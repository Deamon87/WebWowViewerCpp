// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoDatabase.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ProtoDatabase_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ProtoDatabase_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ProtoDatabase_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ProtoDatabase_2eproto {
  static const uint32_t offsets[];
};
class ActiveProcess;
struct ActiveProcessDefaultTypeInternal;
extern ActiveProcessDefaultTypeInternal _ActiveProcess_default_instance_;
class BackfillProgress;
struct BackfillProgressDefaultTypeInternal;
extern BackfillProgressDefaultTypeInternal _BackfillProgress_default_instance_;
class BaseProductState;
struct BaseProductStateDefaultTypeInternal;
extern BaseProductStateDefaultTypeInternal _BaseProductState_default_instance_;
class BuildConfig;
struct BuildConfigDefaultTypeInternal;
extern BuildConfigDefaultTypeInternal _BuildConfig_default_instance_;
class CachedProductState;
struct CachedProductStateDefaultTypeInternal;
extern CachedProductStateDefaultTypeInternal _CachedProductState_default_instance_;
class Database;
struct DatabaseDefaultTypeInternal;
extern DatabaseDefaultTypeInternal _Database_default_instance_;
class DownloadSettings;
struct DownloadSettingsDefaultTypeInternal;
extern DownloadSettingsDefaultTypeInternal _DownloadSettings_default_instance_;
class InstallHandshake;
struct InstallHandshakeDefaultTypeInternal;
extern InstallHandshakeDefaultTypeInternal _InstallHandshake_default_instance_;
class LanguageSetting;
struct LanguageSettingDefaultTypeInternal;
extern LanguageSettingDefaultTypeInternal _LanguageSetting_default_instance_;
class ProductConfig;
struct ProductConfigDefaultTypeInternal;
extern ProductConfigDefaultTypeInternal _ProductConfig_default_instance_;
class ProductInstall;
struct ProductInstallDefaultTypeInternal;
extern ProductInstallDefaultTypeInternal _ProductInstall_default_instance_;
class ProductOperations;
struct ProductOperationsDefaultTypeInternal;
extern ProductOperationsDefaultTypeInternal _ProductOperations_default_instance_;
class RepairProgress;
struct RepairProgressDefaultTypeInternal;
extern RepairProgressDefaultTypeInternal _RepairProgress_default_instance_;
class UpdateProgress;
struct UpdateProgressDefaultTypeInternal;
extern UpdateProgressDefaultTypeInternal _UpdateProgress_default_instance_;
class UserSettings;
struct UserSettingsDefaultTypeInternal;
extern UserSettingsDefaultTypeInternal _UserSettings_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ActiveProcess* Arena::CreateMaybeMessage<::ActiveProcess>(Arena*);
template<> ::BackfillProgress* Arena::CreateMaybeMessage<::BackfillProgress>(Arena*);
template<> ::BaseProductState* Arena::CreateMaybeMessage<::BaseProductState>(Arena*);
template<> ::BuildConfig* Arena::CreateMaybeMessage<::BuildConfig>(Arena*);
template<> ::CachedProductState* Arena::CreateMaybeMessage<::CachedProductState>(Arena*);
template<> ::Database* Arena::CreateMaybeMessage<::Database>(Arena*);
template<> ::DownloadSettings* Arena::CreateMaybeMessage<::DownloadSettings>(Arena*);
template<> ::InstallHandshake* Arena::CreateMaybeMessage<::InstallHandshake>(Arena*);
template<> ::LanguageSetting* Arena::CreateMaybeMessage<::LanguageSetting>(Arena*);
template<> ::ProductConfig* Arena::CreateMaybeMessage<::ProductConfig>(Arena*);
template<> ::ProductInstall* Arena::CreateMaybeMessage<::ProductInstall>(Arena*);
template<> ::ProductOperations* Arena::CreateMaybeMessage<::ProductOperations>(Arena*);
template<> ::RepairProgress* Arena::CreateMaybeMessage<::RepairProgress>(Arena*);
template<> ::UpdateProgress* Arena::CreateMaybeMessage<::UpdateProgress>(Arena*);
template<> ::UserSettings* Arena::CreateMaybeMessage<::UserSettings>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum LanguageOption : int {
  LANGOPTION_NONE = 0,
  LANGOPTION_TEXT = 1,
  LANGOPTION_SPEECH = 2,
  LANGOPTION_TEXT_AND_SPEECH = 3
};
bool LanguageOption_IsValid(int value);
constexpr LanguageOption LanguageOption_MIN = LANGOPTION_NONE;
constexpr LanguageOption LanguageOption_MAX = LANGOPTION_TEXT_AND_SPEECH;
constexpr int LanguageOption_ARRAYSIZE = LanguageOption_MAX + 1;

const std::string& LanguageOption_Name(LanguageOption value);
template<typename T>
inline const std::string& LanguageOption_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LanguageOption>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LanguageOption_Name.");
  return LanguageOption_Name(static_cast<LanguageOption>(enum_t_value));
}
bool LanguageOption_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LanguageOption* value);
enum LanguageSettingType : int {
  LANGSETTING_NONE = 0,
  LANGSETTING_SINGLE = 1,
  LANGSETTING_SIMPLE = 2,
  LANGSETTING_ADVANCED = 3
};
bool LanguageSettingType_IsValid(int value);
constexpr LanguageSettingType LanguageSettingType_MIN = LANGSETTING_NONE;
constexpr LanguageSettingType LanguageSettingType_MAX = LANGSETTING_ADVANCED;
constexpr int LanguageSettingType_ARRAYSIZE = LanguageSettingType_MAX + 1;

const std::string& LanguageSettingType_Name(LanguageSettingType value);
template<typename T>
inline const std::string& LanguageSettingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LanguageSettingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LanguageSettingType_Name.");
  return LanguageSettingType_Name(static_cast<LanguageSettingType>(enum_t_value));
}
bool LanguageSettingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LanguageSettingType* value);
enum ShortcutOption : int {
  SHORTCUT_NONE = 0,
  SHORTCUT_USER = 1,
  SHORTCUT_ALL_USERS = 2
};
bool ShortcutOption_IsValid(int value);
constexpr ShortcutOption ShortcutOption_MIN = SHORTCUT_NONE;
constexpr ShortcutOption ShortcutOption_MAX = SHORTCUT_ALL_USERS;
constexpr int ShortcutOption_ARRAYSIZE = ShortcutOption_MAX + 1;

const std::string& ShortcutOption_Name(ShortcutOption value);
template<typename T>
inline const std::string& ShortcutOption_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShortcutOption>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShortcutOption_Name.");
  return ShortcutOption_Name(static_cast<ShortcutOption>(enum_t_value));
}
bool ShortcutOption_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShortcutOption* value);
enum Operation : int {
  OP_NONE = -1,
  OP_UPDATE = 0,
  OP_BACKFILL = 1,
  OP_REPAIR = 2
};
bool Operation_IsValid(int value);
constexpr Operation Operation_MIN = OP_NONE;
constexpr Operation Operation_MAX = OP_REPAIR;
constexpr int Operation_ARRAYSIZE = Operation_MAX + 1;

const std::string& Operation_Name(Operation value);
template<typename T>
inline const std::string& Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Operation_Name.");
  return Operation_Name(static_cast<Operation>(enum_t_value));
}
bool Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Operation* value);
// ===================================================================

class LanguageSetting final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:LanguageSetting) */ {
 public:
  inline LanguageSetting() : LanguageSetting(nullptr) {}
  ~LanguageSetting() override;
  explicit PROTOBUF_CONSTEXPR LanguageSetting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LanguageSetting(const LanguageSetting& from);
  LanguageSetting(LanguageSetting&& from) noexcept
    : LanguageSetting() {
    *this = ::std::move(from);
  }

  inline LanguageSetting& operator=(const LanguageSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline LanguageSetting& operator=(LanguageSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LanguageSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const LanguageSetting* internal_default_instance() {
    return reinterpret_cast<const LanguageSetting*>(
               &_LanguageSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LanguageSetting& a, LanguageSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(LanguageSetting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LanguageSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LanguageSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LanguageSetting>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LanguageSetting& from);
  void MergeFrom(const LanguageSetting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LanguageSetting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LanguageSetting";
  }
  protected:
  explicit LanguageSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageFieldNumber = 1,
    kOptionFieldNumber = 2,
  };
  // optional string language = 1;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional .LanguageOption option = 2;
  bool has_option() const;
  private:
  bool _internal_has_option() const;
  public:
  void clear_option();
  ::LanguageOption option() const;
  void set_option(::LanguageOption value);
  private:
  ::LanguageOption _internal_option() const;
  void _internal_set_option(::LanguageOption value);
  public:

  // @@protoc_insertion_point(class_scope:LanguageSetting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    int option_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class UserSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:UserSettings) */ {
 public:
  inline UserSettings() : UserSettings(nullptr) {}
  ~UserSettings() override;
  explicit PROTOBUF_CONSTEXPR UserSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSettings(const UserSettings& from);
  UserSettings(UserSettings&& from) noexcept
    : UserSettings() {
    *this = ::std::move(from);
  }

  inline UserSettings& operator=(const UserSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSettings& operator=(UserSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSettings* internal_default_instance() {
    return reinterpret_cast<const UserSettings*>(
               &_UserSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserSettings& a, UserSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserSettings& from);
  void MergeFrom(const UserSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserSettings";
  }
  protected:
  explicit UserSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguagesFieldNumber = 8,
    kInstallPathFieldNumber = 1,
    kPlayRegionFieldNumber = 2,
    kSelectedTextLanguageFieldNumber = 6,
    kSelectedSpeechLanguageFieldNumber = 7,
    kGfxOverrideTagsFieldNumber = 9,
    kVersionbranchFieldNumber = 10,
    kAccountCountryFieldNumber = 11,
    kGeoIpCountryFieldNumber = 12,
    kGameSubfolderFieldNumber = 13,
    kDesktopShortcutFieldNumber = 3,
    kStartmenuShortcutFieldNumber = 4,
    kLanguageSettingsFieldNumber = 5,
  };
  // repeated .LanguageSetting languages = 8;
  int languages_size() const;
  private:
  int _internal_languages_size() const;
  public:
  void clear_languages();
  ::LanguageSetting* mutable_languages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LanguageSetting >*
      mutable_languages();
  private:
  const ::LanguageSetting& _internal_languages(int index) const;
  ::LanguageSetting* _internal_add_languages();
  public:
  const ::LanguageSetting& languages(int index) const;
  ::LanguageSetting* add_languages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LanguageSetting >&
      languages() const;

  // optional string installPath = 1;
  bool has_installpath() const;
  private:
  bool _internal_has_installpath() const;
  public:
  void clear_installpath();
  const std::string& installpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_installpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_installpath();
  PROTOBUF_NODISCARD std::string* release_installpath();
  void set_allocated_installpath(std::string* installpath);
  private:
  const std::string& _internal_installpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_installpath(const std::string& value);
  std::string* _internal_mutable_installpath();
  public:

  // optional string playRegion = 2;
  bool has_playregion() const;
  private:
  bool _internal_has_playregion() const;
  public:
  void clear_playregion();
  const std::string& playregion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playregion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playregion();
  PROTOBUF_NODISCARD std::string* release_playregion();
  void set_allocated_playregion(std::string* playregion);
  private:
  const std::string& _internal_playregion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playregion(const std::string& value);
  std::string* _internal_mutable_playregion();
  public:

  // optional string selectedTextLanguage = 6;
  bool has_selectedtextlanguage() const;
  private:
  bool _internal_has_selectedtextlanguage() const;
  public:
  void clear_selectedtextlanguage();
  const std::string& selectedtextlanguage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selectedtextlanguage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selectedtextlanguage();
  PROTOBUF_NODISCARD std::string* release_selectedtextlanguage();
  void set_allocated_selectedtextlanguage(std::string* selectedtextlanguage);
  private:
  const std::string& _internal_selectedtextlanguage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selectedtextlanguage(const std::string& value);
  std::string* _internal_mutable_selectedtextlanguage();
  public:

  // optional string selectedSpeechLanguage = 7;
  bool has_selectedspeechlanguage() const;
  private:
  bool _internal_has_selectedspeechlanguage() const;
  public:
  void clear_selectedspeechlanguage();
  const std::string& selectedspeechlanguage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selectedspeechlanguage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selectedspeechlanguage();
  PROTOBUF_NODISCARD std::string* release_selectedspeechlanguage();
  void set_allocated_selectedspeechlanguage(std::string* selectedspeechlanguage);
  private:
  const std::string& _internal_selectedspeechlanguage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selectedspeechlanguage(const std::string& value);
  std::string* _internal_mutable_selectedspeechlanguage();
  public:

  // optional string gfx_override_tags = 9;
  bool has_gfx_override_tags() const;
  private:
  bool _internal_has_gfx_override_tags() const;
  public:
  void clear_gfx_override_tags();
  const std::string& gfx_override_tags() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gfx_override_tags(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gfx_override_tags();
  PROTOBUF_NODISCARD std::string* release_gfx_override_tags();
  void set_allocated_gfx_override_tags(std::string* gfx_override_tags);
  private:
  const std::string& _internal_gfx_override_tags() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gfx_override_tags(const std::string& value);
  std::string* _internal_mutable_gfx_override_tags();
  public:

  // optional string versionbranch = 10;
  bool has_versionbranch() const;
  private:
  bool _internal_has_versionbranch() const;
  public:
  void clear_versionbranch();
  const std::string& versionbranch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_versionbranch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_versionbranch();
  PROTOBUF_NODISCARD std::string* release_versionbranch();
  void set_allocated_versionbranch(std::string* versionbranch);
  private:
  const std::string& _internal_versionbranch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_versionbranch(const std::string& value);
  std::string* _internal_mutable_versionbranch();
  public:

  // optional string accountCountry = 11;
  bool has_accountcountry() const;
  private:
  bool _internal_has_accountcountry() const;
  public:
  void clear_accountcountry();
  const std::string& accountcountry() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accountcountry(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accountcountry();
  PROTOBUF_NODISCARD std::string* release_accountcountry();
  void set_allocated_accountcountry(std::string* accountcountry);
  private:
  const std::string& _internal_accountcountry() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accountcountry(const std::string& value);
  std::string* _internal_mutable_accountcountry();
  public:

  // optional string geoIpCountry = 12;
  bool has_geoipcountry() const;
  private:
  bool _internal_has_geoipcountry() const;
  public:
  void clear_geoipcountry();
  const std::string& geoipcountry() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_geoipcountry(ArgT0&& arg0, ArgT... args);
  std::string* mutable_geoipcountry();
  PROTOBUF_NODISCARD std::string* release_geoipcountry();
  void set_allocated_geoipcountry(std::string* geoipcountry);
  private:
  const std::string& _internal_geoipcountry() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_geoipcountry(const std::string& value);
  std::string* _internal_mutable_geoipcountry();
  public:

  // optional string gameSubfolder = 13;
  bool has_gamesubfolder() const;
  private:
  bool _internal_has_gamesubfolder() const;
  public:
  void clear_gamesubfolder();
  const std::string& gamesubfolder() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gamesubfolder(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gamesubfolder();
  PROTOBUF_NODISCARD std::string* release_gamesubfolder();
  void set_allocated_gamesubfolder(std::string* gamesubfolder);
  private:
  const std::string& _internal_gamesubfolder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gamesubfolder(const std::string& value);
  std::string* _internal_mutable_gamesubfolder();
  public:

  // optional .ShortcutOption desktopShortcut = 3;
  bool has_desktopshortcut() const;
  private:
  bool _internal_has_desktopshortcut() const;
  public:
  void clear_desktopshortcut();
  ::ShortcutOption desktopshortcut() const;
  void set_desktopshortcut(::ShortcutOption value);
  private:
  ::ShortcutOption _internal_desktopshortcut() const;
  void _internal_set_desktopshortcut(::ShortcutOption value);
  public:

  // optional .ShortcutOption startmenuShortcut = 4;
  bool has_startmenushortcut() const;
  private:
  bool _internal_has_startmenushortcut() const;
  public:
  void clear_startmenushortcut();
  ::ShortcutOption startmenushortcut() const;
  void set_startmenushortcut(::ShortcutOption value);
  private:
  ::ShortcutOption _internal_startmenushortcut() const;
  void _internal_set_startmenushortcut(::ShortcutOption value);
  public:

  // optional .LanguageSettingType languageSettings = 5;
  bool has_languagesettings() const;
  private:
  bool _internal_has_languagesettings() const;
  public:
  void clear_languagesettings();
  ::LanguageSettingType languagesettings() const;
  void set_languagesettings(::LanguageSettingType value);
  private:
  ::LanguageSettingType _internal_languagesettings() const;
  void _internal_set_languagesettings(::LanguageSettingType value);
  public:

  // @@protoc_insertion_point(class_scope:UserSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LanguageSetting > languages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr installpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playregion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selectedtextlanguage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selectedspeechlanguage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gfx_override_tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr versionbranch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accountcountry_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr geoipcountry_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamesubfolder_;
    int desktopshortcut_;
    int startmenushortcut_;
    int languagesettings_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class InstallHandshake final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:InstallHandshake) */ {
 public:
  inline InstallHandshake() : InstallHandshake(nullptr) {}
  ~InstallHandshake() override;
  explicit PROTOBUF_CONSTEXPR InstallHandshake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstallHandshake(const InstallHandshake& from);
  InstallHandshake(InstallHandshake&& from) noexcept
    : InstallHandshake() {
    *this = ::std::move(from);
  }

  inline InstallHandshake& operator=(const InstallHandshake& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallHandshake& operator=(InstallHandshake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InstallHandshake& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallHandshake* internal_default_instance() {
    return reinterpret_cast<const InstallHandshake*>(
               &_InstallHandshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InstallHandshake& a, InstallHandshake& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallHandshake* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallHandshake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallHandshake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallHandshake>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InstallHandshake& from);
  void MergeFrom(const InstallHandshake& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InstallHandshake* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InstallHandshake";
  }
  protected:
  explicit InstallHandshake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductFieldNumber = 1,
    kUidFieldNumber = 2,
    kSettingsFieldNumber = 3,
  };
  // optional string product = 1;
  bool has_product() const;
  private:
  bool _internal_has_product() const;
  public:
  void clear_product();
  const std::string& product() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product();
  PROTOBUF_NODISCARD std::string* release_product();
  void set_allocated_product(std::string* product);
  private:
  const std::string& _internal_product() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product(const std::string& value);
  std::string* _internal_mutable_product();
  public:

  // optional string uid = 2;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // optional .UserSettings settings = 3;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::UserSettings& settings() const;
  PROTOBUF_NODISCARD ::UserSettings* release_settings();
  ::UserSettings* mutable_settings();
  void set_allocated_settings(::UserSettings* settings);
  private:
  const ::UserSettings& _internal_settings() const;
  ::UserSettings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::UserSettings* settings);
  ::UserSettings* unsafe_arena_release_settings();

  // @@protoc_insertion_point(class_scope:InstallHandshake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::UserSettings* settings_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class BuildConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:BuildConfig) */ {
 public:
  inline BuildConfig() : BuildConfig(nullptr) {}
  ~BuildConfig() override;
  explicit PROTOBUF_CONSTEXPR BuildConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuildConfig(const BuildConfig& from);
  BuildConfig(BuildConfig&& from) noexcept
    : BuildConfig() {
    *this = ::std::move(from);
  }

  inline BuildConfig& operator=(const BuildConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildConfig& operator=(BuildConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BuildConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuildConfig* internal_default_instance() {
    return reinterpret_cast<const BuildConfig*>(
               &_BuildConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BuildConfig& a, BuildConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuildConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuildConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BuildConfig& from);
  void MergeFrom(const BuildConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BuildConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BuildConfig";
  }
  protected:
  explicit BuildConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kBuildConfigFieldNumber = 2,
  };
  // optional string region = 1;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // optional string buildConfig = 2;
  bool has_buildconfig() const;
  private:
  bool _internal_has_buildconfig() const;
  public:
  void clear_buildconfig();
  const std::string& buildconfig() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buildconfig(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buildconfig();
  PROTOBUF_NODISCARD std::string* release_buildconfig();
  void set_allocated_buildconfig(std::string* buildconfig);
  private:
  const std::string& _internal_buildconfig() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buildconfig(const std::string& value);
  std::string* _internal_mutable_buildconfig();
  public:

  // @@protoc_insertion_point(class_scope:BuildConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buildconfig_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class BaseProductState final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:BaseProductState) */ {
 public:
  inline BaseProductState() : BaseProductState(nullptr) {}
  ~BaseProductState() override;
  explicit PROTOBUF_CONSTEXPR BaseProductState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseProductState(const BaseProductState& from);
  BaseProductState(BaseProductState&& from) noexcept
    : BaseProductState() {
    *this = ::std::move(from);
  }

  inline BaseProductState& operator=(const BaseProductState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseProductState& operator=(BaseProductState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BaseProductState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseProductState* internal_default_instance() {
    return reinterpret_cast<const BaseProductState*>(
               &_BaseProductState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BaseProductState& a, BaseProductState& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseProductState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseProductState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseProductState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseProductState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BaseProductState& from);
  void MergeFrom(const BaseProductState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BaseProductState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BaseProductState";
  }
  protected:
  explicit BaseProductState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstalledBuildConfigFieldNumber = 8,
    kBackgroundDownloadBuildConfigFieldNumber = 9,
    kCompletedInstallActionsFieldNumber = 11,
    kCompletedBuildKeysFieldNumber = 12,
    kCompletedBgdlKeysFieldNumber = 13,
    kActiveBuildKeyFieldNumber = 14,
    kActiveBgdlKeyFieldNumber = 15,
    kActiveInstallKeyFieldNumber = 16,
    kActiveTagStringFieldNumber = 17,
    kIncompleteBuildKeyFieldNumber = 18,
    kCurrentVersionFieldNumber = 6,
    kCurrentVersionStrFieldNumber = 7,
    kDecryptionKeyFieldNumber = 10,
    kInstalledFieldNumber = 1,
    kPlayableFieldNumber = 2,
    kUpdateCompleteFieldNumber = 3,
    kBackgroundDownloadAvailableFieldNumber = 4,
    kBackgroundDownloadCompleteFieldNumber = 5,
  };
  // repeated .BuildConfig installedBuildConfig = 8;
  int installedbuildconfig_size() const;
  private:
  int _internal_installedbuildconfig_size() const;
  public:
  void clear_installedbuildconfig();
  ::BuildConfig* mutable_installedbuildconfig(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >*
      mutable_installedbuildconfig();
  private:
  const ::BuildConfig& _internal_installedbuildconfig(int index) const;
  ::BuildConfig* _internal_add_installedbuildconfig();
  public:
  const ::BuildConfig& installedbuildconfig(int index) const;
  ::BuildConfig* add_installedbuildconfig();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >&
      installedbuildconfig() const;

  // repeated .BuildConfig backgroundDownloadBuildConfig = 9;
  int backgrounddownloadbuildconfig_size() const;
  private:
  int _internal_backgrounddownloadbuildconfig_size() const;
  public:
  void clear_backgrounddownloadbuildconfig();
  ::BuildConfig* mutable_backgrounddownloadbuildconfig(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >*
      mutable_backgrounddownloadbuildconfig();
  private:
  const ::BuildConfig& _internal_backgrounddownloadbuildconfig(int index) const;
  ::BuildConfig* _internal_add_backgrounddownloadbuildconfig();
  public:
  const ::BuildConfig& backgrounddownloadbuildconfig(int index) const;
  ::BuildConfig* add_backgrounddownloadbuildconfig();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >&
      backgrounddownloadbuildconfig() const;

  // repeated string completedInstallActions = 11;
  int completedinstallactions_size() const;
  private:
  int _internal_completedinstallactions_size() const;
  public:
  void clear_completedinstallactions();
  const std::string& completedinstallactions(int index) const;
  std::string* mutable_completedinstallactions(int index);
  void set_completedinstallactions(int index, const std::string& value);
  void set_completedinstallactions(int index, std::string&& value);
  void set_completedinstallactions(int index, const char* value);
  void set_completedinstallactions(int index, const char* value, size_t size);
  std::string* add_completedinstallactions();
  void add_completedinstallactions(const std::string& value);
  void add_completedinstallactions(std::string&& value);
  void add_completedinstallactions(const char* value);
  void add_completedinstallactions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& completedinstallactions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_completedinstallactions();
  private:
  const std::string& _internal_completedinstallactions(int index) const;
  std::string* _internal_add_completedinstallactions();
  public:

  // repeated string completedBuildKeys = 12;
  int completedbuildkeys_size() const;
  private:
  int _internal_completedbuildkeys_size() const;
  public:
  void clear_completedbuildkeys();
  const std::string& completedbuildkeys(int index) const;
  std::string* mutable_completedbuildkeys(int index);
  void set_completedbuildkeys(int index, const std::string& value);
  void set_completedbuildkeys(int index, std::string&& value);
  void set_completedbuildkeys(int index, const char* value);
  void set_completedbuildkeys(int index, const char* value, size_t size);
  std::string* add_completedbuildkeys();
  void add_completedbuildkeys(const std::string& value);
  void add_completedbuildkeys(std::string&& value);
  void add_completedbuildkeys(const char* value);
  void add_completedbuildkeys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& completedbuildkeys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_completedbuildkeys();
  private:
  const std::string& _internal_completedbuildkeys(int index) const;
  std::string* _internal_add_completedbuildkeys();
  public:

  // repeated string completedBgdlKeys = 13;
  int completedbgdlkeys_size() const;
  private:
  int _internal_completedbgdlkeys_size() const;
  public:
  void clear_completedbgdlkeys();
  const std::string& completedbgdlkeys(int index) const;
  std::string* mutable_completedbgdlkeys(int index);
  void set_completedbgdlkeys(int index, const std::string& value);
  void set_completedbgdlkeys(int index, std::string&& value);
  void set_completedbgdlkeys(int index, const char* value);
  void set_completedbgdlkeys(int index, const char* value, size_t size);
  std::string* add_completedbgdlkeys();
  void add_completedbgdlkeys(const std::string& value);
  void add_completedbgdlkeys(std::string&& value);
  void add_completedbgdlkeys(const char* value);
  void add_completedbgdlkeys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& completedbgdlkeys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_completedbgdlkeys();
  private:
  const std::string& _internal_completedbgdlkeys(int index) const;
  std::string* _internal_add_completedbgdlkeys();
  public:

  // repeated string activeBuildKey = 14;
  int activebuildkey_size() const;
  private:
  int _internal_activebuildkey_size() const;
  public:
  void clear_activebuildkey();
  const std::string& activebuildkey(int index) const;
  std::string* mutable_activebuildkey(int index);
  void set_activebuildkey(int index, const std::string& value);
  void set_activebuildkey(int index, std::string&& value);
  void set_activebuildkey(int index, const char* value);
  void set_activebuildkey(int index, const char* value, size_t size);
  std::string* add_activebuildkey();
  void add_activebuildkey(const std::string& value);
  void add_activebuildkey(std::string&& value);
  void add_activebuildkey(const char* value);
  void add_activebuildkey(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& activebuildkey() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_activebuildkey();
  private:
  const std::string& _internal_activebuildkey(int index) const;
  std::string* _internal_add_activebuildkey();
  public:

  // repeated string activeBgdlKey = 15;
  int activebgdlkey_size() const;
  private:
  int _internal_activebgdlkey_size() const;
  public:
  void clear_activebgdlkey();
  const std::string& activebgdlkey(int index) const;
  std::string* mutable_activebgdlkey(int index);
  void set_activebgdlkey(int index, const std::string& value);
  void set_activebgdlkey(int index, std::string&& value);
  void set_activebgdlkey(int index, const char* value);
  void set_activebgdlkey(int index, const char* value, size_t size);
  std::string* add_activebgdlkey();
  void add_activebgdlkey(const std::string& value);
  void add_activebgdlkey(std::string&& value);
  void add_activebgdlkey(const char* value);
  void add_activebgdlkey(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& activebgdlkey() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_activebgdlkey();
  private:
  const std::string& _internal_activebgdlkey(int index) const;
  std::string* _internal_add_activebgdlkey();
  public:

  // repeated string activeInstallKey = 16;
  int activeinstallkey_size() const;
  private:
  int _internal_activeinstallkey_size() const;
  public:
  void clear_activeinstallkey();
  const std::string& activeinstallkey(int index) const;
  std::string* mutable_activeinstallkey(int index);
  void set_activeinstallkey(int index, const std::string& value);
  void set_activeinstallkey(int index, std::string&& value);
  void set_activeinstallkey(int index, const char* value);
  void set_activeinstallkey(int index, const char* value, size_t size);
  std::string* add_activeinstallkey();
  void add_activeinstallkey(const std::string& value);
  void add_activeinstallkey(std::string&& value);
  void add_activeinstallkey(const char* value);
  void add_activeinstallkey(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& activeinstallkey() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_activeinstallkey();
  private:
  const std::string& _internal_activeinstallkey(int index) const;
  std::string* _internal_add_activeinstallkey();
  public:

  // repeated string activeTagString = 17;
  int activetagstring_size() const;
  private:
  int _internal_activetagstring_size() const;
  public:
  void clear_activetagstring();
  const std::string& activetagstring(int index) const;
  std::string* mutable_activetagstring(int index);
  void set_activetagstring(int index, const std::string& value);
  void set_activetagstring(int index, std::string&& value);
  void set_activetagstring(int index, const char* value);
  void set_activetagstring(int index, const char* value, size_t size);
  std::string* add_activetagstring();
  void add_activetagstring(const std::string& value);
  void add_activetagstring(std::string&& value);
  void add_activetagstring(const char* value);
  void add_activetagstring(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& activetagstring() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_activetagstring();
  private:
  const std::string& _internal_activetagstring(int index) const;
  std::string* _internal_add_activetagstring();
  public:

  // repeated string incompleteBuildKey = 18;
  int incompletebuildkey_size() const;
  private:
  int _internal_incompletebuildkey_size() const;
  public:
  void clear_incompletebuildkey();
  const std::string& incompletebuildkey(int index) const;
  std::string* mutable_incompletebuildkey(int index);
  void set_incompletebuildkey(int index, const std::string& value);
  void set_incompletebuildkey(int index, std::string&& value);
  void set_incompletebuildkey(int index, const char* value);
  void set_incompletebuildkey(int index, const char* value, size_t size);
  std::string* add_incompletebuildkey();
  void add_incompletebuildkey(const std::string& value);
  void add_incompletebuildkey(std::string&& value);
  void add_incompletebuildkey(const char* value);
  void add_incompletebuildkey(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& incompletebuildkey() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_incompletebuildkey();
  private:
  const std::string& _internal_incompletebuildkey(int index) const;
  std::string* _internal_add_incompletebuildkey();
  public:

  // optional string currentVersion = 6;
  bool has_currentversion() const;
  private:
  bool _internal_has_currentversion() const;
  public:
  void clear_currentversion();
  const std::string& currentversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currentversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currentversion();
  PROTOBUF_NODISCARD std::string* release_currentversion();
  void set_allocated_currentversion(std::string* currentversion);
  private:
  const std::string& _internal_currentversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currentversion(const std::string& value);
  std::string* _internal_mutable_currentversion();
  public:

  // optional string currentVersionStr = 7;
  bool has_currentversionstr() const;
  private:
  bool _internal_has_currentversionstr() const;
  public:
  void clear_currentversionstr();
  const std::string& currentversionstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currentversionstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currentversionstr();
  PROTOBUF_NODISCARD std::string* release_currentversionstr();
  void set_allocated_currentversionstr(std::string* currentversionstr);
  private:
  const std::string& _internal_currentversionstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currentversionstr(const std::string& value);
  std::string* _internal_mutable_currentversionstr();
  public:

  // optional string decryptionKey = 10;
  bool has_decryptionkey() const;
  private:
  bool _internal_has_decryptionkey() const;
  public:
  void clear_decryptionkey();
  const std::string& decryptionkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_decryptionkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_decryptionkey();
  PROTOBUF_NODISCARD std::string* release_decryptionkey();
  void set_allocated_decryptionkey(std::string* decryptionkey);
  private:
  const std::string& _internal_decryptionkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_decryptionkey(const std::string& value);
  std::string* _internal_mutable_decryptionkey();
  public:

  // optional bool installed = 1;
  bool has_installed() const;
  private:
  bool _internal_has_installed() const;
  public:
  void clear_installed();
  bool installed() const;
  void set_installed(bool value);
  private:
  bool _internal_installed() const;
  void _internal_set_installed(bool value);
  public:

  // optional bool playable = 2;
  bool has_playable() const;
  private:
  bool _internal_has_playable() const;
  public:
  void clear_playable();
  bool playable() const;
  void set_playable(bool value);
  private:
  bool _internal_playable() const;
  void _internal_set_playable(bool value);
  public:

  // optional bool updateComplete = 3;
  bool has_updatecomplete() const;
  private:
  bool _internal_has_updatecomplete() const;
  public:
  void clear_updatecomplete();
  bool updatecomplete() const;
  void set_updatecomplete(bool value);
  private:
  bool _internal_updatecomplete() const;
  void _internal_set_updatecomplete(bool value);
  public:

  // optional bool backgroundDownloadAvailable = 4;
  bool has_backgrounddownloadavailable() const;
  private:
  bool _internal_has_backgrounddownloadavailable() const;
  public:
  void clear_backgrounddownloadavailable();
  bool backgrounddownloadavailable() const;
  void set_backgrounddownloadavailable(bool value);
  private:
  bool _internal_backgrounddownloadavailable() const;
  void _internal_set_backgrounddownloadavailable(bool value);
  public:

  // optional bool backgroundDownloadComplete = 5;
  bool has_backgrounddownloadcomplete() const;
  private:
  bool _internal_has_backgrounddownloadcomplete() const;
  public:
  void clear_backgrounddownloadcomplete();
  bool backgrounddownloadcomplete() const;
  void set_backgrounddownloadcomplete(bool value);
  private:
  bool _internal_backgrounddownloadcomplete() const;
  void _internal_set_backgrounddownloadcomplete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:BaseProductState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig > installedbuildconfig_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig > backgrounddownloadbuildconfig_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> completedinstallactions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> completedbuildkeys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> completedbgdlkeys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> activebuildkey_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> activebgdlkey_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> activeinstallkey_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> activetagstring_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> incompletebuildkey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currentversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currentversionstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr decryptionkey_;
    bool installed_;
    bool playable_;
    bool updatecomplete_;
    bool backgrounddownloadavailable_;
    bool backgrounddownloadcomplete_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class BackfillProgress final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:BackfillProgress) */ {
 public:
  inline BackfillProgress() : BackfillProgress(nullptr) {}
  ~BackfillProgress() override;
  explicit PROTOBUF_CONSTEXPR BackfillProgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BackfillProgress(const BackfillProgress& from);
  BackfillProgress(BackfillProgress&& from) noexcept
    : BackfillProgress() {
    *this = ::std::move(from);
  }

  inline BackfillProgress& operator=(const BackfillProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackfillProgress& operator=(BackfillProgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BackfillProgress& default_instance() {
    return *internal_default_instance();
  }
  static inline const BackfillProgress* internal_default_instance() {
    return reinterpret_cast<const BackfillProgress*>(
               &_BackfillProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BackfillProgress& a, BackfillProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(BackfillProgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackfillProgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BackfillProgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BackfillProgress>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BackfillProgress& from);
  void MergeFrom(const BackfillProgress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BackfillProgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BackfillProgress";
  }
  protected:
  explicit BackfillProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProgressFieldNumber = 1,
    kDownloadLimitFieldNumber = 4,
    kBackgrounddownloadFieldNumber = 2,
    kPausedFieldNumber = 3,
  };
  // optional double progress = 1;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  double progress() const;
  void set_progress(double value);
  private:
  double _internal_progress() const;
  void _internal_set_progress(double value);
  public:

  // optional uint64 downloadLimit = 4;
  bool has_downloadlimit() const;
  private:
  bool _internal_has_downloadlimit() const;
  public:
  void clear_downloadlimit();
  uint64_t downloadlimit() const;
  void set_downloadlimit(uint64_t value);
  private:
  uint64_t _internal_downloadlimit() const;
  void _internal_set_downloadlimit(uint64_t value);
  public:

  // optional bool backgrounddownload = 2;
  bool has_backgrounddownload() const;
  private:
  bool _internal_has_backgrounddownload() const;
  public:
  void clear_backgrounddownload();
  bool backgrounddownload() const;
  void set_backgrounddownload(bool value);
  private:
  bool _internal_backgrounddownload() const;
  void _internal_set_backgrounddownload(bool value);
  public:

  // optional bool paused = 3;
  bool has_paused() const;
  private:
  bool _internal_has_paused() const;
  public:
  void clear_paused();
  bool paused() const;
  void set_paused(bool value);
  private:
  bool _internal_paused() const;
  void _internal_set_paused(bool value);
  public:

  // @@protoc_insertion_point(class_scope:BackfillProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double progress_;
    uint64_t downloadlimit_;
    bool backgrounddownload_;
    bool paused_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class RepairProgress final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:RepairProgress) */ {
 public:
  inline RepairProgress() : RepairProgress(nullptr) {}
  ~RepairProgress() override;
  explicit PROTOBUF_CONSTEXPR RepairProgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RepairProgress(const RepairProgress& from);
  RepairProgress(RepairProgress&& from) noexcept
    : RepairProgress() {
    *this = ::std::move(from);
  }

  inline RepairProgress& operator=(const RepairProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepairProgress& operator=(RepairProgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RepairProgress& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepairProgress* internal_default_instance() {
    return reinterpret_cast<const RepairProgress*>(
               &_RepairProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RepairProgress& a, RepairProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(RepairProgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepairProgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepairProgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepairProgress>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RepairProgress& from);
  void MergeFrom(const RepairProgress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RepairProgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RepairProgress";
  }
  protected:
  explicit RepairProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProgressFieldNumber = 1,
  };
  // optional double progress = 1;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  double progress() const;
  void set_progress(double value);
  private:
  double _internal_progress() const;
  void _internal_set_progress(double value);
  public:

  // @@protoc_insertion_point(class_scope:RepairProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double progress_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class UpdateProgress final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:UpdateProgress) */ {
 public:
  inline UpdateProgress() : UpdateProgress(nullptr) {}
  ~UpdateProgress() override;
  explicit PROTOBUF_CONSTEXPR UpdateProgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateProgress(const UpdateProgress& from);
  UpdateProgress(UpdateProgress&& from) noexcept
    : UpdateProgress() {
    *this = ::std::move(from);
  }

  inline UpdateProgress& operator=(const UpdateProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateProgress& operator=(UpdateProgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UpdateProgress& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateProgress* internal_default_instance() {
    return reinterpret_cast<const UpdateProgress*>(
               &_UpdateProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpdateProgress& a, UpdateProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateProgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateProgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateProgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateProgress>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UpdateProgress& from);
  void MergeFrom(const UpdateProgress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpdateProgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UpdateProgress";
  }
  protected:
  explicit UpdateProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastDiscSetUsedFieldNumber = 1,
    kProgressFieldNumber = 2,
    kTotalToDownloadFieldNumber = 4,
    kDownloadRemainingFieldNumber = 5,
    kDiscIgnoredFieldNumber = 3,
  };
  // optional string lastDiscSetUsed = 1;
  bool has_lastdiscsetused() const;
  private:
  bool _internal_has_lastdiscsetused() const;
  public:
  void clear_lastdiscsetused();
  const std::string& lastdiscsetused() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lastdiscsetused(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lastdiscsetused();
  PROTOBUF_NODISCARD std::string* release_lastdiscsetused();
  void set_allocated_lastdiscsetused(std::string* lastdiscsetused);
  private:
  const std::string& _internal_lastdiscsetused() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lastdiscsetused(const std::string& value);
  std::string* _internal_mutable_lastdiscsetused();
  public:

  // optional double progress = 2;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  double progress() const;
  void set_progress(double value);
  private:
  double _internal_progress() const;
  void _internal_set_progress(double value);
  public:

  // optional uint64 totalToDownload = 4 [default = 0];
  bool has_totaltodownload() const;
  private:
  bool _internal_has_totaltodownload() const;
  public:
  void clear_totaltodownload();
  uint64_t totaltodownload() const;
  void set_totaltodownload(uint64_t value);
  private:
  uint64_t _internal_totaltodownload() const;
  void _internal_set_totaltodownload(uint64_t value);
  public:

  // optional uint64 downloadRemaining = 5 [default = 0];
  bool has_downloadremaining() const;
  private:
  bool _internal_has_downloadremaining() const;
  public:
  void clear_downloadremaining();
  uint64_t downloadremaining() const;
  void set_downloadremaining(uint64_t value);
  private:
  uint64_t _internal_downloadremaining() const;
  void _internal_set_downloadremaining(uint64_t value);
  public:

  // optional bool discIgnored = 3;
  bool has_discignored() const;
  private:
  bool _internal_has_discignored() const;
  public:
  void clear_discignored();
  bool discignored() const;
  void set_discignored(bool value);
  private:
  bool _internal_discignored() const;
  void _internal_set_discignored(bool value);
  public:

  // @@protoc_insertion_point(class_scope:UpdateProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lastdiscsetused_;
    double progress_;
    uint64_t totaltodownload_;
    uint64_t downloadremaining_;
    bool discignored_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class CachedProductState final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CachedProductState) */ {
 public:
  inline CachedProductState() : CachedProductState(nullptr) {}
  ~CachedProductState() override;
  explicit PROTOBUF_CONSTEXPR CachedProductState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CachedProductState(const CachedProductState& from);
  CachedProductState(CachedProductState&& from) noexcept
    : CachedProductState() {
    *this = ::std::move(from);
  }

  inline CachedProductState& operator=(const CachedProductState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CachedProductState& operator=(CachedProductState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CachedProductState& default_instance() {
    return *internal_default_instance();
  }
  static inline const CachedProductState* internal_default_instance() {
    return reinterpret_cast<const CachedProductState*>(
               &_CachedProductState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CachedProductState& a, CachedProductState& b) {
    a.Swap(&b);
  }
  inline void Swap(CachedProductState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CachedProductState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CachedProductState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CachedProductState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CachedProductState& from);
  void MergeFrom(const CachedProductState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CachedProductState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CachedProductState";
  }
  protected:
  explicit CachedProductState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseProductStateFieldNumber = 1,
    kBackfillProgressFieldNumber = 2,
    kRepairProgressFieldNumber = 3,
    kUpdateProgressFieldNumber = 4,
  };
  // optional .BaseProductState baseProductState = 1;
  bool has_baseproductstate() const;
  private:
  bool _internal_has_baseproductstate() const;
  public:
  void clear_baseproductstate();
  const ::BaseProductState& baseproductstate() const;
  PROTOBUF_NODISCARD ::BaseProductState* release_baseproductstate();
  ::BaseProductState* mutable_baseproductstate();
  void set_allocated_baseproductstate(::BaseProductState* baseproductstate);
  private:
  const ::BaseProductState& _internal_baseproductstate() const;
  ::BaseProductState* _internal_mutable_baseproductstate();
  public:
  void unsafe_arena_set_allocated_baseproductstate(
      ::BaseProductState* baseproductstate);
  ::BaseProductState* unsafe_arena_release_baseproductstate();

  // optional .BackfillProgress backfillProgress = 2;
  bool has_backfillprogress() const;
  private:
  bool _internal_has_backfillprogress() const;
  public:
  void clear_backfillprogress();
  const ::BackfillProgress& backfillprogress() const;
  PROTOBUF_NODISCARD ::BackfillProgress* release_backfillprogress();
  ::BackfillProgress* mutable_backfillprogress();
  void set_allocated_backfillprogress(::BackfillProgress* backfillprogress);
  private:
  const ::BackfillProgress& _internal_backfillprogress() const;
  ::BackfillProgress* _internal_mutable_backfillprogress();
  public:
  void unsafe_arena_set_allocated_backfillprogress(
      ::BackfillProgress* backfillprogress);
  ::BackfillProgress* unsafe_arena_release_backfillprogress();

  // optional .RepairProgress repairProgress = 3;
  bool has_repairprogress() const;
  private:
  bool _internal_has_repairprogress() const;
  public:
  void clear_repairprogress();
  const ::RepairProgress& repairprogress() const;
  PROTOBUF_NODISCARD ::RepairProgress* release_repairprogress();
  ::RepairProgress* mutable_repairprogress();
  void set_allocated_repairprogress(::RepairProgress* repairprogress);
  private:
  const ::RepairProgress& _internal_repairprogress() const;
  ::RepairProgress* _internal_mutable_repairprogress();
  public:
  void unsafe_arena_set_allocated_repairprogress(
      ::RepairProgress* repairprogress);
  ::RepairProgress* unsafe_arena_release_repairprogress();

  // optional .UpdateProgress updateProgress = 4;
  bool has_updateprogress() const;
  private:
  bool _internal_has_updateprogress() const;
  public:
  void clear_updateprogress();
  const ::UpdateProgress& updateprogress() const;
  PROTOBUF_NODISCARD ::UpdateProgress* release_updateprogress();
  ::UpdateProgress* mutable_updateprogress();
  void set_allocated_updateprogress(::UpdateProgress* updateprogress);
  private:
  const ::UpdateProgress& _internal_updateprogress() const;
  ::UpdateProgress* _internal_mutable_updateprogress();
  public:
  void unsafe_arena_set_allocated_updateprogress(
      ::UpdateProgress* updateprogress);
  ::UpdateProgress* unsafe_arena_release_updateprogress();

  // @@protoc_insertion_point(class_scope:CachedProductState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::BaseProductState* baseproductstate_;
    ::BackfillProgress* backfillprogress_;
    ::RepairProgress* repairprogress_;
    ::UpdateProgress* updateprogress_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class ProductOperations final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ProductOperations) */ {
 public:
  inline ProductOperations() : ProductOperations(nullptr) {}
  ~ProductOperations() override;
  explicit PROTOBUF_CONSTEXPR ProductOperations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProductOperations(const ProductOperations& from);
  ProductOperations(ProductOperations&& from) noexcept
    : ProductOperations() {
    *this = ::std::move(from);
  }

  inline ProductOperations& operator=(const ProductOperations& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProductOperations& operator=(ProductOperations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ProductOperations& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProductOperations* internal_default_instance() {
    return reinterpret_cast<const ProductOperations*>(
               &_ProductOperations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ProductOperations& a, ProductOperations& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductOperations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductOperations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProductOperations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProductOperations>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProductOperations& from);
  void MergeFrom(const ProductOperations& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProductOperations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProductOperations";
  }
  protected:
  explicit ProductOperations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriorityFieldNumber = 2,
    kActiveOperationFieldNumber = 1,
  };
  // optional uint64 priority = 2;
  bool has_priority() const;
  private:
  bool _internal_has_priority() const;
  public:
  void clear_priority();
  uint64_t priority() const;
  void set_priority(uint64_t value);
  private:
  uint64_t _internal_priority() const;
  void _internal_set_priority(uint64_t value);
  public:

  // optional .Operation activeOperation = 1 [default = OP_NONE];
  bool has_activeoperation() const;
  private:
  bool _internal_has_activeoperation() const;
  public:
  void clear_activeoperation();
  ::Operation activeoperation() const;
  void set_activeoperation(::Operation value);
  private:
  ::Operation _internal_activeoperation() const;
  void _internal_set_activeoperation(::Operation value);
  public:

  // @@protoc_insertion_point(class_scope:ProductOperations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t priority_;
    int activeoperation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class ProductInstall final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ProductInstall) */ {
 public:
  inline ProductInstall() : ProductInstall(nullptr) {}
  ~ProductInstall() override;
  explicit PROTOBUF_CONSTEXPR ProductInstall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProductInstall(const ProductInstall& from);
  ProductInstall(ProductInstall&& from) noexcept
    : ProductInstall() {
    *this = ::std::move(from);
  }

  inline ProductInstall& operator=(const ProductInstall& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProductInstall& operator=(ProductInstall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ProductInstall& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProductInstall* internal_default_instance() {
    return reinterpret_cast<const ProductInstall*>(
               &_ProductInstall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ProductInstall& a, ProductInstall& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductInstall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductInstall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProductInstall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProductInstall>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProductInstall& from);
  void MergeFrom(const ProductInstall& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProductInstall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProductInstall";
  }
  protected:
  explicit ProductInstall(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kProductCodeFieldNumber = 2,
    kProductFamilyFieldNumber = 6,
    kPersistentJsonStorageFieldNumber = 8,
    kSettingsFieldNumber = 3,
    kCachedProductStateFieldNumber = 4,
    kProductOperationsFieldNumber = 5,
    kHiddenFieldNumber = 7,
  };
  // optional string uid = 1;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // optional string productCode = 2;
  bool has_productcode() const;
  private:
  bool _internal_has_productcode() const;
  public:
  void clear_productcode();
  const std::string& productcode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_productcode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_productcode();
  PROTOBUF_NODISCARD std::string* release_productcode();
  void set_allocated_productcode(std::string* productcode);
  private:
  const std::string& _internal_productcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productcode(const std::string& value);
  std::string* _internal_mutable_productcode();
  public:

  // optional string productFamily = 6;
  bool has_productfamily() const;
  private:
  bool _internal_has_productfamily() const;
  public:
  void clear_productfamily();
  const std::string& productfamily() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_productfamily(ArgT0&& arg0, ArgT... args);
  std::string* mutable_productfamily();
  PROTOBUF_NODISCARD std::string* release_productfamily();
  void set_allocated_productfamily(std::string* productfamily);
  private:
  const std::string& _internal_productfamily() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productfamily(const std::string& value);
  std::string* _internal_mutable_productfamily();
  public:

  // optional string persistentJsonStorage = 8;
  bool has_persistentjsonstorage() const;
  private:
  bool _internal_has_persistentjsonstorage() const;
  public:
  void clear_persistentjsonstorage();
  const std::string& persistentjsonstorage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_persistentjsonstorage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_persistentjsonstorage();
  PROTOBUF_NODISCARD std::string* release_persistentjsonstorage();
  void set_allocated_persistentjsonstorage(std::string* persistentjsonstorage);
  private:
  const std::string& _internal_persistentjsonstorage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_persistentjsonstorage(const std::string& value);
  std::string* _internal_mutable_persistentjsonstorage();
  public:

  // optional .UserSettings settings = 3;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::UserSettings& settings() const;
  PROTOBUF_NODISCARD ::UserSettings* release_settings();
  ::UserSettings* mutable_settings();
  void set_allocated_settings(::UserSettings* settings);
  private:
  const ::UserSettings& _internal_settings() const;
  ::UserSettings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::UserSettings* settings);
  ::UserSettings* unsafe_arena_release_settings();

  // optional .CachedProductState cachedProductState = 4;
  bool has_cachedproductstate() const;
  private:
  bool _internal_has_cachedproductstate() const;
  public:
  void clear_cachedproductstate();
  const ::CachedProductState& cachedproductstate() const;
  PROTOBUF_NODISCARD ::CachedProductState* release_cachedproductstate();
  ::CachedProductState* mutable_cachedproductstate();
  void set_allocated_cachedproductstate(::CachedProductState* cachedproductstate);
  private:
  const ::CachedProductState& _internal_cachedproductstate() const;
  ::CachedProductState* _internal_mutable_cachedproductstate();
  public:
  void unsafe_arena_set_allocated_cachedproductstate(
      ::CachedProductState* cachedproductstate);
  ::CachedProductState* unsafe_arena_release_cachedproductstate();

  // optional .ProductOperations productOperations = 5;
  bool has_productoperations() const;
  private:
  bool _internal_has_productoperations() const;
  public:
  void clear_productoperations();
  const ::ProductOperations& productoperations() const;
  PROTOBUF_NODISCARD ::ProductOperations* release_productoperations();
  ::ProductOperations* mutable_productoperations();
  void set_allocated_productoperations(::ProductOperations* productoperations);
  private:
  const ::ProductOperations& _internal_productoperations() const;
  ::ProductOperations* _internal_mutable_productoperations();
  public:
  void unsafe_arena_set_allocated_productoperations(
      ::ProductOperations* productoperations);
  ::ProductOperations* unsafe_arena_release_productoperations();

  // optional bool Hidden = 7;
  bool has_hidden() const;
  private:
  bool _internal_has_hidden() const;
  public:
  void clear_hidden();
  bool hidden() const;
  void set_hidden(bool value);
  private:
  bool _internal_hidden() const;
  void _internal_set_hidden(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ProductInstall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr productcode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr productfamily_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr persistentjsonstorage_;
    ::UserSettings* settings_;
    ::CachedProductState* cachedproductstate_;
    ::ProductOperations* productoperations_;
    bool hidden_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class ProductConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ProductConfig) */ {
 public:
  inline ProductConfig() : ProductConfig(nullptr) {}
  ~ProductConfig() override;
  explicit PROTOBUF_CONSTEXPR ProductConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProductConfig(const ProductConfig& from);
  ProductConfig(ProductConfig&& from) noexcept
    : ProductConfig() {
    *this = ::std::move(from);
  }

  inline ProductConfig& operator=(const ProductConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProductConfig& operator=(ProductConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ProductConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProductConfig* internal_default_instance() {
    return reinterpret_cast<const ProductConfig*>(
               &_ProductConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ProductConfig& a, ProductConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProductConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProductConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProductConfig& from);
  void MergeFrom(const ProductConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProductConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProductConfig";
  }
  protected:
  explicit ProductConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductCodeFieldNumber = 1,
    kMetadataHashFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // optional string productCode = 1;
  bool has_productcode() const;
  private:
  bool _internal_has_productcode() const;
  public:
  void clear_productcode();
  const std::string& productcode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_productcode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_productcode();
  PROTOBUF_NODISCARD std::string* release_productcode();
  void set_allocated_productcode(std::string* productcode);
  private:
  const std::string& _internal_productcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productcode(const std::string& value);
  std::string* _internal_mutable_productcode();
  public:

  // optional string metadataHash = 2;
  bool has_metadatahash() const;
  private:
  bool _internal_has_metadatahash() const;
  public:
  void clear_metadatahash();
  const std::string& metadatahash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadatahash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadatahash();
  PROTOBUF_NODISCARD std::string* release_metadatahash();
  void set_allocated_metadatahash(std::string* metadatahash);
  private:
  const std::string& _internal_metadatahash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadatahash(const std::string& value);
  std::string* _internal_mutable_metadatahash();
  public:

  // optional string timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const std::string& timestamp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timestamp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* timestamp);
  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(const std::string& value);
  std::string* _internal_mutable_timestamp();
  public:

  // @@protoc_insertion_point(class_scope:ProductConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr productcode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadatahash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class ActiveProcess final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ActiveProcess) */ {
 public:
  inline ActiveProcess() : ActiveProcess(nullptr) {}
  ~ActiveProcess() override;
  explicit PROTOBUF_CONSTEXPR ActiveProcess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveProcess(const ActiveProcess& from);
  ActiveProcess(ActiveProcess&& from) noexcept
    : ActiveProcess() {
    *this = ::std::move(from);
  }

  inline ActiveProcess& operator=(const ActiveProcess& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveProcess& operator=(ActiveProcess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ActiveProcess& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveProcess* internal_default_instance() {
    return reinterpret_cast<const ActiveProcess*>(
               &_ActiveProcess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ActiveProcess& a, ActiveProcess& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveProcess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveProcess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveProcess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveProcess>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ActiveProcess& from);
  void MergeFrom(const ActiveProcess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActiveProcess* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActiveProcess";
  }
  protected:
  explicit ActiveProcess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 3,
    kProcessNameFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  // repeated string uri = 3;
  int uri_size() const;
  private:
  int _internal_uri_size() const;
  public:
  void clear_uri();
  const std::string& uri(int index) const;
  std::string* mutable_uri(int index);
  void set_uri(int index, const std::string& value);
  void set_uri(int index, std::string&& value);
  void set_uri(int index, const char* value);
  void set_uri(int index, const char* value, size_t size);
  std::string* add_uri();
  void add_uri(const std::string& value);
  void add_uri(std::string&& value);
  void add_uri(const char* value);
  void add_uri(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& uri() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_uri();
  private:
  const std::string& _internal_uri(int index) const;
  std::string* _internal_add_uri();
  public:

  // optional string processName = 1;
  bool has_processname() const;
  private:
  bool _internal_has_processname() const;
  public:
  void clear_processname();
  const std::string& processname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processname();
  PROTOBUF_NODISCARD std::string* release_processname();
  void set_allocated_processname(std::string* processname);
  private:
  const std::string& _internal_processname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processname(const std::string& value);
  std::string* _internal_mutable_processname();
  public:

  // optional int32 pid = 2;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ActiveProcess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processname_;
    int32_t pid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class DownloadSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DownloadSettings) */ {
 public:
  inline DownloadSettings() : DownloadSettings(nullptr) {}
  ~DownloadSettings() override;
  explicit PROTOBUF_CONSTEXPR DownloadSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadSettings(const DownloadSettings& from);
  DownloadSettings(DownloadSettings&& from) noexcept
    : DownloadSettings() {
    *this = ::std::move(from);
  }

  inline DownloadSettings& operator=(const DownloadSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadSettings& operator=(DownloadSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DownloadSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadSettings* internal_default_instance() {
    return reinterpret_cast<const DownloadSettings*>(
               &_DownloadSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DownloadSettings& a, DownloadSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DownloadSettings& from);
  void MergeFrom(const DownloadSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DownloadSettings";
  }
  protected:
  explicit DownloadSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDownloadLimitFieldNumber = 1,
    kBackfillLimitFieldNumber = 2,
  };
  // optional int32 downloadLimit = 1 [default = -1];
  bool has_downloadlimit() const;
  private:
  bool _internal_has_downloadlimit() const;
  public:
  void clear_downloadlimit();
  int32_t downloadlimit() const;
  void set_downloadlimit(int32_t value);
  private:
  int32_t _internal_downloadlimit() const;
  void _internal_set_downloadlimit(int32_t value);
  public:

  // optional int32 backfillLimit = 2 [default = -1];
  bool has_backfilllimit() const;
  private:
  bool _internal_has_backfilllimit() const;
  public:
  void clear_backfilllimit();
  int32_t backfilllimit() const;
  void set_backfilllimit(int32_t value);
  private:
  int32_t _internal_backfilllimit() const;
  void _internal_set_backfilllimit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DownloadSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t downloadlimit_;
    int32_t backfilllimit_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// -------------------------------------------------------------------

class Database final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Database) */ {
 public:
  inline Database() : Database(nullptr) {}
  ~Database() override;
  explicit PROTOBUF_CONSTEXPR Database(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Database(const Database& from);
  Database(Database&& from) noexcept
    : Database() {
    *this = ::std::move(from);
  }

  inline Database& operator=(const Database& from) {
    CopyFrom(from);
    return *this;
  }
  inline Database& operator=(Database&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Database& default_instance() {
    return *internal_default_instance();
  }
  static inline const Database* internal_default_instance() {
    return reinterpret_cast<const Database*>(
               &_Database_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Database& a, Database& b) {
    a.Swap(&b);
  }
  inline void Swap(Database* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Database* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Database* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Database>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Database& from);
  void MergeFrom(const Database& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Database* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Database";
  }
  protected:
  explicit Database(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductInstallFieldNumber = 1,
    kActiveInstallsFieldNumber = 2,
    kActiveProcessesFieldNumber = 3,
    kProductConfigsFieldNumber = 4,
    kDownloadSettingsFieldNumber = 5,
  };
  // repeated .ProductInstall productInstall = 1;
  int productinstall_size() const;
  private:
  int _internal_productinstall_size() const;
  public:
  void clear_productinstall();
  ::ProductInstall* mutable_productinstall(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductInstall >*
      mutable_productinstall();
  private:
  const ::ProductInstall& _internal_productinstall(int index) const;
  ::ProductInstall* _internal_add_productinstall();
  public:
  const ::ProductInstall& productinstall(int index) const;
  ::ProductInstall* add_productinstall();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductInstall >&
      productinstall() const;

  // repeated .InstallHandshake activeInstalls = 2;
  int activeinstalls_size() const;
  private:
  int _internal_activeinstalls_size() const;
  public:
  void clear_activeinstalls();
  ::InstallHandshake* mutable_activeinstalls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstallHandshake >*
      mutable_activeinstalls();
  private:
  const ::InstallHandshake& _internal_activeinstalls(int index) const;
  ::InstallHandshake* _internal_add_activeinstalls();
  public:
  const ::InstallHandshake& activeinstalls(int index) const;
  ::InstallHandshake* add_activeinstalls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstallHandshake >&
      activeinstalls() const;

  // repeated .ActiveProcess activeProcesses = 3;
  int activeprocesses_size() const;
  private:
  int _internal_activeprocesses_size() const;
  public:
  void clear_activeprocesses();
  ::ActiveProcess* mutable_activeprocesses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ActiveProcess >*
      mutable_activeprocesses();
  private:
  const ::ActiveProcess& _internal_activeprocesses(int index) const;
  ::ActiveProcess* _internal_add_activeprocesses();
  public:
  const ::ActiveProcess& activeprocesses(int index) const;
  ::ActiveProcess* add_activeprocesses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ActiveProcess >&
      activeprocesses() const;

  // repeated .ProductConfig productConfigs = 4;
  int productconfigs_size() const;
  private:
  int _internal_productconfigs_size() const;
  public:
  void clear_productconfigs();
  ::ProductConfig* mutable_productconfigs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductConfig >*
      mutable_productconfigs();
  private:
  const ::ProductConfig& _internal_productconfigs(int index) const;
  ::ProductConfig* _internal_add_productconfigs();
  public:
  const ::ProductConfig& productconfigs(int index) const;
  ::ProductConfig* add_productconfigs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductConfig >&
      productconfigs() const;

  // optional .DownloadSettings downloadSettings = 5;
  bool has_downloadsettings() const;
  private:
  bool _internal_has_downloadsettings() const;
  public:
  void clear_downloadsettings();
  const ::DownloadSettings& downloadsettings() const;
  PROTOBUF_NODISCARD ::DownloadSettings* release_downloadsettings();
  ::DownloadSettings* mutable_downloadsettings();
  void set_allocated_downloadsettings(::DownloadSettings* downloadsettings);
  private:
  const ::DownloadSettings& _internal_downloadsettings() const;
  ::DownloadSettings* _internal_mutable_downloadsettings();
  public:
  void unsafe_arena_set_allocated_downloadsettings(
      ::DownloadSettings* downloadsettings);
  ::DownloadSettings* unsafe_arena_release_downloadsettings();

  // @@protoc_insertion_point(class_scope:Database)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductInstall > productinstall_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstallHandshake > activeinstalls_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ActiveProcess > activeprocesses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductConfig > productconfigs_;
    ::DownloadSettings* downloadsettings_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ProtoDatabase_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LanguageSetting

// optional string language = 1;
inline bool LanguageSetting::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LanguageSetting::has_language() const {
  return _internal_has_language();
}
inline void LanguageSetting::clear_language() {
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LanguageSetting::language() const {
  // @@protoc_insertion_point(field_get:LanguageSetting.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LanguageSetting::set_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LanguageSetting.language)
}
inline std::string* LanguageSetting::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:LanguageSetting.language)
  return _s;
}
inline const std::string& LanguageSetting::_internal_language() const {
  return _impl_.language_.Get();
}
inline void LanguageSetting::_internal_set_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* LanguageSetting::_internal_mutable_language() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* LanguageSetting::release_language() {
  // @@protoc_insertion_point(field_release:LanguageSetting.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LanguageSetting::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LanguageSetting.language)
}

// optional .LanguageOption option = 2;
inline bool LanguageSetting::_internal_has_option() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LanguageSetting::has_option() const {
  return _internal_has_option();
}
inline void LanguageSetting::clear_option() {
  _impl_.option_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::LanguageOption LanguageSetting::_internal_option() const {
  return static_cast< ::LanguageOption >(_impl_.option_);
}
inline ::LanguageOption LanguageSetting::option() const {
  // @@protoc_insertion_point(field_get:LanguageSetting.option)
  return _internal_option();
}
inline void LanguageSetting::_internal_set_option(::LanguageOption value) {
  assert(::LanguageOption_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.option_ = value;
}
inline void LanguageSetting::set_option(::LanguageOption value) {
  _internal_set_option(value);
  // @@protoc_insertion_point(field_set:LanguageSetting.option)
}

// -------------------------------------------------------------------

// UserSettings

// optional string installPath = 1;
inline bool UserSettings::_internal_has_installpath() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserSettings::has_installpath() const {
  return _internal_has_installpath();
}
inline void UserSettings::clear_installpath() {
  _impl_.installpath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserSettings::installpath() const {
  // @@protoc_insertion_point(field_get:UserSettings.installPath)
  return _internal_installpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSettings::set_installpath(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.installpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserSettings.installPath)
}
inline std::string* UserSettings::mutable_installpath() {
  std::string* _s = _internal_mutable_installpath();
  // @@protoc_insertion_point(field_mutable:UserSettings.installPath)
  return _s;
}
inline const std::string& UserSettings::_internal_installpath() const {
  return _impl_.installpath_.Get();
}
inline void UserSettings::_internal_set_installpath(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.installpath_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSettings::_internal_mutable_installpath() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.installpath_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSettings::release_installpath() {
  // @@protoc_insertion_point(field_release:UserSettings.installPath)
  if (!_internal_has_installpath()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.installpath_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.installpath_.IsDefault()) {
    _impl_.installpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserSettings::set_allocated_installpath(std::string* installpath) {
  if (installpath != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.installpath_.SetAllocated(installpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.installpath_.IsDefault()) {
    _impl_.installpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserSettings.installPath)
}

// optional string playRegion = 2;
inline bool UserSettings::_internal_has_playregion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserSettings::has_playregion() const {
  return _internal_has_playregion();
}
inline void UserSettings::clear_playregion() {
  _impl_.playregion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserSettings::playregion() const {
  // @@protoc_insertion_point(field_get:UserSettings.playRegion)
  return _internal_playregion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSettings::set_playregion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.playregion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserSettings.playRegion)
}
inline std::string* UserSettings::mutable_playregion() {
  std::string* _s = _internal_mutable_playregion();
  // @@protoc_insertion_point(field_mutable:UserSettings.playRegion)
  return _s;
}
inline const std::string& UserSettings::_internal_playregion() const {
  return _impl_.playregion_.Get();
}
inline void UserSettings::_internal_set_playregion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.playregion_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSettings::_internal_mutable_playregion() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.playregion_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSettings::release_playregion() {
  // @@protoc_insertion_point(field_release:UserSettings.playRegion)
  if (!_internal_has_playregion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.playregion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playregion_.IsDefault()) {
    _impl_.playregion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserSettings::set_allocated_playregion(std::string* playregion) {
  if (playregion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.playregion_.SetAllocated(playregion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playregion_.IsDefault()) {
    _impl_.playregion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserSettings.playRegion)
}

// optional .ShortcutOption desktopShortcut = 3;
inline bool UserSettings::_internal_has_desktopshortcut() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool UserSettings::has_desktopshortcut() const {
  return _internal_has_desktopshortcut();
}
inline void UserSettings::clear_desktopshortcut() {
  _impl_.desktopshortcut_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::ShortcutOption UserSettings::_internal_desktopshortcut() const {
  return static_cast< ::ShortcutOption >(_impl_.desktopshortcut_);
}
inline ::ShortcutOption UserSettings::desktopshortcut() const {
  // @@protoc_insertion_point(field_get:UserSettings.desktopShortcut)
  return _internal_desktopshortcut();
}
inline void UserSettings::_internal_set_desktopshortcut(::ShortcutOption value) {
  assert(::ShortcutOption_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.desktopshortcut_ = value;
}
inline void UserSettings::set_desktopshortcut(::ShortcutOption value) {
  _internal_set_desktopshortcut(value);
  // @@protoc_insertion_point(field_set:UserSettings.desktopShortcut)
}

// optional .ShortcutOption startmenuShortcut = 4;
inline bool UserSettings::_internal_has_startmenushortcut() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool UserSettings::has_startmenushortcut() const {
  return _internal_has_startmenushortcut();
}
inline void UserSettings::clear_startmenushortcut() {
  _impl_.startmenushortcut_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::ShortcutOption UserSettings::_internal_startmenushortcut() const {
  return static_cast< ::ShortcutOption >(_impl_.startmenushortcut_);
}
inline ::ShortcutOption UserSettings::startmenushortcut() const {
  // @@protoc_insertion_point(field_get:UserSettings.startmenuShortcut)
  return _internal_startmenushortcut();
}
inline void UserSettings::_internal_set_startmenushortcut(::ShortcutOption value) {
  assert(::ShortcutOption_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.startmenushortcut_ = value;
}
inline void UserSettings::set_startmenushortcut(::ShortcutOption value) {
  _internal_set_startmenushortcut(value);
  // @@protoc_insertion_point(field_set:UserSettings.startmenuShortcut)
}

// optional .LanguageSettingType languageSettings = 5;
inline bool UserSettings::_internal_has_languagesettings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool UserSettings::has_languagesettings() const {
  return _internal_has_languagesettings();
}
inline void UserSettings::clear_languagesettings() {
  _impl_.languagesettings_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::LanguageSettingType UserSettings::_internal_languagesettings() const {
  return static_cast< ::LanguageSettingType >(_impl_.languagesettings_);
}
inline ::LanguageSettingType UserSettings::languagesettings() const {
  // @@protoc_insertion_point(field_get:UserSettings.languageSettings)
  return _internal_languagesettings();
}
inline void UserSettings::_internal_set_languagesettings(::LanguageSettingType value) {
  assert(::LanguageSettingType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.languagesettings_ = value;
}
inline void UserSettings::set_languagesettings(::LanguageSettingType value) {
  _internal_set_languagesettings(value);
  // @@protoc_insertion_point(field_set:UserSettings.languageSettings)
}

// optional string selectedTextLanguage = 6;
inline bool UserSettings::_internal_has_selectedtextlanguage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserSettings::has_selectedtextlanguage() const {
  return _internal_has_selectedtextlanguage();
}
inline void UserSettings::clear_selectedtextlanguage() {
  _impl_.selectedtextlanguage_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserSettings::selectedtextlanguage() const {
  // @@protoc_insertion_point(field_get:UserSettings.selectedTextLanguage)
  return _internal_selectedtextlanguage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSettings::set_selectedtextlanguage(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.selectedtextlanguage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserSettings.selectedTextLanguage)
}
inline std::string* UserSettings::mutable_selectedtextlanguage() {
  std::string* _s = _internal_mutable_selectedtextlanguage();
  // @@protoc_insertion_point(field_mutable:UserSettings.selectedTextLanguage)
  return _s;
}
inline const std::string& UserSettings::_internal_selectedtextlanguage() const {
  return _impl_.selectedtextlanguage_.Get();
}
inline void UserSettings::_internal_set_selectedtextlanguage(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.selectedtextlanguage_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSettings::_internal_mutable_selectedtextlanguage() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.selectedtextlanguage_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSettings::release_selectedtextlanguage() {
  // @@protoc_insertion_point(field_release:UserSettings.selectedTextLanguage)
  if (!_internal_has_selectedtextlanguage()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.selectedtextlanguage_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selectedtextlanguage_.IsDefault()) {
    _impl_.selectedtextlanguage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserSettings::set_allocated_selectedtextlanguage(std::string* selectedtextlanguage) {
  if (selectedtextlanguage != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.selectedtextlanguage_.SetAllocated(selectedtextlanguage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selectedtextlanguage_.IsDefault()) {
    _impl_.selectedtextlanguage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserSettings.selectedTextLanguage)
}

// optional string selectedSpeechLanguage = 7;
inline bool UserSettings::_internal_has_selectedspeechlanguage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserSettings::has_selectedspeechlanguage() const {
  return _internal_has_selectedspeechlanguage();
}
inline void UserSettings::clear_selectedspeechlanguage() {
  _impl_.selectedspeechlanguage_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserSettings::selectedspeechlanguage() const {
  // @@protoc_insertion_point(field_get:UserSettings.selectedSpeechLanguage)
  return _internal_selectedspeechlanguage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSettings::set_selectedspeechlanguage(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.selectedspeechlanguage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserSettings.selectedSpeechLanguage)
}
inline std::string* UserSettings::mutable_selectedspeechlanguage() {
  std::string* _s = _internal_mutable_selectedspeechlanguage();
  // @@protoc_insertion_point(field_mutable:UserSettings.selectedSpeechLanguage)
  return _s;
}
inline const std::string& UserSettings::_internal_selectedspeechlanguage() const {
  return _impl_.selectedspeechlanguage_.Get();
}
inline void UserSettings::_internal_set_selectedspeechlanguage(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.selectedspeechlanguage_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSettings::_internal_mutable_selectedspeechlanguage() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.selectedspeechlanguage_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSettings::release_selectedspeechlanguage() {
  // @@protoc_insertion_point(field_release:UserSettings.selectedSpeechLanguage)
  if (!_internal_has_selectedspeechlanguage()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.selectedspeechlanguage_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selectedspeechlanguage_.IsDefault()) {
    _impl_.selectedspeechlanguage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserSettings::set_allocated_selectedspeechlanguage(std::string* selectedspeechlanguage) {
  if (selectedspeechlanguage != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.selectedspeechlanguage_.SetAllocated(selectedspeechlanguage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selectedspeechlanguage_.IsDefault()) {
    _impl_.selectedspeechlanguage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserSettings.selectedSpeechLanguage)
}

// repeated .LanguageSetting languages = 8;
inline int UserSettings::_internal_languages_size() const {
  return _impl_.languages_.size();
}
inline int UserSettings::languages_size() const {
  return _internal_languages_size();
}
inline void UserSettings::clear_languages() {
  _impl_.languages_.Clear();
}
inline ::LanguageSetting* UserSettings::mutable_languages(int index) {
  // @@protoc_insertion_point(field_mutable:UserSettings.languages)
  return _impl_.languages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LanguageSetting >*
UserSettings::mutable_languages() {
  // @@protoc_insertion_point(field_mutable_list:UserSettings.languages)
  return &_impl_.languages_;
}
inline const ::LanguageSetting& UserSettings::_internal_languages(int index) const {
  return _impl_.languages_.Get(index);
}
inline const ::LanguageSetting& UserSettings::languages(int index) const {
  // @@protoc_insertion_point(field_get:UserSettings.languages)
  return _internal_languages(index);
}
inline ::LanguageSetting* UserSettings::_internal_add_languages() {
  return _impl_.languages_.Add();
}
inline ::LanguageSetting* UserSettings::add_languages() {
  ::LanguageSetting* _add = _internal_add_languages();
  // @@protoc_insertion_point(field_add:UserSettings.languages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LanguageSetting >&
UserSettings::languages() const {
  // @@protoc_insertion_point(field_list:UserSettings.languages)
  return _impl_.languages_;
}

// optional string gfx_override_tags = 9;
inline bool UserSettings::_internal_has_gfx_override_tags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserSettings::has_gfx_override_tags() const {
  return _internal_has_gfx_override_tags();
}
inline void UserSettings::clear_gfx_override_tags() {
  _impl_.gfx_override_tags_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UserSettings::gfx_override_tags() const {
  // @@protoc_insertion_point(field_get:UserSettings.gfx_override_tags)
  return _internal_gfx_override_tags();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSettings::set_gfx_override_tags(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.gfx_override_tags_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserSettings.gfx_override_tags)
}
inline std::string* UserSettings::mutable_gfx_override_tags() {
  std::string* _s = _internal_mutable_gfx_override_tags();
  // @@protoc_insertion_point(field_mutable:UserSettings.gfx_override_tags)
  return _s;
}
inline const std::string& UserSettings::_internal_gfx_override_tags() const {
  return _impl_.gfx_override_tags_.Get();
}
inline void UserSettings::_internal_set_gfx_override_tags(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.gfx_override_tags_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSettings::_internal_mutable_gfx_override_tags() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.gfx_override_tags_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSettings::release_gfx_override_tags() {
  // @@protoc_insertion_point(field_release:UserSettings.gfx_override_tags)
  if (!_internal_has_gfx_override_tags()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.gfx_override_tags_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gfx_override_tags_.IsDefault()) {
    _impl_.gfx_override_tags_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserSettings::set_allocated_gfx_override_tags(std::string* gfx_override_tags) {
  if (gfx_override_tags != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.gfx_override_tags_.SetAllocated(gfx_override_tags, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gfx_override_tags_.IsDefault()) {
    _impl_.gfx_override_tags_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserSettings.gfx_override_tags)
}

// optional string versionbranch = 10;
inline bool UserSettings::_internal_has_versionbranch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserSettings::has_versionbranch() const {
  return _internal_has_versionbranch();
}
inline void UserSettings::clear_versionbranch() {
  _impl_.versionbranch_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& UserSettings::versionbranch() const {
  // @@protoc_insertion_point(field_get:UserSettings.versionbranch)
  return _internal_versionbranch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSettings::set_versionbranch(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.versionbranch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserSettings.versionbranch)
}
inline std::string* UserSettings::mutable_versionbranch() {
  std::string* _s = _internal_mutable_versionbranch();
  // @@protoc_insertion_point(field_mutable:UserSettings.versionbranch)
  return _s;
}
inline const std::string& UserSettings::_internal_versionbranch() const {
  return _impl_.versionbranch_.Get();
}
inline void UserSettings::_internal_set_versionbranch(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.versionbranch_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSettings::_internal_mutable_versionbranch() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.versionbranch_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSettings::release_versionbranch() {
  // @@protoc_insertion_point(field_release:UserSettings.versionbranch)
  if (!_internal_has_versionbranch()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.versionbranch_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.versionbranch_.IsDefault()) {
    _impl_.versionbranch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserSettings::set_allocated_versionbranch(std::string* versionbranch) {
  if (versionbranch != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.versionbranch_.SetAllocated(versionbranch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.versionbranch_.IsDefault()) {
    _impl_.versionbranch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserSettings.versionbranch)
}

// optional string accountCountry = 11;
inline bool UserSettings::_internal_has_accountcountry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UserSettings::has_accountcountry() const {
  return _internal_has_accountcountry();
}
inline void UserSettings::clear_accountcountry() {
  _impl_.accountcountry_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& UserSettings::accountcountry() const {
  // @@protoc_insertion_point(field_get:UserSettings.accountCountry)
  return _internal_accountcountry();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSettings::set_accountcountry(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.accountcountry_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserSettings.accountCountry)
}
inline std::string* UserSettings::mutable_accountcountry() {
  std::string* _s = _internal_mutable_accountcountry();
  // @@protoc_insertion_point(field_mutable:UserSettings.accountCountry)
  return _s;
}
inline const std::string& UserSettings::_internal_accountcountry() const {
  return _impl_.accountcountry_.Get();
}
inline void UserSettings::_internal_set_accountcountry(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.accountcountry_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSettings::_internal_mutable_accountcountry() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.accountcountry_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSettings::release_accountcountry() {
  // @@protoc_insertion_point(field_release:UserSettings.accountCountry)
  if (!_internal_has_accountcountry()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.accountcountry_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accountcountry_.IsDefault()) {
    _impl_.accountcountry_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserSettings::set_allocated_accountcountry(std::string* accountcountry) {
  if (accountcountry != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.accountcountry_.SetAllocated(accountcountry, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accountcountry_.IsDefault()) {
    _impl_.accountcountry_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserSettings.accountCountry)
}

// optional string geoIpCountry = 12;
inline bool UserSettings::_internal_has_geoipcountry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UserSettings::has_geoipcountry() const {
  return _internal_has_geoipcountry();
}
inline void UserSettings::clear_geoipcountry() {
  _impl_.geoipcountry_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& UserSettings::geoipcountry() const {
  // @@protoc_insertion_point(field_get:UserSettings.geoIpCountry)
  return _internal_geoipcountry();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSettings::set_geoipcountry(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.geoipcountry_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserSettings.geoIpCountry)
}
inline std::string* UserSettings::mutable_geoipcountry() {
  std::string* _s = _internal_mutable_geoipcountry();
  // @@protoc_insertion_point(field_mutable:UserSettings.geoIpCountry)
  return _s;
}
inline const std::string& UserSettings::_internal_geoipcountry() const {
  return _impl_.geoipcountry_.Get();
}
inline void UserSettings::_internal_set_geoipcountry(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.geoipcountry_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSettings::_internal_mutable_geoipcountry() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.geoipcountry_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSettings::release_geoipcountry() {
  // @@protoc_insertion_point(field_release:UserSettings.geoIpCountry)
  if (!_internal_has_geoipcountry()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.geoipcountry_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.geoipcountry_.IsDefault()) {
    _impl_.geoipcountry_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserSettings::set_allocated_geoipcountry(std::string* geoipcountry) {
  if (geoipcountry != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.geoipcountry_.SetAllocated(geoipcountry, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.geoipcountry_.IsDefault()) {
    _impl_.geoipcountry_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserSettings.geoIpCountry)
}

// optional string gameSubfolder = 13;
inline bool UserSettings::_internal_has_gamesubfolder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool UserSettings::has_gamesubfolder() const {
  return _internal_has_gamesubfolder();
}
inline void UserSettings::clear_gamesubfolder() {
  _impl_.gamesubfolder_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& UserSettings::gamesubfolder() const {
  // @@protoc_insertion_point(field_get:UserSettings.gameSubfolder)
  return _internal_gamesubfolder();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSettings::set_gamesubfolder(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.gamesubfolder_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserSettings.gameSubfolder)
}
inline std::string* UserSettings::mutable_gamesubfolder() {
  std::string* _s = _internal_mutable_gamesubfolder();
  // @@protoc_insertion_point(field_mutable:UserSettings.gameSubfolder)
  return _s;
}
inline const std::string& UserSettings::_internal_gamesubfolder() const {
  return _impl_.gamesubfolder_.Get();
}
inline void UserSettings::_internal_set_gamesubfolder(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.gamesubfolder_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSettings::_internal_mutable_gamesubfolder() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.gamesubfolder_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSettings::release_gamesubfolder() {
  // @@protoc_insertion_point(field_release:UserSettings.gameSubfolder)
  if (!_internal_has_gamesubfolder()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.gamesubfolder_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gamesubfolder_.IsDefault()) {
    _impl_.gamesubfolder_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserSettings::set_allocated_gamesubfolder(std::string* gamesubfolder) {
  if (gamesubfolder != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.gamesubfolder_.SetAllocated(gamesubfolder, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gamesubfolder_.IsDefault()) {
    _impl_.gamesubfolder_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserSettings.gameSubfolder)
}

// -------------------------------------------------------------------

// InstallHandshake

// optional string product = 1;
inline bool InstallHandshake::_internal_has_product() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstallHandshake::has_product() const {
  return _internal_has_product();
}
inline void InstallHandshake::clear_product() {
  _impl_.product_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstallHandshake::product() const {
  // @@protoc_insertion_point(field_get:InstallHandshake.product)
  return _internal_product();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstallHandshake::set_product(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.product_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InstallHandshake.product)
}
inline std::string* InstallHandshake::mutable_product() {
  std::string* _s = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:InstallHandshake.product)
  return _s;
}
inline const std::string& InstallHandshake::_internal_product() const {
  return _impl_.product_.Get();
}
inline void InstallHandshake::_internal_set_product(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.product_.Set(value, GetArenaForAllocation());
}
inline std::string* InstallHandshake::_internal_mutable_product() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.product_.Mutable(GetArenaForAllocation());
}
inline std::string* InstallHandshake::release_product() {
  // @@protoc_insertion_point(field_release:InstallHandshake.product)
  if (!_internal_has_product()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.product_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.product_.IsDefault()) {
    _impl_.product_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstallHandshake::set_allocated_product(std::string* product) {
  if (product != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.product_.SetAllocated(product, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.product_.IsDefault()) {
    _impl_.product_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InstallHandshake.product)
}

// optional string uid = 2;
inline bool InstallHandshake::_internal_has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InstallHandshake::has_uid() const {
  return _internal_has_uid();
}
inline void InstallHandshake::clear_uid() {
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InstallHandshake::uid() const {
  // @@protoc_insertion_point(field_get:InstallHandshake.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstallHandshake::set_uid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InstallHandshake.uid)
}
inline std::string* InstallHandshake::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:InstallHandshake.uid)
  return _s;
}
inline const std::string& InstallHandshake::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void InstallHandshake::_internal_set_uid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* InstallHandshake::_internal_mutable_uid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* InstallHandshake::release_uid() {
  // @@protoc_insertion_point(field_release:InstallHandshake.uid)
  if (!_internal_has_uid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.uid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstallHandshake::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InstallHandshake.uid)
}

// optional .UserSettings settings = 3;
inline bool InstallHandshake::_internal_has_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.settings_ != nullptr);
  return value;
}
inline bool InstallHandshake::has_settings() const {
  return _internal_has_settings();
}
inline void InstallHandshake::clear_settings() {
  if (_impl_.settings_ != nullptr) _impl_.settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::UserSettings& InstallHandshake::_internal_settings() const {
  const ::UserSettings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserSettings&>(
      ::_UserSettings_default_instance_);
}
inline const ::UserSettings& InstallHandshake::settings() const {
  // @@protoc_insertion_point(field_get:InstallHandshake.settings)
  return _internal_settings();
}
inline void InstallHandshake::unsafe_arena_set_allocated_settings(
    ::UserSettings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = settings;
  if (settings) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InstallHandshake.settings)
}
inline ::UserSettings* InstallHandshake::release_settings() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::UserSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserSettings* InstallHandshake::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:InstallHandshake.settings)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::UserSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::UserSettings* InstallHandshake::_internal_mutable_settings() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserSettings>(GetArenaForAllocation());
    _impl_.settings_ = p;
  }
  return _impl_.settings_;
}
inline ::UserSettings* InstallHandshake::mutable_settings() {
  ::UserSettings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:InstallHandshake.settings)
  return _msg;
}
inline void InstallHandshake::set_allocated_settings(::UserSettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:InstallHandshake.settings)
}

// -------------------------------------------------------------------

// BuildConfig

// optional string region = 1;
inline bool BuildConfig::_internal_has_region() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BuildConfig::has_region() const {
  return _internal_has_region();
}
inline void BuildConfig::clear_region() {
  _impl_.region_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BuildConfig::region() const {
  // @@protoc_insertion_point(field_get:BuildConfig.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuildConfig::set_region(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BuildConfig.region)
}
inline std::string* BuildConfig::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:BuildConfig.region)
  return _s;
}
inline const std::string& BuildConfig::_internal_region() const {
  return _impl_.region_.Get();
}
inline void BuildConfig::_internal_set_region(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* BuildConfig::_internal_mutable_region() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* BuildConfig::release_region() {
  // @@protoc_insertion_point(field_release:BuildConfig.region)
  if (!_internal_has_region()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.region_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BuildConfig::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BuildConfig.region)
}

// optional string buildConfig = 2;
inline bool BuildConfig::_internal_has_buildconfig() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BuildConfig::has_buildconfig() const {
  return _internal_has_buildconfig();
}
inline void BuildConfig::clear_buildconfig() {
  _impl_.buildconfig_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BuildConfig::buildconfig() const {
  // @@protoc_insertion_point(field_get:BuildConfig.buildConfig)
  return _internal_buildconfig();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuildConfig::set_buildconfig(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.buildconfig_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BuildConfig.buildConfig)
}
inline std::string* BuildConfig::mutable_buildconfig() {
  std::string* _s = _internal_mutable_buildconfig();
  // @@protoc_insertion_point(field_mutable:BuildConfig.buildConfig)
  return _s;
}
inline const std::string& BuildConfig::_internal_buildconfig() const {
  return _impl_.buildconfig_.Get();
}
inline void BuildConfig::_internal_set_buildconfig(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.buildconfig_.Set(value, GetArenaForAllocation());
}
inline std::string* BuildConfig::_internal_mutable_buildconfig() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.buildconfig_.Mutable(GetArenaForAllocation());
}
inline std::string* BuildConfig::release_buildconfig() {
  // @@protoc_insertion_point(field_release:BuildConfig.buildConfig)
  if (!_internal_has_buildconfig()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.buildconfig_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buildconfig_.IsDefault()) {
    _impl_.buildconfig_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BuildConfig::set_allocated_buildconfig(std::string* buildconfig) {
  if (buildconfig != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.buildconfig_.SetAllocated(buildconfig, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buildconfig_.IsDefault()) {
    _impl_.buildconfig_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BuildConfig.buildConfig)
}

// -------------------------------------------------------------------

// BaseProductState

// optional bool installed = 1;
inline bool BaseProductState::_internal_has_installed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BaseProductState::has_installed() const {
  return _internal_has_installed();
}
inline void BaseProductState::clear_installed() {
  _impl_.installed_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool BaseProductState::_internal_installed() const {
  return _impl_.installed_;
}
inline bool BaseProductState::installed() const {
  // @@protoc_insertion_point(field_get:BaseProductState.installed)
  return _internal_installed();
}
inline void BaseProductState::_internal_set_installed(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.installed_ = value;
}
inline void BaseProductState::set_installed(bool value) {
  _internal_set_installed(value);
  // @@protoc_insertion_point(field_set:BaseProductState.installed)
}

// optional bool playable = 2;
inline bool BaseProductState::_internal_has_playable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BaseProductState::has_playable() const {
  return _internal_has_playable();
}
inline void BaseProductState::clear_playable() {
  _impl_.playable_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool BaseProductState::_internal_playable() const {
  return _impl_.playable_;
}
inline bool BaseProductState::playable() const {
  // @@protoc_insertion_point(field_get:BaseProductState.playable)
  return _internal_playable();
}
inline void BaseProductState::_internal_set_playable(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.playable_ = value;
}
inline void BaseProductState::set_playable(bool value) {
  _internal_set_playable(value);
  // @@protoc_insertion_point(field_set:BaseProductState.playable)
}

// optional bool updateComplete = 3;
inline bool BaseProductState::_internal_has_updatecomplete() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BaseProductState::has_updatecomplete() const {
  return _internal_has_updatecomplete();
}
inline void BaseProductState::clear_updatecomplete() {
  _impl_.updatecomplete_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool BaseProductState::_internal_updatecomplete() const {
  return _impl_.updatecomplete_;
}
inline bool BaseProductState::updatecomplete() const {
  // @@protoc_insertion_point(field_get:BaseProductState.updateComplete)
  return _internal_updatecomplete();
}
inline void BaseProductState::_internal_set_updatecomplete(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.updatecomplete_ = value;
}
inline void BaseProductState::set_updatecomplete(bool value) {
  _internal_set_updatecomplete(value);
  // @@protoc_insertion_point(field_set:BaseProductState.updateComplete)
}

// optional bool backgroundDownloadAvailable = 4;
inline bool BaseProductState::_internal_has_backgrounddownloadavailable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BaseProductState::has_backgrounddownloadavailable() const {
  return _internal_has_backgrounddownloadavailable();
}
inline void BaseProductState::clear_backgrounddownloadavailable() {
  _impl_.backgrounddownloadavailable_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool BaseProductState::_internal_backgrounddownloadavailable() const {
  return _impl_.backgrounddownloadavailable_;
}
inline bool BaseProductState::backgrounddownloadavailable() const {
  // @@protoc_insertion_point(field_get:BaseProductState.backgroundDownloadAvailable)
  return _internal_backgrounddownloadavailable();
}
inline void BaseProductState::_internal_set_backgrounddownloadavailable(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.backgrounddownloadavailable_ = value;
}
inline void BaseProductState::set_backgrounddownloadavailable(bool value) {
  _internal_set_backgrounddownloadavailable(value);
  // @@protoc_insertion_point(field_set:BaseProductState.backgroundDownloadAvailable)
}

// optional bool backgroundDownloadComplete = 5;
inline bool BaseProductState::_internal_has_backgrounddownloadcomplete() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BaseProductState::has_backgrounddownloadcomplete() const {
  return _internal_has_backgrounddownloadcomplete();
}
inline void BaseProductState::clear_backgrounddownloadcomplete() {
  _impl_.backgrounddownloadcomplete_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool BaseProductState::_internal_backgrounddownloadcomplete() const {
  return _impl_.backgrounddownloadcomplete_;
}
inline bool BaseProductState::backgrounddownloadcomplete() const {
  // @@protoc_insertion_point(field_get:BaseProductState.backgroundDownloadComplete)
  return _internal_backgrounddownloadcomplete();
}
inline void BaseProductState::_internal_set_backgrounddownloadcomplete(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.backgrounddownloadcomplete_ = value;
}
inline void BaseProductState::set_backgrounddownloadcomplete(bool value) {
  _internal_set_backgrounddownloadcomplete(value);
  // @@protoc_insertion_point(field_set:BaseProductState.backgroundDownloadComplete)
}

// optional string currentVersion = 6;
inline bool BaseProductState::_internal_has_currentversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BaseProductState::has_currentversion() const {
  return _internal_has_currentversion();
}
inline void BaseProductState::clear_currentversion() {
  _impl_.currentversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BaseProductState::currentversion() const {
  // @@protoc_insertion_point(field_get:BaseProductState.currentVersion)
  return _internal_currentversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseProductState::set_currentversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.currentversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BaseProductState.currentVersion)
}
inline std::string* BaseProductState::mutable_currentversion() {
  std::string* _s = _internal_mutable_currentversion();
  // @@protoc_insertion_point(field_mutable:BaseProductState.currentVersion)
  return _s;
}
inline const std::string& BaseProductState::_internal_currentversion() const {
  return _impl_.currentversion_.Get();
}
inline void BaseProductState::_internal_set_currentversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.currentversion_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseProductState::_internal_mutable_currentversion() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.currentversion_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseProductState::release_currentversion() {
  // @@protoc_insertion_point(field_release:BaseProductState.currentVersion)
  if (!_internal_has_currentversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.currentversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currentversion_.IsDefault()) {
    _impl_.currentversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BaseProductState::set_allocated_currentversion(std::string* currentversion) {
  if (currentversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.currentversion_.SetAllocated(currentversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currentversion_.IsDefault()) {
    _impl_.currentversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BaseProductState.currentVersion)
}

// optional string currentVersionStr = 7;
inline bool BaseProductState::_internal_has_currentversionstr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BaseProductState::has_currentversionstr() const {
  return _internal_has_currentversionstr();
}
inline void BaseProductState::clear_currentversionstr() {
  _impl_.currentversionstr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BaseProductState::currentversionstr() const {
  // @@protoc_insertion_point(field_get:BaseProductState.currentVersionStr)
  return _internal_currentversionstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseProductState::set_currentversionstr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.currentversionstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BaseProductState.currentVersionStr)
}
inline std::string* BaseProductState::mutable_currentversionstr() {
  std::string* _s = _internal_mutable_currentversionstr();
  // @@protoc_insertion_point(field_mutable:BaseProductState.currentVersionStr)
  return _s;
}
inline const std::string& BaseProductState::_internal_currentversionstr() const {
  return _impl_.currentversionstr_.Get();
}
inline void BaseProductState::_internal_set_currentversionstr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.currentversionstr_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseProductState::_internal_mutable_currentversionstr() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.currentversionstr_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseProductState::release_currentversionstr() {
  // @@protoc_insertion_point(field_release:BaseProductState.currentVersionStr)
  if (!_internal_has_currentversionstr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.currentversionstr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currentversionstr_.IsDefault()) {
    _impl_.currentversionstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BaseProductState::set_allocated_currentversionstr(std::string* currentversionstr) {
  if (currentversionstr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.currentversionstr_.SetAllocated(currentversionstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currentversionstr_.IsDefault()) {
    _impl_.currentversionstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BaseProductState.currentVersionStr)
}

// repeated .BuildConfig installedBuildConfig = 8;
inline int BaseProductState::_internal_installedbuildconfig_size() const {
  return _impl_.installedbuildconfig_.size();
}
inline int BaseProductState::installedbuildconfig_size() const {
  return _internal_installedbuildconfig_size();
}
inline void BaseProductState::clear_installedbuildconfig() {
  _impl_.installedbuildconfig_.Clear();
}
inline ::BuildConfig* BaseProductState::mutable_installedbuildconfig(int index) {
  // @@protoc_insertion_point(field_mutable:BaseProductState.installedBuildConfig)
  return _impl_.installedbuildconfig_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >*
BaseProductState::mutable_installedbuildconfig() {
  // @@protoc_insertion_point(field_mutable_list:BaseProductState.installedBuildConfig)
  return &_impl_.installedbuildconfig_;
}
inline const ::BuildConfig& BaseProductState::_internal_installedbuildconfig(int index) const {
  return _impl_.installedbuildconfig_.Get(index);
}
inline const ::BuildConfig& BaseProductState::installedbuildconfig(int index) const {
  // @@protoc_insertion_point(field_get:BaseProductState.installedBuildConfig)
  return _internal_installedbuildconfig(index);
}
inline ::BuildConfig* BaseProductState::_internal_add_installedbuildconfig() {
  return _impl_.installedbuildconfig_.Add();
}
inline ::BuildConfig* BaseProductState::add_installedbuildconfig() {
  ::BuildConfig* _add = _internal_add_installedbuildconfig();
  // @@protoc_insertion_point(field_add:BaseProductState.installedBuildConfig)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >&
BaseProductState::installedbuildconfig() const {
  // @@protoc_insertion_point(field_list:BaseProductState.installedBuildConfig)
  return _impl_.installedbuildconfig_;
}

// repeated .BuildConfig backgroundDownloadBuildConfig = 9;
inline int BaseProductState::_internal_backgrounddownloadbuildconfig_size() const {
  return _impl_.backgrounddownloadbuildconfig_.size();
}
inline int BaseProductState::backgrounddownloadbuildconfig_size() const {
  return _internal_backgrounddownloadbuildconfig_size();
}
inline void BaseProductState::clear_backgrounddownloadbuildconfig() {
  _impl_.backgrounddownloadbuildconfig_.Clear();
}
inline ::BuildConfig* BaseProductState::mutable_backgrounddownloadbuildconfig(int index) {
  // @@protoc_insertion_point(field_mutable:BaseProductState.backgroundDownloadBuildConfig)
  return _impl_.backgrounddownloadbuildconfig_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >*
BaseProductState::mutable_backgrounddownloadbuildconfig() {
  // @@protoc_insertion_point(field_mutable_list:BaseProductState.backgroundDownloadBuildConfig)
  return &_impl_.backgrounddownloadbuildconfig_;
}
inline const ::BuildConfig& BaseProductState::_internal_backgrounddownloadbuildconfig(int index) const {
  return _impl_.backgrounddownloadbuildconfig_.Get(index);
}
inline const ::BuildConfig& BaseProductState::backgrounddownloadbuildconfig(int index) const {
  // @@protoc_insertion_point(field_get:BaseProductState.backgroundDownloadBuildConfig)
  return _internal_backgrounddownloadbuildconfig(index);
}
inline ::BuildConfig* BaseProductState::_internal_add_backgrounddownloadbuildconfig() {
  return _impl_.backgrounddownloadbuildconfig_.Add();
}
inline ::BuildConfig* BaseProductState::add_backgrounddownloadbuildconfig() {
  ::BuildConfig* _add = _internal_add_backgrounddownloadbuildconfig();
  // @@protoc_insertion_point(field_add:BaseProductState.backgroundDownloadBuildConfig)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BuildConfig >&
BaseProductState::backgrounddownloadbuildconfig() const {
  // @@protoc_insertion_point(field_list:BaseProductState.backgroundDownloadBuildConfig)
  return _impl_.backgrounddownloadbuildconfig_;
}

// optional string decryptionKey = 10;
inline bool BaseProductState::_internal_has_decryptionkey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BaseProductState::has_decryptionkey() const {
  return _internal_has_decryptionkey();
}
inline void BaseProductState::clear_decryptionkey() {
  _impl_.decryptionkey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BaseProductState::decryptionkey() const {
  // @@protoc_insertion_point(field_get:BaseProductState.decryptionKey)
  return _internal_decryptionkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseProductState::set_decryptionkey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.decryptionkey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BaseProductState.decryptionKey)
}
inline std::string* BaseProductState::mutable_decryptionkey() {
  std::string* _s = _internal_mutable_decryptionkey();
  // @@protoc_insertion_point(field_mutable:BaseProductState.decryptionKey)
  return _s;
}
inline const std::string& BaseProductState::_internal_decryptionkey() const {
  return _impl_.decryptionkey_.Get();
}
inline void BaseProductState::_internal_set_decryptionkey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.decryptionkey_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseProductState::_internal_mutable_decryptionkey() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.decryptionkey_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseProductState::release_decryptionkey() {
  // @@protoc_insertion_point(field_release:BaseProductState.decryptionKey)
  if (!_internal_has_decryptionkey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.decryptionkey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.decryptionkey_.IsDefault()) {
    _impl_.decryptionkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BaseProductState::set_allocated_decryptionkey(std::string* decryptionkey) {
  if (decryptionkey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.decryptionkey_.SetAllocated(decryptionkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.decryptionkey_.IsDefault()) {
    _impl_.decryptionkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BaseProductState.decryptionKey)
}

// repeated string completedInstallActions = 11;
inline int BaseProductState::_internal_completedinstallactions_size() const {
  return _impl_.completedinstallactions_.size();
}
inline int BaseProductState::completedinstallactions_size() const {
  return _internal_completedinstallactions_size();
}
inline void BaseProductState::clear_completedinstallactions() {
  _impl_.completedinstallactions_.Clear();
}
inline std::string* BaseProductState::add_completedinstallactions() {
  std::string* _s = _internal_add_completedinstallactions();
  // @@protoc_insertion_point(field_add_mutable:BaseProductState.completedInstallActions)
  return _s;
}
inline const std::string& BaseProductState::_internal_completedinstallactions(int index) const {
  return _impl_.completedinstallactions_.Get(index);
}
inline const std::string& BaseProductState::completedinstallactions(int index) const {
  // @@protoc_insertion_point(field_get:BaseProductState.completedInstallActions)
  return _internal_completedinstallactions(index);
}
inline std::string* BaseProductState::mutable_completedinstallactions(int index) {
  // @@protoc_insertion_point(field_mutable:BaseProductState.completedInstallActions)
  return _impl_.completedinstallactions_.Mutable(index);
}
inline void BaseProductState::set_completedinstallactions(int index, const std::string& value) {
  _impl_.completedinstallactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:BaseProductState.completedInstallActions)
}
inline void BaseProductState::set_completedinstallactions(int index, std::string&& value) {
  _impl_.completedinstallactions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:BaseProductState.completedInstallActions)
}
inline void BaseProductState::set_completedinstallactions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.completedinstallactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BaseProductState.completedInstallActions)
}
inline void BaseProductState::set_completedinstallactions(int index, const char* value, size_t size) {
  _impl_.completedinstallactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BaseProductState.completedInstallActions)
}
inline std::string* BaseProductState::_internal_add_completedinstallactions() {
  return _impl_.completedinstallactions_.Add();
}
inline void BaseProductState::add_completedinstallactions(const std::string& value) {
  _impl_.completedinstallactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BaseProductState.completedInstallActions)
}
inline void BaseProductState::add_completedinstallactions(std::string&& value) {
  _impl_.completedinstallactions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:BaseProductState.completedInstallActions)
}
inline void BaseProductState::add_completedinstallactions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.completedinstallactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BaseProductState.completedInstallActions)
}
inline void BaseProductState::add_completedinstallactions(const char* value, size_t size) {
  _impl_.completedinstallactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BaseProductState.completedInstallActions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BaseProductState::completedinstallactions() const {
  // @@protoc_insertion_point(field_list:BaseProductState.completedInstallActions)
  return _impl_.completedinstallactions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BaseProductState::mutable_completedinstallactions() {
  // @@protoc_insertion_point(field_mutable_list:BaseProductState.completedInstallActions)
  return &_impl_.completedinstallactions_;
}

// repeated string completedBuildKeys = 12;
inline int BaseProductState::_internal_completedbuildkeys_size() const {
  return _impl_.completedbuildkeys_.size();
}
inline int BaseProductState::completedbuildkeys_size() const {
  return _internal_completedbuildkeys_size();
}
inline void BaseProductState::clear_completedbuildkeys() {
  _impl_.completedbuildkeys_.Clear();
}
inline std::string* BaseProductState::add_completedbuildkeys() {
  std::string* _s = _internal_add_completedbuildkeys();
  // @@protoc_insertion_point(field_add_mutable:BaseProductState.completedBuildKeys)
  return _s;
}
inline const std::string& BaseProductState::_internal_completedbuildkeys(int index) const {
  return _impl_.completedbuildkeys_.Get(index);
}
inline const std::string& BaseProductState::completedbuildkeys(int index) const {
  // @@protoc_insertion_point(field_get:BaseProductState.completedBuildKeys)
  return _internal_completedbuildkeys(index);
}
inline std::string* BaseProductState::mutable_completedbuildkeys(int index) {
  // @@protoc_insertion_point(field_mutable:BaseProductState.completedBuildKeys)
  return _impl_.completedbuildkeys_.Mutable(index);
}
inline void BaseProductState::set_completedbuildkeys(int index, const std::string& value) {
  _impl_.completedbuildkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:BaseProductState.completedBuildKeys)
}
inline void BaseProductState::set_completedbuildkeys(int index, std::string&& value) {
  _impl_.completedbuildkeys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:BaseProductState.completedBuildKeys)
}
inline void BaseProductState::set_completedbuildkeys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.completedbuildkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BaseProductState.completedBuildKeys)
}
inline void BaseProductState::set_completedbuildkeys(int index, const char* value, size_t size) {
  _impl_.completedbuildkeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BaseProductState.completedBuildKeys)
}
inline std::string* BaseProductState::_internal_add_completedbuildkeys() {
  return _impl_.completedbuildkeys_.Add();
}
inline void BaseProductState::add_completedbuildkeys(const std::string& value) {
  _impl_.completedbuildkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BaseProductState.completedBuildKeys)
}
inline void BaseProductState::add_completedbuildkeys(std::string&& value) {
  _impl_.completedbuildkeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:BaseProductState.completedBuildKeys)
}
inline void BaseProductState::add_completedbuildkeys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.completedbuildkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BaseProductState.completedBuildKeys)
}
inline void BaseProductState::add_completedbuildkeys(const char* value, size_t size) {
  _impl_.completedbuildkeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BaseProductState.completedBuildKeys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BaseProductState::completedbuildkeys() const {
  // @@protoc_insertion_point(field_list:BaseProductState.completedBuildKeys)
  return _impl_.completedbuildkeys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BaseProductState::mutable_completedbuildkeys() {
  // @@protoc_insertion_point(field_mutable_list:BaseProductState.completedBuildKeys)
  return &_impl_.completedbuildkeys_;
}

// repeated string completedBgdlKeys = 13;
inline int BaseProductState::_internal_completedbgdlkeys_size() const {
  return _impl_.completedbgdlkeys_.size();
}
inline int BaseProductState::completedbgdlkeys_size() const {
  return _internal_completedbgdlkeys_size();
}
inline void BaseProductState::clear_completedbgdlkeys() {
  _impl_.completedbgdlkeys_.Clear();
}
inline std::string* BaseProductState::add_completedbgdlkeys() {
  std::string* _s = _internal_add_completedbgdlkeys();
  // @@protoc_insertion_point(field_add_mutable:BaseProductState.completedBgdlKeys)
  return _s;
}
inline const std::string& BaseProductState::_internal_completedbgdlkeys(int index) const {
  return _impl_.completedbgdlkeys_.Get(index);
}
inline const std::string& BaseProductState::completedbgdlkeys(int index) const {
  // @@protoc_insertion_point(field_get:BaseProductState.completedBgdlKeys)
  return _internal_completedbgdlkeys(index);
}
inline std::string* BaseProductState::mutable_completedbgdlkeys(int index) {
  // @@protoc_insertion_point(field_mutable:BaseProductState.completedBgdlKeys)
  return _impl_.completedbgdlkeys_.Mutable(index);
}
inline void BaseProductState::set_completedbgdlkeys(int index, const std::string& value) {
  _impl_.completedbgdlkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:BaseProductState.completedBgdlKeys)
}
inline void BaseProductState::set_completedbgdlkeys(int index, std::string&& value) {
  _impl_.completedbgdlkeys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:BaseProductState.completedBgdlKeys)
}
inline void BaseProductState::set_completedbgdlkeys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.completedbgdlkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BaseProductState.completedBgdlKeys)
}
inline void BaseProductState::set_completedbgdlkeys(int index, const char* value, size_t size) {
  _impl_.completedbgdlkeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BaseProductState.completedBgdlKeys)
}
inline std::string* BaseProductState::_internal_add_completedbgdlkeys() {
  return _impl_.completedbgdlkeys_.Add();
}
inline void BaseProductState::add_completedbgdlkeys(const std::string& value) {
  _impl_.completedbgdlkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BaseProductState.completedBgdlKeys)
}
inline void BaseProductState::add_completedbgdlkeys(std::string&& value) {
  _impl_.completedbgdlkeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:BaseProductState.completedBgdlKeys)
}
inline void BaseProductState::add_completedbgdlkeys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.completedbgdlkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BaseProductState.completedBgdlKeys)
}
inline void BaseProductState::add_completedbgdlkeys(const char* value, size_t size) {
  _impl_.completedbgdlkeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BaseProductState.completedBgdlKeys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BaseProductState::completedbgdlkeys() const {
  // @@protoc_insertion_point(field_list:BaseProductState.completedBgdlKeys)
  return _impl_.completedbgdlkeys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BaseProductState::mutable_completedbgdlkeys() {
  // @@protoc_insertion_point(field_mutable_list:BaseProductState.completedBgdlKeys)
  return &_impl_.completedbgdlkeys_;
}

// repeated string activeBuildKey = 14;
inline int BaseProductState::_internal_activebuildkey_size() const {
  return _impl_.activebuildkey_.size();
}
inline int BaseProductState::activebuildkey_size() const {
  return _internal_activebuildkey_size();
}
inline void BaseProductState::clear_activebuildkey() {
  _impl_.activebuildkey_.Clear();
}
inline std::string* BaseProductState::add_activebuildkey() {
  std::string* _s = _internal_add_activebuildkey();
  // @@protoc_insertion_point(field_add_mutable:BaseProductState.activeBuildKey)
  return _s;
}
inline const std::string& BaseProductState::_internal_activebuildkey(int index) const {
  return _impl_.activebuildkey_.Get(index);
}
inline const std::string& BaseProductState::activebuildkey(int index) const {
  // @@protoc_insertion_point(field_get:BaseProductState.activeBuildKey)
  return _internal_activebuildkey(index);
}
inline std::string* BaseProductState::mutable_activebuildkey(int index) {
  // @@protoc_insertion_point(field_mutable:BaseProductState.activeBuildKey)
  return _impl_.activebuildkey_.Mutable(index);
}
inline void BaseProductState::set_activebuildkey(int index, const std::string& value) {
  _impl_.activebuildkey_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:BaseProductState.activeBuildKey)
}
inline void BaseProductState::set_activebuildkey(int index, std::string&& value) {
  _impl_.activebuildkey_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:BaseProductState.activeBuildKey)
}
inline void BaseProductState::set_activebuildkey(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.activebuildkey_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BaseProductState.activeBuildKey)
}
inline void BaseProductState::set_activebuildkey(int index, const char* value, size_t size) {
  _impl_.activebuildkey_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BaseProductState.activeBuildKey)
}
inline std::string* BaseProductState::_internal_add_activebuildkey() {
  return _impl_.activebuildkey_.Add();
}
inline void BaseProductState::add_activebuildkey(const std::string& value) {
  _impl_.activebuildkey_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BaseProductState.activeBuildKey)
}
inline void BaseProductState::add_activebuildkey(std::string&& value) {
  _impl_.activebuildkey_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:BaseProductState.activeBuildKey)
}
inline void BaseProductState::add_activebuildkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.activebuildkey_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BaseProductState.activeBuildKey)
}
inline void BaseProductState::add_activebuildkey(const char* value, size_t size) {
  _impl_.activebuildkey_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BaseProductState.activeBuildKey)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BaseProductState::activebuildkey() const {
  // @@protoc_insertion_point(field_list:BaseProductState.activeBuildKey)
  return _impl_.activebuildkey_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BaseProductState::mutable_activebuildkey() {
  // @@protoc_insertion_point(field_mutable_list:BaseProductState.activeBuildKey)
  return &_impl_.activebuildkey_;
}

// repeated string activeBgdlKey = 15;
inline int BaseProductState::_internal_activebgdlkey_size() const {
  return _impl_.activebgdlkey_.size();
}
inline int BaseProductState::activebgdlkey_size() const {
  return _internal_activebgdlkey_size();
}
inline void BaseProductState::clear_activebgdlkey() {
  _impl_.activebgdlkey_.Clear();
}
inline std::string* BaseProductState::add_activebgdlkey() {
  std::string* _s = _internal_add_activebgdlkey();
  // @@protoc_insertion_point(field_add_mutable:BaseProductState.activeBgdlKey)
  return _s;
}
inline const std::string& BaseProductState::_internal_activebgdlkey(int index) const {
  return _impl_.activebgdlkey_.Get(index);
}
inline const std::string& BaseProductState::activebgdlkey(int index) const {
  // @@protoc_insertion_point(field_get:BaseProductState.activeBgdlKey)
  return _internal_activebgdlkey(index);
}
inline std::string* BaseProductState::mutable_activebgdlkey(int index) {
  // @@protoc_insertion_point(field_mutable:BaseProductState.activeBgdlKey)
  return _impl_.activebgdlkey_.Mutable(index);
}
inline void BaseProductState::set_activebgdlkey(int index, const std::string& value) {
  _impl_.activebgdlkey_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:BaseProductState.activeBgdlKey)
}
inline void BaseProductState::set_activebgdlkey(int index, std::string&& value) {
  _impl_.activebgdlkey_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:BaseProductState.activeBgdlKey)
}
inline void BaseProductState::set_activebgdlkey(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.activebgdlkey_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BaseProductState.activeBgdlKey)
}
inline void BaseProductState::set_activebgdlkey(int index, const char* value, size_t size) {
  _impl_.activebgdlkey_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BaseProductState.activeBgdlKey)
}
inline std::string* BaseProductState::_internal_add_activebgdlkey() {
  return _impl_.activebgdlkey_.Add();
}
inline void BaseProductState::add_activebgdlkey(const std::string& value) {
  _impl_.activebgdlkey_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BaseProductState.activeBgdlKey)
}
inline void BaseProductState::add_activebgdlkey(std::string&& value) {
  _impl_.activebgdlkey_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:BaseProductState.activeBgdlKey)
}
inline void BaseProductState::add_activebgdlkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.activebgdlkey_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BaseProductState.activeBgdlKey)
}
inline void BaseProductState::add_activebgdlkey(const char* value, size_t size) {
  _impl_.activebgdlkey_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BaseProductState.activeBgdlKey)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BaseProductState::activebgdlkey() const {
  // @@protoc_insertion_point(field_list:BaseProductState.activeBgdlKey)
  return _impl_.activebgdlkey_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BaseProductState::mutable_activebgdlkey() {
  // @@protoc_insertion_point(field_mutable_list:BaseProductState.activeBgdlKey)
  return &_impl_.activebgdlkey_;
}

// repeated string activeInstallKey = 16;
inline int BaseProductState::_internal_activeinstallkey_size() const {
  return _impl_.activeinstallkey_.size();
}
inline int BaseProductState::activeinstallkey_size() const {
  return _internal_activeinstallkey_size();
}
inline void BaseProductState::clear_activeinstallkey() {
  _impl_.activeinstallkey_.Clear();
}
inline std::string* BaseProductState::add_activeinstallkey() {
  std::string* _s = _internal_add_activeinstallkey();
  // @@protoc_insertion_point(field_add_mutable:BaseProductState.activeInstallKey)
  return _s;
}
inline const std::string& BaseProductState::_internal_activeinstallkey(int index) const {
  return _impl_.activeinstallkey_.Get(index);
}
inline const std::string& BaseProductState::activeinstallkey(int index) const {
  // @@protoc_insertion_point(field_get:BaseProductState.activeInstallKey)
  return _internal_activeinstallkey(index);
}
inline std::string* BaseProductState::mutable_activeinstallkey(int index) {
  // @@protoc_insertion_point(field_mutable:BaseProductState.activeInstallKey)
  return _impl_.activeinstallkey_.Mutable(index);
}
inline void BaseProductState::set_activeinstallkey(int index, const std::string& value) {
  _impl_.activeinstallkey_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:BaseProductState.activeInstallKey)
}
inline void BaseProductState::set_activeinstallkey(int index, std::string&& value) {
  _impl_.activeinstallkey_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:BaseProductState.activeInstallKey)
}
inline void BaseProductState::set_activeinstallkey(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.activeinstallkey_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BaseProductState.activeInstallKey)
}
inline void BaseProductState::set_activeinstallkey(int index, const char* value, size_t size) {
  _impl_.activeinstallkey_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BaseProductState.activeInstallKey)
}
inline std::string* BaseProductState::_internal_add_activeinstallkey() {
  return _impl_.activeinstallkey_.Add();
}
inline void BaseProductState::add_activeinstallkey(const std::string& value) {
  _impl_.activeinstallkey_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BaseProductState.activeInstallKey)
}
inline void BaseProductState::add_activeinstallkey(std::string&& value) {
  _impl_.activeinstallkey_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:BaseProductState.activeInstallKey)
}
inline void BaseProductState::add_activeinstallkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.activeinstallkey_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BaseProductState.activeInstallKey)
}
inline void BaseProductState::add_activeinstallkey(const char* value, size_t size) {
  _impl_.activeinstallkey_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BaseProductState.activeInstallKey)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BaseProductState::activeinstallkey() const {
  // @@protoc_insertion_point(field_list:BaseProductState.activeInstallKey)
  return _impl_.activeinstallkey_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BaseProductState::mutable_activeinstallkey() {
  // @@protoc_insertion_point(field_mutable_list:BaseProductState.activeInstallKey)
  return &_impl_.activeinstallkey_;
}

// repeated string activeTagString = 17;
inline int BaseProductState::_internal_activetagstring_size() const {
  return _impl_.activetagstring_.size();
}
inline int BaseProductState::activetagstring_size() const {
  return _internal_activetagstring_size();
}
inline void BaseProductState::clear_activetagstring() {
  _impl_.activetagstring_.Clear();
}
inline std::string* BaseProductState::add_activetagstring() {
  std::string* _s = _internal_add_activetagstring();
  // @@protoc_insertion_point(field_add_mutable:BaseProductState.activeTagString)
  return _s;
}
inline const std::string& BaseProductState::_internal_activetagstring(int index) const {
  return _impl_.activetagstring_.Get(index);
}
inline const std::string& BaseProductState::activetagstring(int index) const {
  // @@protoc_insertion_point(field_get:BaseProductState.activeTagString)
  return _internal_activetagstring(index);
}
inline std::string* BaseProductState::mutable_activetagstring(int index) {
  // @@protoc_insertion_point(field_mutable:BaseProductState.activeTagString)
  return _impl_.activetagstring_.Mutable(index);
}
inline void BaseProductState::set_activetagstring(int index, const std::string& value) {
  _impl_.activetagstring_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:BaseProductState.activeTagString)
}
inline void BaseProductState::set_activetagstring(int index, std::string&& value) {
  _impl_.activetagstring_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:BaseProductState.activeTagString)
}
inline void BaseProductState::set_activetagstring(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.activetagstring_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BaseProductState.activeTagString)
}
inline void BaseProductState::set_activetagstring(int index, const char* value, size_t size) {
  _impl_.activetagstring_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BaseProductState.activeTagString)
}
inline std::string* BaseProductState::_internal_add_activetagstring() {
  return _impl_.activetagstring_.Add();
}
inline void BaseProductState::add_activetagstring(const std::string& value) {
  _impl_.activetagstring_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BaseProductState.activeTagString)
}
inline void BaseProductState::add_activetagstring(std::string&& value) {
  _impl_.activetagstring_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:BaseProductState.activeTagString)
}
inline void BaseProductState::add_activetagstring(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.activetagstring_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BaseProductState.activeTagString)
}
inline void BaseProductState::add_activetagstring(const char* value, size_t size) {
  _impl_.activetagstring_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BaseProductState.activeTagString)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BaseProductState::activetagstring() const {
  // @@protoc_insertion_point(field_list:BaseProductState.activeTagString)
  return _impl_.activetagstring_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BaseProductState::mutable_activetagstring() {
  // @@protoc_insertion_point(field_mutable_list:BaseProductState.activeTagString)
  return &_impl_.activetagstring_;
}

// repeated string incompleteBuildKey = 18;
inline int BaseProductState::_internal_incompletebuildkey_size() const {
  return _impl_.incompletebuildkey_.size();
}
inline int BaseProductState::incompletebuildkey_size() const {
  return _internal_incompletebuildkey_size();
}
inline void BaseProductState::clear_incompletebuildkey() {
  _impl_.incompletebuildkey_.Clear();
}
inline std::string* BaseProductState::add_incompletebuildkey() {
  std::string* _s = _internal_add_incompletebuildkey();
  // @@protoc_insertion_point(field_add_mutable:BaseProductState.incompleteBuildKey)
  return _s;
}
inline const std::string& BaseProductState::_internal_incompletebuildkey(int index) const {
  return _impl_.incompletebuildkey_.Get(index);
}
inline const std::string& BaseProductState::incompletebuildkey(int index) const {
  // @@protoc_insertion_point(field_get:BaseProductState.incompleteBuildKey)
  return _internal_incompletebuildkey(index);
}
inline std::string* BaseProductState::mutable_incompletebuildkey(int index) {
  // @@protoc_insertion_point(field_mutable:BaseProductState.incompleteBuildKey)
  return _impl_.incompletebuildkey_.Mutable(index);
}
inline void BaseProductState::set_incompletebuildkey(int index, const std::string& value) {
  _impl_.incompletebuildkey_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:BaseProductState.incompleteBuildKey)
}
inline void BaseProductState::set_incompletebuildkey(int index, std::string&& value) {
  _impl_.incompletebuildkey_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:BaseProductState.incompleteBuildKey)
}
inline void BaseProductState::set_incompletebuildkey(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.incompletebuildkey_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BaseProductState.incompleteBuildKey)
}
inline void BaseProductState::set_incompletebuildkey(int index, const char* value, size_t size) {
  _impl_.incompletebuildkey_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BaseProductState.incompleteBuildKey)
}
inline std::string* BaseProductState::_internal_add_incompletebuildkey() {
  return _impl_.incompletebuildkey_.Add();
}
inline void BaseProductState::add_incompletebuildkey(const std::string& value) {
  _impl_.incompletebuildkey_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BaseProductState.incompleteBuildKey)
}
inline void BaseProductState::add_incompletebuildkey(std::string&& value) {
  _impl_.incompletebuildkey_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:BaseProductState.incompleteBuildKey)
}
inline void BaseProductState::add_incompletebuildkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.incompletebuildkey_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BaseProductState.incompleteBuildKey)
}
inline void BaseProductState::add_incompletebuildkey(const char* value, size_t size) {
  _impl_.incompletebuildkey_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BaseProductState.incompleteBuildKey)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BaseProductState::incompletebuildkey() const {
  // @@protoc_insertion_point(field_list:BaseProductState.incompleteBuildKey)
  return _impl_.incompletebuildkey_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BaseProductState::mutable_incompletebuildkey() {
  // @@protoc_insertion_point(field_mutable_list:BaseProductState.incompleteBuildKey)
  return &_impl_.incompletebuildkey_;
}

// -------------------------------------------------------------------

// BackfillProgress

// optional double progress = 1;
inline bool BackfillProgress::_internal_has_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BackfillProgress::has_progress() const {
  return _internal_has_progress();
}
inline void BackfillProgress::clear_progress() {
  _impl_.progress_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double BackfillProgress::_internal_progress() const {
  return _impl_.progress_;
}
inline double BackfillProgress::progress() const {
  // @@protoc_insertion_point(field_get:BackfillProgress.progress)
  return _internal_progress();
}
inline void BackfillProgress::_internal_set_progress(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.progress_ = value;
}
inline void BackfillProgress::set_progress(double value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:BackfillProgress.progress)
}

// optional bool backgrounddownload = 2;
inline bool BackfillProgress::_internal_has_backgrounddownload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BackfillProgress::has_backgrounddownload() const {
  return _internal_has_backgrounddownload();
}
inline void BackfillProgress::clear_backgrounddownload() {
  _impl_.backgrounddownload_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool BackfillProgress::_internal_backgrounddownload() const {
  return _impl_.backgrounddownload_;
}
inline bool BackfillProgress::backgrounddownload() const {
  // @@protoc_insertion_point(field_get:BackfillProgress.backgrounddownload)
  return _internal_backgrounddownload();
}
inline void BackfillProgress::_internal_set_backgrounddownload(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.backgrounddownload_ = value;
}
inline void BackfillProgress::set_backgrounddownload(bool value) {
  _internal_set_backgrounddownload(value);
  // @@protoc_insertion_point(field_set:BackfillProgress.backgrounddownload)
}

// optional bool paused = 3;
inline bool BackfillProgress::_internal_has_paused() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BackfillProgress::has_paused() const {
  return _internal_has_paused();
}
inline void BackfillProgress::clear_paused() {
  _impl_.paused_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool BackfillProgress::_internal_paused() const {
  return _impl_.paused_;
}
inline bool BackfillProgress::paused() const {
  // @@protoc_insertion_point(field_get:BackfillProgress.paused)
  return _internal_paused();
}
inline void BackfillProgress::_internal_set_paused(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.paused_ = value;
}
inline void BackfillProgress::set_paused(bool value) {
  _internal_set_paused(value);
  // @@protoc_insertion_point(field_set:BackfillProgress.paused)
}

// optional uint64 downloadLimit = 4;
inline bool BackfillProgress::_internal_has_downloadlimit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BackfillProgress::has_downloadlimit() const {
  return _internal_has_downloadlimit();
}
inline void BackfillProgress::clear_downloadlimit() {
  _impl_.downloadlimit_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t BackfillProgress::_internal_downloadlimit() const {
  return _impl_.downloadlimit_;
}
inline uint64_t BackfillProgress::downloadlimit() const {
  // @@protoc_insertion_point(field_get:BackfillProgress.downloadLimit)
  return _internal_downloadlimit();
}
inline void BackfillProgress::_internal_set_downloadlimit(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.downloadlimit_ = value;
}
inline void BackfillProgress::set_downloadlimit(uint64_t value) {
  _internal_set_downloadlimit(value);
  // @@protoc_insertion_point(field_set:BackfillProgress.downloadLimit)
}

// -------------------------------------------------------------------

// RepairProgress

// optional double progress = 1;
inline bool RepairProgress::_internal_has_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RepairProgress::has_progress() const {
  return _internal_has_progress();
}
inline void RepairProgress::clear_progress() {
  _impl_.progress_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double RepairProgress::_internal_progress() const {
  return _impl_.progress_;
}
inline double RepairProgress::progress() const {
  // @@protoc_insertion_point(field_get:RepairProgress.progress)
  return _internal_progress();
}
inline void RepairProgress::_internal_set_progress(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.progress_ = value;
}
inline void RepairProgress::set_progress(double value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:RepairProgress.progress)
}

// -------------------------------------------------------------------

// UpdateProgress

// optional string lastDiscSetUsed = 1;
inline bool UpdateProgress::_internal_has_lastdiscsetused() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateProgress::has_lastdiscsetused() const {
  return _internal_has_lastdiscsetused();
}
inline void UpdateProgress::clear_lastdiscsetused() {
  _impl_.lastdiscsetused_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateProgress::lastdiscsetused() const {
  // @@protoc_insertion_point(field_get:UpdateProgress.lastDiscSetUsed)
  return _internal_lastdiscsetused();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateProgress::set_lastdiscsetused(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.lastdiscsetused_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UpdateProgress.lastDiscSetUsed)
}
inline std::string* UpdateProgress::mutable_lastdiscsetused() {
  std::string* _s = _internal_mutable_lastdiscsetused();
  // @@protoc_insertion_point(field_mutable:UpdateProgress.lastDiscSetUsed)
  return _s;
}
inline const std::string& UpdateProgress::_internal_lastdiscsetused() const {
  return _impl_.lastdiscsetused_.Get();
}
inline void UpdateProgress::_internal_set_lastdiscsetused(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lastdiscsetused_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateProgress::_internal_mutable_lastdiscsetused() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.lastdiscsetused_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateProgress::release_lastdiscsetused() {
  // @@protoc_insertion_point(field_release:UpdateProgress.lastDiscSetUsed)
  if (!_internal_has_lastdiscsetused()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.lastdiscsetused_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lastdiscsetused_.IsDefault()) {
    _impl_.lastdiscsetused_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateProgress::set_allocated_lastdiscsetused(std::string* lastdiscsetused) {
  if (lastdiscsetused != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.lastdiscsetused_.SetAllocated(lastdiscsetused, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lastdiscsetused_.IsDefault()) {
    _impl_.lastdiscsetused_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UpdateProgress.lastDiscSetUsed)
}

// optional double progress = 2;
inline bool UpdateProgress::_internal_has_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateProgress::has_progress() const {
  return _internal_has_progress();
}
inline void UpdateProgress::clear_progress() {
  _impl_.progress_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double UpdateProgress::_internal_progress() const {
  return _impl_.progress_;
}
inline double UpdateProgress::progress() const {
  // @@protoc_insertion_point(field_get:UpdateProgress.progress)
  return _internal_progress();
}
inline void UpdateProgress::_internal_set_progress(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.progress_ = value;
}
inline void UpdateProgress::set_progress(double value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:UpdateProgress.progress)
}

// optional bool discIgnored = 3;
inline bool UpdateProgress::_internal_has_discignored() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UpdateProgress::has_discignored() const {
  return _internal_has_discignored();
}
inline void UpdateProgress::clear_discignored() {
  _impl_.discignored_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool UpdateProgress::_internal_discignored() const {
  return _impl_.discignored_;
}
inline bool UpdateProgress::discignored() const {
  // @@protoc_insertion_point(field_get:UpdateProgress.discIgnored)
  return _internal_discignored();
}
inline void UpdateProgress::_internal_set_discignored(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.discignored_ = value;
}
inline void UpdateProgress::set_discignored(bool value) {
  _internal_set_discignored(value);
  // @@protoc_insertion_point(field_set:UpdateProgress.discIgnored)
}

// optional uint64 totalToDownload = 4 [default = 0];
inline bool UpdateProgress::_internal_has_totaltodownload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateProgress::has_totaltodownload() const {
  return _internal_has_totaltodownload();
}
inline void UpdateProgress::clear_totaltodownload() {
  _impl_.totaltodownload_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t UpdateProgress::_internal_totaltodownload() const {
  return _impl_.totaltodownload_;
}
inline uint64_t UpdateProgress::totaltodownload() const {
  // @@protoc_insertion_point(field_get:UpdateProgress.totalToDownload)
  return _internal_totaltodownload();
}
inline void UpdateProgress::_internal_set_totaltodownload(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.totaltodownload_ = value;
}
inline void UpdateProgress::set_totaltodownload(uint64_t value) {
  _internal_set_totaltodownload(value);
  // @@protoc_insertion_point(field_set:UpdateProgress.totalToDownload)
}

// optional uint64 downloadRemaining = 5 [default = 0];
inline bool UpdateProgress::_internal_has_downloadremaining() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UpdateProgress::has_downloadremaining() const {
  return _internal_has_downloadremaining();
}
inline void UpdateProgress::clear_downloadremaining() {
  _impl_.downloadremaining_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t UpdateProgress::_internal_downloadremaining() const {
  return _impl_.downloadremaining_;
}
inline uint64_t UpdateProgress::downloadremaining() const {
  // @@protoc_insertion_point(field_get:UpdateProgress.downloadRemaining)
  return _internal_downloadremaining();
}
inline void UpdateProgress::_internal_set_downloadremaining(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.downloadremaining_ = value;
}
inline void UpdateProgress::set_downloadremaining(uint64_t value) {
  _internal_set_downloadremaining(value);
  // @@protoc_insertion_point(field_set:UpdateProgress.downloadRemaining)
}

// -------------------------------------------------------------------

// CachedProductState

// optional .BaseProductState baseProductState = 1;
inline bool CachedProductState::_internal_has_baseproductstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.baseproductstate_ != nullptr);
  return value;
}
inline bool CachedProductState::has_baseproductstate() const {
  return _internal_has_baseproductstate();
}
inline void CachedProductState::clear_baseproductstate() {
  if (_impl_.baseproductstate_ != nullptr) _impl_.baseproductstate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::BaseProductState& CachedProductState::_internal_baseproductstate() const {
  const ::BaseProductState* p = _impl_.baseproductstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::BaseProductState&>(
      ::_BaseProductState_default_instance_);
}
inline const ::BaseProductState& CachedProductState::baseproductstate() const {
  // @@protoc_insertion_point(field_get:CachedProductState.baseProductState)
  return _internal_baseproductstate();
}
inline void CachedProductState::unsafe_arena_set_allocated_baseproductstate(
    ::BaseProductState* baseproductstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.baseproductstate_);
  }
  _impl_.baseproductstate_ = baseproductstate;
  if (baseproductstate) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CachedProductState.baseProductState)
}
inline ::BaseProductState* CachedProductState::release_baseproductstate() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::BaseProductState* temp = _impl_.baseproductstate_;
  _impl_.baseproductstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BaseProductState* CachedProductState::unsafe_arena_release_baseproductstate() {
  // @@protoc_insertion_point(field_release:CachedProductState.baseProductState)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::BaseProductState* temp = _impl_.baseproductstate_;
  _impl_.baseproductstate_ = nullptr;
  return temp;
}
inline ::BaseProductState* CachedProductState::_internal_mutable_baseproductstate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.baseproductstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::BaseProductState>(GetArenaForAllocation());
    _impl_.baseproductstate_ = p;
  }
  return _impl_.baseproductstate_;
}
inline ::BaseProductState* CachedProductState::mutable_baseproductstate() {
  ::BaseProductState* _msg = _internal_mutable_baseproductstate();
  // @@protoc_insertion_point(field_mutable:CachedProductState.baseProductState)
  return _msg;
}
inline void CachedProductState::set_allocated_baseproductstate(::BaseProductState* baseproductstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.baseproductstate_;
  }
  if (baseproductstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(baseproductstate);
    if (message_arena != submessage_arena) {
      baseproductstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, baseproductstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.baseproductstate_ = baseproductstate;
  // @@protoc_insertion_point(field_set_allocated:CachedProductState.baseProductState)
}

// optional .BackfillProgress backfillProgress = 2;
inline bool CachedProductState::_internal_has_backfillprogress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.backfillprogress_ != nullptr);
  return value;
}
inline bool CachedProductState::has_backfillprogress() const {
  return _internal_has_backfillprogress();
}
inline void CachedProductState::clear_backfillprogress() {
  if (_impl_.backfillprogress_ != nullptr) _impl_.backfillprogress_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::BackfillProgress& CachedProductState::_internal_backfillprogress() const {
  const ::BackfillProgress* p = _impl_.backfillprogress_;
  return p != nullptr ? *p : reinterpret_cast<const ::BackfillProgress&>(
      ::_BackfillProgress_default_instance_);
}
inline const ::BackfillProgress& CachedProductState::backfillprogress() const {
  // @@protoc_insertion_point(field_get:CachedProductState.backfillProgress)
  return _internal_backfillprogress();
}
inline void CachedProductState::unsafe_arena_set_allocated_backfillprogress(
    ::BackfillProgress* backfillprogress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.backfillprogress_);
  }
  _impl_.backfillprogress_ = backfillprogress;
  if (backfillprogress) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CachedProductState.backfillProgress)
}
inline ::BackfillProgress* CachedProductState::release_backfillprogress() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::BackfillProgress* temp = _impl_.backfillprogress_;
  _impl_.backfillprogress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BackfillProgress* CachedProductState::unsafe_arena_release_backfillprogress() {
  // @@protoc_insertion_point(field_release:CachedProductState.backfillProgress)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::BackfillProgress* temp = _impl_.backfillprogress_;
  _impl_.backfillprogress_ = nullptr;
  return temp;
}
inline ::BackfillProgress* CachedProductState::_internal_mutable_backfillprogress() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.backfillprogress_ == nullptr) {
    auto* p = CreateMaybeMessage<::BackfillProgress>(GetArenaForAllocation());
    _impl_.backfillprogress_ = p;
  }
  return _impl_.backfillprogress_;
}
inline ::BackfillProgress* CachedProductState::mutable_backfillprogress() {
  ::BackfillProgress* _msg = _internal_mutable_backfillprogress();
  // @@protoc_insertion_point(field_mutable:CachedProductState.backfillProgress)
  return _msg;
}
inline void CachedProductState::set_allocated_backfillprogress(::BackfillProgress* backfillprogress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.backfillprogress_;
  }
  if (backfillprogress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(backfillprogress);
    if (message_arena != submessage_arena) {
      backfillprogress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, backfillprogress, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.backfillprogress_ = backfillprogress;
  // @@protoc_insertion_point(field_set_allocated:CachedProductState.backfillProgress)
}

// optional .RepairProgress repairProgress = 3;
inline bool CachedProductState::_internal_has_repairprogress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.repairprogress_ != nullptr);
  return value;
}
inline bool CachedProductState::has_repairprogress() const {
  return _internal_has_repairprogress();
}
inline void CachedProductState::clear_repairprogress() {
  if (_impl_.repairprogress_ != nullptr) _impl_.repairprogress_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::RepairProgress& CachedProductState::_internal_repairprogress() const {
  const ::RepairProgress* p = _impl_.repairprogress_;
  return p != nullptr ? *p : reinterpret_cast<const ::RepairProgress&>(
      ::_RepairProgress_default_instance_);
}
inline const ::RepairProgress& CachedProductState::repairprogress() const {
  // @@protoc_insertion_point(field_get:CachedProductState.repairProgress)
  return _internal_repairprogress();
}
inline void CachedProductState::unsafe_arena_set_allocated_repairprogress(
    ::RepairProgress* repairprogress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.repairprogress_);
  }
  _impl_.repairprogress_ = repairprogress;
  if (repairprogress) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CachedProductState.repairProgress)
}
inline ::RepairProgress* CachedProductState::release_repairprogress() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::RepairProgress* temp = _impl_.repairprogress_;
  _impl_.repairprogress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RepairProgress* CachedProductState::unsafe_arena_release_repairprogress() {
  // @@protoc_insertion_point(field_release:CachedProductState.repairProgress)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::RepairProgress* temp = _impl_.repairprogress_;
  _impl_.repairprogress_ = nullptr;
  return temp;
}
inline ::RepairProgress* CachedProductState::_internal_mutable_repairprogress() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.repairprogress_ == nullptr) {
    auto* p = CreateMaybeMessage<::RepairProgress>(GetArenaForAllocation());
    _impl_.repairprogress_ = p;
  }
  return _impl_.repairprogress_;
}
inline ::RepairProgress* CachedProductState::mutable_repairprogress() {
  ::RepairProgress* _msg = _internal_mutable_repairprogress();
  // @@protoc_insertion_point(field_mutable:CachedProductState.repairProgress)
  return _msg;
}
inline void CachedProductState::set_allocated_repairprogress(::RepairProgress* repairprogress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.repairprogress_;
  }
  if (repairprogress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(repairprogress);
    if (message_arena != submessage_arena) {
      repairprogress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repairprogress, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.repairprogress_ = repairprogress;
  // @@protoc_insertion_point(field_set_allocated:CachedProductState.repairProgress)
}

// optional .UpdateProgress updateProgress = 4;
inline bool CachedProductState::_internal_has_updateprogress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updateprogress_ != nullptr);
  return value;
}
inline bool CachedProductState::has_updateprogress() const {
  return _internal_has_updateprogress();
}
inline void CachedProductState::clear_updateprogress() {
  if (_impl_.updateprogress_ != nullptr) _impl_.updateprogress_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::UpdateProgress& CachedProductState::_internal_updateprogress() const {
  const ::UpdateProgress* p = _impl_.updateprogress_;
  return p != nullptr ? *p : reinterpret_cast<const ::UpdateProgress&>(
      ::_UpdateProgress_default_instance_);
}
inline const ::UpdateProgress& CachedProductState::updateprogress() const {
  // @@protoc_insertion_point(field_get:CachedProductState.updateProgress)
  return _internal_updateprogress();
}
inline void CachedProductState::unsafe_arena_set_allocated_updateprogress(
    ::UpdateProgress* updateprogress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updateprogress_);
  }
  _impl_.updateprogress_ = updateprogress;
  if (updateprogress) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CachedProductState.updateProgress)
}
inline ::UpdateProgress* CachedProductState::release_updateprogress() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::UpdateProgress* temp = _impl_.updateprogress_;
  _impl_.updateprogress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UpdateProgress* CachedProductState::unsafe_arena_release_updateprogress() {
  // @@protoc_insertion_point(field_release:CachedProductState.updateProgress)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::UpdateProgress* temp = _impl_.updateprogress_;
  _impl_.updateprogress_ = nullptr;
  return temp;
}
inline ::UpdateProgress* CachedProductState::_internal_mutable_updateprogress() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.updateprogress_ == nullptr) {
    auto* p = CreateMaybeMessage<::UpdateProgress>(GetArenaForAllocation());
    _impl_.updateprogress_ = p;
  }
  return _impl_.updateprogress_;
}
inline ::UpdateProgress* CachedProductState::mutable_updateprogress() {
  ::UpdateProgress* _msg = _internal_mutable_updateprogress();
  // @@protoc_insertion_point(field_mutable:CachedProductState.updateProgress)
  return _msg;
}
inline void CachedProductState::set_allocated_updateprogress(::UpdateProgress* updateprogress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.updateprogress_;
  }
  if (updateprogress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(updateprogress);
    if (message_arena != submessage_arena) {
      updateprogress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updateprogress, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.updateprogress_ = updateprogress;
  // @@protoc_insertion_point(field_set_allocated:CachedProductState.updateProgress)
}

// -------------------------------------------------------------------

// ProductOperations

// optional .Operation activeOperation = 1 [default = OP_NONE];
inline bool ProductOperations::_internal_has_activeoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProductOperations::has_activeoperation() const {
  return _internal_has_activeoperation();
}
inline void ProductOperations::clear_activeoperation() {
  _impl_.activeoperation_ = -1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::Operation ProductOperations::_internal_activeoperation() const {
  return static_cast< ::Operation >(_impl_.activeoperation_);
}
inline ::Operation ProductOperations::activeoperation() const {
  // @@protoc_insertion_point(field_get:ProductOperations.activeOperation)
  return _internal_activeoperation();
}
inline void ProductOperations::_internal_set_activeoperation(::Operation value) {
  assert(::Operation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.activeoperation_ = value;
}
inline void ProductOperations::set_activeoperation(::Operation value) {
  _internal_set_activeoperation(value);
  // @@protoc_insertion_point(field_set:ProductOperations.activeOperation)
}

// optional uint64 priority = 2;
inline bool ProductOperations::_internal_has_priority() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProductOperations::has_priority() const {
  return _internal_has_priority();
}
inline void ProductOperations::clear_priority() {
  _impl_.priority_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ProductOperations::_internal_priority() const {
  return _impl_.priority_;
}
inline uint64_t ProductOperations::priority() const {
  // @@protoc_insertion_point(field_get:ProductOperations.priority)
  return _internal_priority();
}
inline void ProductOperations::_internal_set_priority(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.priority_ = value;
}
inline void ProductOperations::set_priority(uint64_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:ProductOperations.priority)
}

// -------------------------------------------------------------------

// ProductInstall

// optional string uid = 1;
inline bool ProductInstall::_internal_has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProductInstall::has_uid() const {
  return _internal_has_uid();
}
inline void ProductInstall::clear_uid() {
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProductInstall::uid() const {
  // @@protoc_insertion_point(field_get:ProductInstall.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductInstall::set_uid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProductInstall.uid)
}
inline std::string* ProductInstall::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:ProductInstall.uid)
  return _s;
}
inline const std::string& ProductInstall::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void ProductInstall::_internal_set_uid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductInstall::_internal_mutable_uid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductInstall::release_uid() {
  // @@protoc_insertion_point(field_release:ProductInstall.uid)
  if (!_internal_has_uid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.uid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductInstall::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProductInstall.uid)
}

// optional string productCode = 2;
inline bool ProductInstall::_internal_has_productcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProductInstall::has_productcode() const {
  return _internal_has_productcode();
}
inline void ProductInstall::clear_productcode() {
  _impl_.productcode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProductInstall::productcode() const {
  // @@protoc_insertion_point(field_get:ProductInstall.productCode)
  return _internal_productcode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductInstall::set_productcode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.productcode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProductInstall.productCode)
}
inline std::string* ProductInstall::mutable_productcode() {
  std::string* _s = _internal_mutable_productcode();
  // @@protoc_insertion_point(field_mutable:ProductInstall.productCode)
  return _s;
}
inline const std::string& ProductInstall::_internal_productcode() const {
  return _impl_.productcode_.Get();
}
inline void ProductInstall::_internal_set_productcode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.productcode_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductInstall::_internal_mutable_productcode() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.productcode_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductInstall::release_productcode() {
  // @@protoc_insertion_point(field_release:ProductInstall.productCode)
  if (!_internal_has_productcode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.productcode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.productcode_.IsDefault()) {
    _impl_.productcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductInstall::set_allocated_productcode(std::string* productcode) {
  if (productcode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.productcode_.SetAllocated(productcode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.productcode_.IsDefault()) {
    _impl_.productcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProductInstall.productCode)
}

// optional .UserSettings settings = 3;
inline bool ProductInstall::_internal_has_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.settings_ != nullptr);
  return value;
}
inline bool ProductInstall::has_settings() const {
  return _internal_has_settings();
}
inline void ProductInstall::clear_settings() {
  if (_impl_.settings_ != nullptr) _impl_.settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::UserSettings& ProductInstall::_internal_settings() const {
  const ::UserSettings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserSettings&>(
      ::_UserSettings_default_instance_);
}
inline const ::UserSettings& ProductInstall::settings() const {
  // @@protoc_insertion_point(field_get:ProductInstall.settings)
  return _internal_settings();
}
inline void ProductInstall::unsafe_arena_set_allocated_settings(
    ::UserSettings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = settings;
  if (settings) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProductInstall.settings)
}
inline ::UserSettings* ProductInstall::release_settings() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::UserSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserSettings* ProductInstall::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:ProductInstall.settings)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::UserSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::UserSettings* ProductInstall::_internal_mutable_settings() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserSettings>(GetArenaForAllocation());
    _impl_.settings_ = p;
  }
  return _impl_.settings_;
}
inline ::UserSettings* ProductInstall::mutable_settings() {
  ::UserSettings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:ProductInstall.settings)
  return _msg;
}
inline void ProductInstall::set_allocated_settings(::UserSettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:ProductInstall.settings)
}

// optional .CachedProductState cachedProductState = 4;
inline bool ProductInstall::_internal_has_cachedproductstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cachedproductstate_ != nullptr);
  return value;
}
inline bool ProductInstall::has_cachedproductstate() const {
  return _internal_has_cachedproductstate();
}
inline void ProductInstall::clear_cachedproductstate() {
  if (_impl_.cachedproductstate_ != nullptr) _impl_.cachedproductstate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::CachedProductState& ProductInstall::_internal_cachedproductstate() const {
  const ::CachedProductState* p = _impl_.cachedproductstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::CachedProductState&>(
      ::_CachedProductState_default_instance_);
}
inline const ::CachedProductState& ProductInstall::cachedproductstate() const {
  // @@protoc_insertion_point(field_get:ProductInstall.cachedProductState)
  return _internal_cachedproductstate();
}
inline void ProductInstall::unsafe_arena_set_allocated_cachedproductstate(
    ::CachedProductState* cachedproductstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cachedproductstate_);
  }
  _impl_.cachedproductstate_ = cachedproductstate;
  if (cachedproductstate) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProductInstall.cachedProductState)
}
inline ::CachedProductState* ProductInstall::release_cachedproductstate() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::CachedProductState* temp = _impl_.cachedproductstate_;
  _impl_.cachedproductstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CachedProductState* ProductInstall::unsafe_arena_release_cachedproductstate() {
  // @@protoc_insertion_point(field_release:ProductInstall.cachedProductState)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::CachedProductState* temp = _impl_.cachedproductstate_;
  _impl_.cachedproductstate_ = nullptr;
  return temp;
}
inline ::CachedProductState* ProductInstall::_internal_mutable_cachedproductstate() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.cachedproductstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::CachedProductState>(GetArenaForAllocation());
    _impl_.cachedproductstate_ = p;
  }
  return _impl_.cachedproductstate_;
}
inline ::CachedProductState* ProductInstall::mutable_cachedproductstate() {
  ::CachedProductState* _msg = _internal_mutable_cachedproductstate();
  // @@protoc_insertion_point(field_mutable:ProductInstall.cachedProductState)
  return _msg;
}
inline void ProductInstall::set_allocated_cachedproductstate(::CachedProductState* cachedproductstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cachedproductstate_;
  }
  if (cachedproductstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cachedproductstate);
    if (message_arena != submessage_arena) {
      cachedproductstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cachedproductstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.cachedproductstate_ = cachedproductstate;
  // @@protoc_insertion_point(field_set_allocated:ProductInstall.cachedProductState)
}

// optional .ProductOperations productOperations = 5;
inline bool ProductInstall::_internal_has_productoperations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.productoperations_ != nullptr);
  return value;
}
inline bool ProductInstall::has_productoperations() const {
  return _internal_has_productoperations();
}
inline void ProductInstall::clear_productoperations() {
  if (_impl_.productoperations_ != nullptr) _impl_.productoperations_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::ProductOperations& ProductInstall::_internal_productoperations() const {
  const ::ProductOperations* p = _impl_.productoperations_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProductOperations&>(
      ::_ProductOperations_default_instance_);
}
inline const ::ProductOperations& ProductInstall::productoperations() const {
  // @@protoc_insertion_point(field_get:ProductInstall.productOperations)
  return _internal_productoperations();
}
inline void ProductInstall::unsafe_arena_set_allocated_productoperations(
    ::ProductOperations* productoperations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.productoperations_);
  }
  _impl_.productoperations_ = productoperations;
  if (productoperations) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProductInstall.productOperations)
}
inline ::ProductOperations* ProductInstall::release_productoperations() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::ProductOperations* temp = _impl_.productoperations_;
  _impl_.productoperations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProductOperations* ProductInstall::unsafe_arena_release_productoperations() {
  // @@protoc_insertion_point(field_release:ProductInstall.productOperations)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::ProductOperations* temp = _impl_.productoperations_;
  _impl_.productoperations_ = nullptr;
  return temp;
}
inline ::ProductOperations* ProductInstall::_internal_mutable_productoperations() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.productoperations_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProductOperations>(GetArenaForAllocation());
    _impl_.productoperations_ = p;
  }
  return _impl_.productoperations_;
}
inline ::ProductOperations* ProductInstall::mutable_productoperations() {
  ::ProductOperations* _msg = _internal_mutable_productoperations();
  // @@protoc_insertion_point(field_mutable:ProductInstall.productOperations)
  return _msg;
}
inline void ProductInstall::set_allocated_productoperations(::ProductOperations* productoperations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.productoperations_;
  }
  if (productoperations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(productoperations);
    if (message_arena != submessage_arena) {
      productoperations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, productoperations, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.productoperations_ = productoperations;
  // @@protoc_insertion_point(field_set_allocated:ProductInstall.productOperations)
}

// optional string productFamily = 6;
inline bool ProductInstall::_internal_has_productfamily() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ProductInstall::has_productfamily() const {
  return _internal_has_productfamily();
}
inline void ProductInstall::clear_productfamily() {
  _impl_.productfamily_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ProductInstall::productfamily() const {
  // @@protoc_insertion_point(field_get:ProductInstall.productFamily)
  return _internal_productfamily();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductInstall::set_productfamily(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.productfamily_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProductInstall.productFamily)
}
inline std::string* ProductInstall::mutable_productfamily() {
  std::string* _s = _internal_mutable_productfamily();
  // @@protoc_insertion_point(field_mutable:ProductInstall.productFamily)
  return _s;
}
inline const std::string& ProductInstall::_internal_productfamily() const {
  return _impl_.productfamily_.Get();
}
inline void ProductInstall::_internal_set_productfamily(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.productfamily_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductInstall::_internal_mutable_productfamily() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.productfamily_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductInstall::release_productfamily() {
  // @@protoc_insertion_point(field_release:ProductInstall.productFamily)
  if (!_internal_has_productfamily()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.productfamily_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.productfamily_.IsDefault()) {
    _impl_.productfamily_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductInstall::set_allocated_productfamily(std::string* productfamily) {
  if (productfamily != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.productfamily_.SetAllocated(productfamily, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.productfamily_.IsDefault()) {
    _impl_.productfamily_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProductInstall.productFamily)
}

// optional bool Hidden = 7;
inline bool ProductInstall::_internal_has_hidden() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ProductInstall::has_hidden() const {
  return _internal_has_hidden();
}
inline void ProductInstall::clear_hidden() {
  _impl_.hidden_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool ProductInstall::_internal_hidden() const {
  return _impl_.hidden_;
}
inline bool ProductInstall::hidden() const {
  // @@protoc_insertion_point(field_get:ProductInstall.Hidden)
  return _internal_hidden();
}
inline void ProductInstall::_internal_set_hidden(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.hidden_ = value;
}
inline void ProductInstall::set_hidden(bool value) {
  _internal_set_hidden(value);
  // @@protoc_insertion_point(field_set:ProductInstall.Hidden)
}

// optional string persistentJsonStorage = 8;
inline bool ProductInstall::_internal_has_persistentjsonstorage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ProductInstall::has_persistentjsonstorage() const {
  return _internal_has_persistentjsonstorage();
}
inline void ProductInstall::clear_persistentjsonstorage() {
  _impl_.persistentjsonstorage_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ProductInstall::persistentjsonstorage() const {
  // @@protoc_insertion_point(field_get:ProductInstall.persistentJsonStorage)
  return _internal_persistentjsonstorage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductInstall::set_persistentjsonstorage(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.persistentjsonstorage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProductInstall.persistentJsonStorage)
}
inline std::string* ProductInstall::mutable_persistentjsonstorage() {
  std::string* _s = _internal_mutable_persistentjsonstorage();
  // @@protoc_insertion_point(field_mutable:ProductInstall.persistentJsonStorage)
  return _s;
}
inline const std::string& ProductInstall::_internal_persistentjsonstorage() const {
  return _impl_.persistentjsonstorage_.Get();
}
inline void ProductInstall::_internal_set_persistentjsonstorage(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.persistentjsonstorage_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductInstall::_internal_mutable_persistentjsonstorage() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.persistentjsonstorage_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductInstall::release_persistentjsonstorage() {
  // @@protoc_insertion_point(field_release:ProductInstall.persistentJsonStorage)
  if (!_internal_has_persistentjsonstorage()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.persistentjsonstorage_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.persistentjsonstorage_.IsDefault()) {
    _impl_.persistentjsonstorage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductInstall::set_allocated_persistentjsonstorage(std::string* persistentjsonstorage) {
  if (persistentjsonstorage != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.persistentjsonstorage_.SetAllocated(persistentjsonstorage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.persistentjsonstorage_.IsDefault()) {
    _impl_.persistentjsonstorage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProductInstall.persistentJsonStorage)
}

// -------------------------------------------------------------------

// ProductConfig

// optional string productCode = 1;
inline bool ProductConfig::_internal_has_productcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProductConfig::has_productcode() const {
  return _internal_has_productcode();
}
inline void ProductConfig::clear_productcode() {
  _impl_.productcode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProductConfig::productcode() const {
  // @@protoc_insertion_point(field_get:ProductConfig.productCode)
  return _internal_productcode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductConfig::set_productcode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.productcode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProductConfig.productCode)
}
inline std::string* ProductConfig::mutable_productcode() {
  std::string* _s = _internal_mutable_productcode();
  // @@protoc_insertion_point(field_mutable:ProductConfig.productCode)
  return _s;
}
inline const std::string& ProductConfig::_internal_productcode() const {
  return _impl_.productcode_.Get();
}
inline void ProductConfig::_internal_set_productcode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.productcode_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductConfig::_internal_mutable_productcode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.productcode_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductConfig::release_productcode() {
  // @@protoc_insertion_point(field_release:ProductConfig.productCode)
  if (!_internal_has_productcode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.productcode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.productcode_.IsDefault()) {
    _impl_.productcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductConfig::set_allocated_productcode(std::string* productcode) {
  if (productcode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.productcode_.SetAllocated(productcode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.productcode_.IsDefault()) {
    _impl_.productcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProductConfig.productCode)
}

// optional string metadataHash = 2;
inline bool ProductConfig::_internal_has_metadatahash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProductConfig::has_metadatahash() const {
  return _internal_has_metadatahash();
}
inline void ProductConfig::clear_metadatahash() {
  _impl_.metadatahash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProductConfig::metadatahash() const {
  // @@protoc_insertion_point(field_get:ProductConfig.metadataHash)
  return _internal_metadatahash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductConfig::set_metadatahash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.metadatahash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProductConfig.metadataHash)
}
inline std::string* ProductConfig::mutable_metadatahash() {
  std::string* _s = _internal_mutable_metadatahash();
  // @@protoc_insertion_point(field_mutable:ProductConfig.metadataHash)
  return _s;
}
inline const std::string& ProductConfig::_internal_metadatahash() const {
  return _impl_.metadatahash_.Get();
}
inline void ProductConfig::_internal_set_metadatahash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.metadatahash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductConfig::_internal_mutable_metadatahash() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.metadatahash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductConfig::release_metadatahash() {
  // @@protoc_insertion_point(field_release:ProductConfig.metadataHash)
  if (!_internal_has_metadatahash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.metadatahash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadatahash_.IsDefault()) {
    _impl_.metadatahash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductConfig::set_allocated_metadatahash(std::string* metadatahash) {
  if (metadatahash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.metadatahash_.SetAllocated(metadatahash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadatahash_.IsDefault()) {
    _impl_.metadatahash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProductConfig.metadataHash)
}

// optional string timestamp = 3;
inline bool ProductConfig::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ProductConfig::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void ProductConfig::clear_timestamp() {
  _impl_.timestamp_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ProductConfig::timestamp() const {
  // @@protoc_insertion_point(field_get:ProductConfig.timestamp)
  return _internal_timestamp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductConfig::set_timestamp(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.timestamp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProductConfig.timestamp)
}
inline std::string* ProductConfig::mutable_timestamp() {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:ProductConfig.timestamp)
  return _s;
}
inline const std::string& ProductConfig::_internal_timestamp() const {
  return _impl_.timestamp_.Get();
}
inline void ProductConfig::_internal_set_timestamp(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductConfig::_internal_mutable_timestamp() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.timestamp_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductConfig::release_timestamp() {
  // @@protoc_insertion_point(field_release:ProductConfig.timestamp)
  if (!_internal_has_timestamp()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.timestamp_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductConfig::set_allocated_timestamp(std::string* timestamp) {
  if (timestamp != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.timestamp_.SetAllocated(timestamp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProductConfig.timestamp)
}

// -------------------------------------------------------------------

// ActiveProcess

// optional string processName = 1;
inline bool ActiveProcess::_internal_has_processname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActiveProcess::has_processname() const {
  return _internal_has_processname();
}
inline void ActiveProcess::clear_processname() {
  _impl_.processname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActiveProcess::processname() const {
  // @@protoc_insertion_point(field_get:ActiveProcess.processName)
  return _internal_processname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveProcess::set_processname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.processname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ActiveProcess.processName)
}
inline std::string* ActiveProcess::mutable_processname() {
  std::string* _s = _internal_mutable_processname();
  // @@protoc_insertion_point(field_mutable:ActiveProcess.processName)
  return _s;
}
inline const std::string& ActiveProcess::_internal_processname() const {
  return _impl_.processname_.Get();
}
inline void ActiveProcess::_internal_set_processname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.processname_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveProcess::_internal_mutable_processname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.processname_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveProcess::release_processname() {
  // @@protoc_insertion_point(field_release:ActiveProcess.processName)
  if (!_internal_has_processname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.processname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processname_.IsDefault()) {
    _impl_.processname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActiveProcess::set_allocated_processname(std::string* processname) {
  if (processname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.processname_.SetAllocated(processname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processname_.IsDefault()) {
    _impl_.processname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ActiveProcess.processName)
}

// optional int32 pid = 2;
inline bool ActiveProcess::_internal_has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActiveProcess::has_pid() const {
  return _internal_has_pid();
}
inline void ActiveProcess::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ActiveProcess::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t ActiveProcess::pid() const {
  // @@protoc_insertion_point(field_get:ActiveProcess.pid)
  return _internal_pid();
}
inline void ActiveProcess::_internal_set_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}
inline void ActiveProcess::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ActiveProcess.pid)
}

// repeated string uri = 3;
inline int ActiveProcess::_internal_uri_size() const {
  return _impl_.uri_.size();
}
inline int ActiveProcess::uri_size() const {
  return _internal_uri_size();
}
inline void ActiveProcess::clear_uri() {
  _impl_.uri_.Clear();
}
inline std::string* ActiveProcess::add_uri() {
  std::string* _s = _internal_add_uri();
  // @@protoc_insertion_point(field_add_mutable:ActiveProcess.uri)
  return _s;
}
inline const std::string& ActiveProcess::_internal_uri(int index) const {
  return _impl_.uri_.Get(index);
}
inline const std::string& ActiveProcess::uri(int index) const {
  // @@protoc_insertion_point(field_get:ActiveProcess.uri)
  return _internal_uri(index);
}
inline std::string* ActiveProcess::mutable_uri(int index) {
  // @@protoc_insertion_point(field_mutable:ActiveProcess.uri)
  return _impl_.uri_.Mutable(index);
}
inline void ActiveProcess::set_uri(int index, const std::string& value) {
  _impl_.uri_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ActiveProcess.uri)
}
inline void ActiveProcess::set_uri(int index, std::string&& value) {
  _impl_.uri_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ActiveProcess.uri)
}
inline void ActiveProcess::set_uri(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.uri_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ActiveProcess.uri)
}
inline void ActiveProcess::set_uri(int index, const char* value, size_t size) {
  _impl_.uri_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ActiveProcess.uri)
}
inline std::string* ActiveProcess::_internal_add_uri() {
  return _impl_.uri_.Add();
}
inline void ActiveProcess::add_uri(const std::string& value) {
  _impl_.uri_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ActiveProcess.uri)
}
inline void ActiveProcess::add_uri(std::string&& value) {
  _impl_.uri_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ActiveProcess.uri)
}
inline void ActiveProcess::add_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.uri_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ActiveProcess.uri)
}
inline void ActiveProcess::add_uri(const char* value, size_t size) {
  _impl_.uri_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ActiveProcess.uri)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ActiveProcess::uri() const {
  // @@protoc_insertion_point(field_list:ActiveProcess.uri)
  return _impl_.uri_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ActiveProcess::mutable_uri() {
  // @@protoc_insertion_point(field_mutable_list:ActiveProcess.uri)
  return &_impl_.uri_;
}

// -------------------------------------------------------------------

// DownloadSettings

// optional int32 downloadLimit = 1 [default = -1];
inline bool DownloadSettings::_internal_has_downloadlimit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DownloadSettings::has_downloadlimit() const {
  return _internal_has_downloadlimit();
}
inline void DownloadSettings::clear_downloadlimit() {
  _impl_.downloadlimit_ = -1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t DownloadSettings::_internal_downloadlimit() const {
  return _impl_.downloadlimit_;
}
inline int32_t DownloadSettings::downloadlimit() const {
  // @@protoc_insertion_point(field_get:DownloadSettings.downloadLimit)
  return _internal_downloadlimit();
}
inline void DownloadSettings::_internal_set_downloadlimit(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.downloadlimit_ = value;
}
inline void DownloadSettings::set_downloadlimit(int32_t value) {
  _internal_set_downloadlimit(value);
  // @@protoc_insertion_point(field_set:DownloadSettings.downloadLimit)
}

// optional int32 backfillLimit = 2 [default = -1];
inline bool DownloadSettings::_internal_has_backfilllimit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DownloadSettings::has_backfilllimit() const {
  return _internal_has_backfilllimit();
}
inline void DownloadSettings::clear_backfilllimit() {
  _impl_.backfilllimit_ = -1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t DownloadSettings::_internal_backfilllimit() const {
  return _impl_.backfilllimit_;
}
inline int32_t DownloadSettings::backfilllimit() const {
  // @@protoc_insertion_point(field_get:DownloadSettings.backfillLimit)
  return _internal_backfilllimit();
}
inline void DownloadSettings::_internal_set_backfilllimit(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.backfilllimit_ = value;
}
inline void DownloadSettings::set_backfilllimit(int32_t value) {
  _internal_set_backfilllimit(value);
  // @@protoc_insertion_point(field_set:DownloadSettings.backfillLimit)
}

// -------------------------------------------------------------------

// Database

// repeated .ProductInstall productInstall = 1;
inline int Database::_internal_productinstall_size() const {
  return _impl_.productinstall_.size();
}
inline int Database::productinstall_size() const {
  return _internal_productinstall_size();
}
inline void Database::clear_productinstall() {
  _impl_.productinstall_.Clear();
}
inline ::ProductInstall* Database::mutable_productinstall(int index) {
  // @@protoc_insertion_point(field_mutable:Database.productInstall)
  return _impl_.productinstall_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductInstall >*
Database::mutable_productinstall() {
  // @@protoc_insertion_point(field_mutable_list:Database.productInstall)
  return &_impl_.productinstall_;
}
inline const ::ProductInstall& Database::_internal_productinstall(int index) const {
  return _impl_.productinstall_.Get(index);
}
inline const ::ProductInstall& Database::productinstall(int index) const {
  // @@protoc_insertion_point(field_get:Database.productInstall)
  return _internal_productinstall(index);
}
inline ::ProductInstall* Database::_internal_add_productinstall() {
  return _impl_.productinstall_.Add();
}
inline ::ProductInstall* Database::add_productinstall() {
  ::ProductInstall* _add = _internal_add_productinstall();
  // @@protoc_insertion_point(field_add:Database.productInstall)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductInstall >&
Database::productinstall() const {
  // @@protoc_insertion_point(field_list:Database.productInstall)
  return _impl_.productinstall_;
}

// repeated .InstallHandshake activeInstalls = 2;
inline int Database::_internal_activeinstalls_size() const {
  return _impl_.activeinstalls_.size();
}
inline int Database::activeinstalls_size() const {
  return _internal_activeinstalls_size();
}
inline void Database::clear_activeinstalls() {
  _impl_.activeinstalls_.Clear();
}
inline ::InstallHandshake* Database::mutable_activeinstalls(int index) {
  // @@protoc_insertion_point(field_mutable:Database.activeInstalls)
  return _impl_.activeinstalls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstallHandshake >*
Database::mutable_activeinstalls() {
  // @@protoc_insertion_point(field_mutable_list:Database.activeInstalls)
  return &_impl_.activeinstalls_;
}
inline const ::InstallHandshake& Database::_internal_activeinstalls(int index) const {
  return _impl_.activeinstalls_.Get(index);
}
inline const ::InstallHandshake& Database::activeinstalls(int index) const {
  // @@protoc_insertion_point(field_get:Database.activeInstalls)
  return _internal_activeinstalls(index);
}
inline ::InstallHandshake* Database::_internal_add_activeinstalls() {
  return _impl_.activeinstalls_.Add();
}
inline ::InstallHandshake* Database::add_activeinstalls() {
  ::InstallHandshake* _add = _internal_add_activeinstalls();
  // @@protoc_insertion_point(field_add:Database.activeInstalls)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstallHandshake >&
Database::activeinstalls() const {
  // @@protoc_insertion_point(field_list:Database.activeInstalls)
  return _impl_.activeinstalls_;
}

// repeated .ActiveProcess activeProcesses = 3;
inline int Database::_internal_activeprocesses_size() const {
  return _impl_.activeprocesses_.size();
}
inline int Database::activeprocesses_size() const {
  return _internal_activeprocesses_size();
}
inline void Database::clear_activeprocesses() {
  _impl_.activeprocesses_.Clear();
}
inline ::ActiveProcess* Database::mutable_activeprocesses(int index) {
  // @@protoc_insertion_point(field_mutable:Database.activeProcesses)
  return _impl_.activeprocesses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ActiveProcess >*
Database::mutable_activeprocesses() {
  // @@protoc_insertion_point(field_mutable_list:Database.activeProcesses)
  return &_impl_.activeprocesses_;
}
inline const ::ActiveProcess& Database::_internal_activeprocesses(int index) const {
  return _impl_.activeprocesses_.Get(index);
}
inline const ::ActiveProcess& Database::activeprocesses(int index) const {
  // @@protoc_insertion_point(field_get:Database.activeProcesses)
  return _internal_activeprocesses(index);
}
inline ::ActiveProcess* Database::_internal_add_activeprocesses() {
  return _impl_.activeprocesses_.Add();
}
inline ::ActiveProcess* Database::add_activeprocesses() {
  ::ActiveProcess* _add = _internal_add_activeprocesses();
  // @@protoc_insertion_point(field_add:Database.activeProcesses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ActiveProcess >&
Database::activeprocesses() const {
  // @@protoc_insertion_point(field_list:Database.activeProcesses)
  return _impl_.activeprocesses_;
}

// repeated .ProductConfig productConfigs = 4;
inline int Database::_internal_productconfigs_size() const {
  return _impl_.productconfigs_.size();
}
inline int Database::productconfigs_size() const {
  return _internal_productconfigs_size();
}
inline void Database::clear_productconfigs() {
  _impl_.productconfigs_.Clear();
}
inline ::ProductConfig* Database::mutable_productconfigs(int index) {
  // @@protoc_insertion_point(field_mutable:Database.productConfigs)
  return _impl_.productconfigs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductConfig >*
Database::mutable_productconfigs() {
  // @@protoc_insertion_point(field_mutable_list:Database.productConfigs)
  return &_impl_.productconfigs_;
}
inline const ::ProductConfig& Database::_internal_productconfigs(int index) const {
  return _impl_.productconfigs_.Get(index);
}
inline const ::ProductConfig& Database::productconfigs(int index) const {
  // @@protoc_insertion_point(field_get:Database.productConfigs)
  return _internal_productconfigs(index);
}
inline ::ProductConfig* Database::_internal_add_productconfigs() {
  return _impl_.productconfigs_.Add();
}
inline ::ProductConfig* Database::add_productconfigs() {
  ::ProductConfig* _add = _internal_add_productconfigs();
  // @@protoc_insertion_point(field_add:Database.productConfigs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProductConfig >&
Database::productconfigs() const {
  // @@protoc_insertion_point(field_list:Database.productConfigs)
  return _impl_.productconfigs_;
}

// optional .DownloadSettings downloadSettings = 5;
inline bool Database::_internal_has_downloadsettings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.downloadsettings_ != nullptr);
  return value;
}
inline bool Database::has_downloadsettings() const {
  return _internal_has_downloadsettings();
}
inline void Database::clear_downloadsettings() {
  if (_impl_.downloadsettings_ != nullptr) _impl_.downloadsettings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DownloadSettings& Database::_internal_downloadsettings() const {
  const ::DownloadSettings* p = _impl_.downloadsettings_;
  return p != nullptr ? *p : reinterpret_cast<const ::DownloadSettings&>(
      ::_DownloadSettings_default_instance_);
}
inline const ::DownloadSettings& Database::downloadsettings() const {
  // @@protoc_insertion_point(field_get:Database.downloadSettings)
  return _internal_downloadsettings();
}
inline void Database::unsafe_arena_set_allocated_downloadsettings(
    ::DownloadSettings* downloadsettings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.downloadsettings_);
  }
  _impl_.downloadsettings_ = downloadsettings;
  if (downloadsettings) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Database.downloadSettings)
}
inline ::DownloadSettings* Database::release_downloadsettings() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DownloadSettings* temp = _impl_.downloadsettings_;
  _impl_.downloadsettings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DownloadSettings* Database::unsafe_arena_release_downloadsettings() {
  // @@protoc_insertion_point(field_release:Database.downloadSettings)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DownloadSettings* temp = _impl_.downloadsettings_;
  _impl_.downloadsettings_ = nullptr;
  return temp;
}
inline ::DownloadSettings* Database::_internal_mutable_downloadsettings() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.downloadsettings_ == nullptr) {
    auto* p = CreateMaybeMessage<::DownloadSettings>(GetArenaForAllocation());
    _impl_.downloadsettings_ = p;
  }
  return _impl_.downloadsettings_;
}
inline ::DownloadSettings* Database::mutable_downloadsettings() {
  ::DownloadSettings* _msg = _internal_mutable_downloadsettings();
  // @@protoc_insertion_point(field_mutable:Database.downloadSettings)
  return _msg;
}
inline void Database::set_allocated_downloadsettings(::DownloadSettings* downloadsettings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.downloadsettings_;
  }
  if (downloadsettings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(downloadsettings);
    if (message_arena != submessage_arena) {
      downloadsettings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, downloadsettings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.downloadsettings_ = downloadsettings;
  // @@protoc_insertion_point(field_set_allocated:Database.downloadSettings)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::LanguageOption> : ::std::true_type {};
template <> struct is_proto_enum< ::LanguageSettingType> : ::std::true_type {};
template <> struct is_proto_enum< ::ShortcutOption> : ::std::true_type {};
template <> struct is_proto_enum< ::Operation> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ProtoDatabase_2eproto
