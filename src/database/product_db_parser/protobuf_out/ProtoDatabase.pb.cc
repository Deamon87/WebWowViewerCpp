// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoDatabase.proto

#include "ProtoDatabase.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR LanguageSetting::LanguageSetting(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.option_)*/0} {}
struct LanguageSettingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LanguageSettingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LanguageSettingDefaultTypeInternal() {}
  union {
    LanguageSetting _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LanguageSettingDefaultTypeInternal _LanguageSetting_default_instance_;
PROTOBUF_CONSTEXPR UserSettings::UserSettings(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.languages_)*/{}
  , /*decltype(_impl_.installpath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.playregion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.selectedtextlanguage_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.selectedspeechlanguage_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gfx_override_tags_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.versionbranch_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.accountcountry_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.geoipcountry_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gamesubfolder_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.desktopshortcut_)*/0
  , /*decltype(_impl_.startmenushortcut_)*/0
  , /*decltype(_impl_.languagesettings_)*/0} {}
struct UserSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserSettingsDefaultTypeInternal() {}
  union {
    UserSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserSettingsDefaultTypeInternal _UserSettings_default_instance_;
PROTOBUF_CONSTEXPR InstallHandshake::InstallHandshake(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.product_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.settings_)*/nullptr} {}
struct InstallHandshakeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InstallHandshakeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InstallHandshakeDefaultTypeInternal() {}
  union {
    InstallHandshake _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InstallHandshakeDefaultTypeInternal _InstallHandshake_default_instance_;
PROTOBUF_CONSTEXPR BuildConfig::BuildConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.region_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.buildconfig_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct BuildConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BuildConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BuildConfigDefaultTypeInternal() {}
  union {
    BuildConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BuildConfigDefaultTypeInternal _BuildConfig_default_instance_;
PROTOBUF_CONSTEXPR BaseProductState::BaseProductState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.installedbuildconfig_)*/{}
  , /*decltype(_impl_.backgrounddownloadbuildconfig_)*/{}
  , /*decltype(_impl_.completedinstallactions_)*/{}
  , /*decltype(_impl_.completedbuildkeys_)*/{}
  , /*decltype(_impl_.completedbgdlkeys_)*/{}
  , /*decltype(_impl_.activebuildkey_)*/{}
  , /*decltype(_impl_.activebgdlkey_)*/{}
  , /*decltype(_impl_.activeinstallkey_)*/{}
  , /*decltype(_impl_.activetagstring_)*/{}
  , /*decltype(_impl_.incompletebuildkey_)*/{}
  , /*decltype(_impl_.currentversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.currentversionstr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.decryptionkey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.installed_)*/false
  , /*decltype(_impl_.playable_)*/false
  , /*decltype(_impl_.updatecomplete_)*/false
  , /*decltype(_impl_.backgrounddownloadavailable_)*/false
  , /*decltype(_impl_.backgrounddownloadcomplete_)*/false} {}
struct BaseProductStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BaseProductStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BaseProductStateDefaultTypeInternal() {}
  union {
    BaseProductState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BaseProductStateDefaultTypeInternal _BaseProductState_default_instance_;
PROTOBUF_CONSTEXPR BackfillProgress::BackfillProgress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.progress_)*/0
  , /*decltype(_impl_.downloadlimit_)*/uint64_t{0u}
  , /*decltype(_impl_.backgrounddownload_)*/false
  , /*decltype(_impl_.paused_)*/false} {}
struct BackfillProgressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BackfillProgressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BackfillProgressDefaultTypeInternal() {}
  union {
    BackfillProgress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BackfillProgressDefaultTypeInternal _BackfillProgress_default_instance_;
PROTOBUF_CONSTEXPR RepairProgress::RepairProgress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.progress_)*/0} {}
struct RepairProgressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RepairProgressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RepairProgressDefaultTypeInternal() {}
  union {
    RepairProgress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RepairProgressDefaultTypeInternal _RepairProgress_default_instance_;
PROTOBUF_CONSTEXPR UpdateProgress::UpdateProgress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lastdiscsetused_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.progress_)*/0
  , /*decltype(_impl_.totaltodownload_)*/uint64_t{0u}
  , /*decltype(_impl_.downloadremaining_)*/uint64_t{0u}
  , /*decltype(_impl_.discignored_)*/false} {}
struct UpdateProgressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateProgressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateProgressDefaultTypeInternal() {}
  union {
    UpdateProgress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateProgressDefaultTypeInternal _UpdateProgress_default_instance_;
PROTOBUF_CONSTEXPR CachedProductState::CachedProductState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.baseproductstate_)*/nullptr
  , /*decltype(_impl_.backfillprogress_)*/nullptr
  , /*decltype(_impl_.repairprogress_)*/nullptr
  , /*decltype(_impl_.updateprogress_)*/nullptr} {}
struct CachedProductStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CachedProductStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CachedProductStateDefaultTypeInternal() {}
  union {
    CachedProductState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CachedProductStateDefaultTypeInternal _CachedProductState_default_instance_;
PROTOBUF_CONSTEXPR ProductOperations::ProductOperations(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.priority_)*/uint64_t{0u}
  , /*decltype(_impl_.activeoperation_)*/-1} {}
struct ProductOperationsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProductOperationsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProductOperationsDefaultTypeInternal() {}
  union {
    ProductOperations _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProductOperationsDefaultTypeInternal _ProductOperations_default_instance_;
PROTOBUF_CONSTEXPR ProductInstall::ProductInstall(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.uid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.productcode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.productfamily_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.persistentjsonstorage_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.settings_)*/nullptr
  , /*decltype(_impl_.cachedproductstate_)*/nullptr
  , /*decltype(_impl_.productoperations_)*/nullptr
  , /*decltype(_impl_.hidden_)*/false} {}
struct ProductInstallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProductInstallDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProductInstallDefaultTypeInternal() {}
  union {
    ProductInstall _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProductInstallDefaultTypeInternal _ProductInstall_default_instance_;
PROTOBUF_CONSTEXPR ProductConfig::ProductConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.productcode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.metadatahash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ProductConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProductConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProductConfigDefaultTypeInternal() {}
  union {
    ProductConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProductConfigDefaultTypeInternal _ProductConfig_default_instance_;
PROTOBUF_CONSTEXPR ActiveProcess::ActiveProcess(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.uri_)*/{}
  , /*decltype(_impl_.processname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pid_)*/0} {}
struct ActiveProcessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActiveProcessDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActiveProcessDefaultTypeInternal() {}
  union {
    ActiveProcess _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActiveProcessDefaultTypeInternal _ActiveProcess_default_instance_;
PROTOBUF_CONSTEXPR DownloadSettings::DownloadSettings(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.downloadlimit_)*/-1
  , /*decltype(_impl_.backfilllimit_)*/-1} {}
struct DownloadSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownloadSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownloadSettingsDefaultTypeInternal() {}
  union {
    DownloadSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadSettingsDefaultTypeInternal _DownloadSettings_default_instance_;
PROTOBUF_CONSTEXPR Database::Database(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.productinstall_)*/{}
  , /*decltype(_impl_.activeinstalls_)*/{}
  , /*decltype(_impl_.activeprocesses_)*/{}
  , /*decltype(_impl_.productconfigs_)*/{}
  , /*decltype(_impl_.downloadsettings_)*/nullptr} {}
struct DatabaseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DatabaseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DatabaseDefaultTypeInternal() {}
  union {
    Database _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DatabaseDefaultTypeInternal _Database_default_instance_;
bool LanguageOption_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LanguageOption_strings[4] = {};

static const char LanguageOption_names[] =
  "LANGOPTION_NONE"
  "LANGOPTION_SPEECH"
  "LANGOPTION_TEXT"
  "LANGOPTION_TEXT_AND_SPEECH";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LanguageOption_entries[] = {
  { {LanguageOption_names + 0, 15}, 0 },
  { {LanguageOption_names + 15, 17}, 2 },
  { {LanguageOption_names + 32, 15}, 1 },
  { {LanguageOption_names + 47, 26}, 3 },
};

static const int LanguageOption_entries_by_number[] = {
  0, // 0 -> LANGOPTION_NONE
  2, // 1 -> LANGOPTION_TEXT
  1, // 2 -> LANGOPTION_SPEECH
  3, // 3 -> LANGOPTION_TEXT_AND_SPEECH
};

const std::string& LanguageOption_Name(
    LanguageOption value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LanguageOption_entries,
          LanguageOption_entries_by_number,
          4, LanguageOption_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LanguageOption_entries,
      LanguageOption_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LanguageOption_strings[idx].get();
}
bool LanguageOption_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LanguageOption* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LanguageOption_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<LanguageOption>(int_value);
  }
  return success;
}
bool LanguageSettingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LanguageSettingType_strings[4] = {};

static const char LanguageSettingType_names[] =
  "LANGSETTING_ADVANCED"
  "LANGSETTING_NONE"
  "LANGSETTING_SIMPLE"
  "LANGSETTING_SINGLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LanguageSettingType_entries[] = {
  { {LanguageSettingType_names + 0, 20}, 3 },
  { {LanguageSettingType_names + 20, 16}, 0 },
  { {LanguageSettingType_names + 36, 18}, 2 },
  { {LanguageSettingType_names + 54, 18}, 1 },
};

static const int LanguageSettingType_entries_by_number[] = {
  1, // 0 -> LANGSETTING_NONE
  3, // 1 -> LANGSETTING_SINGLE
  2, // 2 -> LANGSETTING_SIMPLE
  0, // 3 -> LANGSETTING_ADVANCED
};

const std::string& LanguageSettingType_Name(
    LanguageSettingType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LanguageSettingType_entries,
          LanguageSettingType_entries_by_number,
          4, LanguageSettingType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LanguageSettingType_entries,
      LanguageSettingType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LanguageSettingType_strings[idx].get();
}
bool LanguageSettingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LanguageSettingType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LanguageSettingType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<LanguageSettingType>(int_value);
  }
  return success;
}
bool ShortcutOption_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ShortcutOption_strings[3] = {};

static const char ShortcutOption_names[] =
  "SHORTCUT_ALL_USERS"
  "SHORTCUT_NONE"
  "SHORTCUT_USER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ShortcutOption_entries[] = {
  { {ShortcutOption_names + 0, 18}, 2 },
  { {ShortcutOption_names + 18, 13}, 0 },
  { {ShortcutOption_names + 31, 13}, 1 },
};

static const int ShortcutOption_entries_by_number[] = {
  1, // 0 -> SHORTCUT_NONE
  2, // 1 -> SHORTCUT_USER
  0, // 2 -> SHORTCUT_ALL_USERS
};

const std::string& ShortcutOption_Name(
    ShortcutOption value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ShortcutOption_entries,
          ShortcutOption_entries_by_number,
          3, ShortcutOption_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ShortcutOption_entries,
      ShortcutOption_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ShortcutOption_strings[idx].get();
}
bool ShortcutOption_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShortcutOption* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ShortcutOption_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ShortcutOption>(int_value);
  }
  return success;
}
bool Operation_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Operation_strings[4] = {};

static const char Operation_names[] =
  "OP_BACKFILL"
  "OP_NONE"
  "OP_REPAIR"
  "OP_UPDATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Operation_entries[] = {
  { {Operation_names + 0, 11}, 1 },
  { {Operation_names + 11, 7}, -1 },
  { {Operation_names + 18, 9}, 2 },
  { {Operation_names + 27, 9}, 0 },
};

static const int Operation_entries_by_number[] = {
  1, // -1 -> OP_NONE
  3, // 0 -> OP_UPDATE
  0, // 1 -> OP_BACKFILL
  2, // 2 -> OP_REPAIR
};

const std::string& Operation_Name(
    Operation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Operation_entries,
          Operation_entries_by_number,
          4, Operation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Operation_entries,
      Operation_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Operation_strings[idx].get();
}
bool Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Operation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Operation_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<Operation>(int_value);
  }
  return success;
}

// ===================================================================

class LanguageSetting::_Internal {
 public:
  using HasBits = decltype(std::declval<LanguageSetting>()._impl_._has_bits_);
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_option(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LanguageSetting::LanguageSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LanguageSetting)
}
LanguageSetting::LanguageSetting(const LanguageSetting& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LanguageSetting* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.language_){}
    , decltype(_impl_.option_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.option_ = from._impl_.option_;
  // @@protoc_insertion_point(copy_constructor:LanguageSetting)
}

inline void LanguageSetting::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.language_){}
    , decltype(_impl_.option_){0}
  };
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LanguageSetting::~LanguageSetting() {
  // @@protoc_insertion_point(destructor:LanguageSetting)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LanguageSetting::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.language_.Destroy();
}

void LanguageSetting::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LanguageSetting::Clear() {
// @@protoc_insertion_point(message_clear_start:LanguageSetting)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.language_.ClearNonDefaultToEmpty();
  }
  _impl_.option_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LanguageSetting::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string language = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .LanguageOption option = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::LanguageOption_IsValid(val))) {
            _internal_set_option(static_cast<::LanguageOption>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LanguageSetting::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LanguageSetting)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string language = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_language(), target);
  }

  // optional .LanguageOption option = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_option(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LanguageSetting)
  return target;
}

size_t LanguageSetting::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LanguageSetting)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string language = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
    }

    // optional .LanguageOption option = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_option());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LanguageSetting::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LanguageSetting*>(
      &from));
}

void LanguageSetting::MergeFrom(const LanguageSetting& from) {
  LanguageSetting* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:LanguageSetting)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.option_ = from._impl_.option_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LanguageSetting::CopyFrom(const LanguageSetting& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LanguageSetting)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LanguageSetting::IsInitialized() const {
  return true;
}

void LanguageSetting::InternalSwap(LanguageSetting* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  swap(_impl_.option_, other->_impl_.option_);
}

std::string LanguageSetting::GetTypeName() const {
  return "LanguageSetting";
}


// ===================================================================

class UserSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<UserSettings>()._impl_._has_bits_);
  static void set_has_installpath(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playregion(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_desktopshortcut(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_startmenushortcut(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_languagesettings(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_selectedtextlanguage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_selectedspeechlanguage(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gfx_override_tags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_versionbranch(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_accountcountry(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_geoipcountry(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_gamesubfolder(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

UserSettings::UserSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UserSettings)
}
UserSettings::UserSettings(const UserSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserSettings* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.languages_){from._impl_.languages_}
    , decltype(_impl_.installpath_){}
    , decltype(_impl_.playregion_){}
    , decltype(_impl_.selectedtextlanguage_){}
    , decltype(_impl_.selectedspeechlanguage_){}
    , decltype(_impl_.gfx_override_tags_){}
    , decltype(_impl_.versionbranch_){}
    , decltype(_impl_.accountcountry_){}
    , decltype(_impl_.geoipcountry_){}
    , decltype(_impl_.gamesubfolder_){}
    , decltype(_impl_.desktopshortcut_){}
    , decltype(_impl_.startmenushortcut_){}
    , decltype(_impl_.languagesettings_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.installpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.installpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_installpath()) {
    _this->_impl_.installpath_.Set(from._internal_installpath(), 
      _this->GetArenaForAllocation());
  }
  _impl_.playregion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.playregion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_playregion()) {
    _this->_impl_.playregion_.Set(from._internal_playregion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.selectedtextlanguage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.selectedtextlanguage_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_selectedtextlanguage()) {
    _this->_impl_.selectedtextlanguage_.Set(from._internal_selectedtextlanguage(), 
      _this->GetArenaForAllocation());
  }
  _impl_.selectedspeechlanguage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.selectedspeechlanguage_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_selectedspeechlanguage()) {
    _this->_impl_.selectedspeechlanguage_.Set(from._internal_selectedspeechlanguage(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gfx_override_tags_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gfx_override_tags_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gfx_override_tags()) {
    _this->_impl_.gfx_override_tags_.Set(from._internal_gfx_override_tags(), 
      _this->GetArenaForAllocation());
  }
  _impl_.versionbranch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.versionbranch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_versionbranch()) {
    _this->_impl_.versionbranch_.Set(from._internal_versionbranch(), 
      _this->GetArenaForAllocation());
  }
  _impl_.accountcountry_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accountcountry_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_accountcountry()) {
    _this->_impl_.accountcountry_.Set(from._internal_accountcountry(), 
      _this->GetArenaForAllocation());
  }
  _impl_.geoipcountry_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.geoipcountry_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_geoipcountry()) {
    _this->_impl_.geoipcountry_.Set(from._internal_geoipcountry(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gamesubfolder_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gamesubfolder_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gamesubfolder()) {
    _this->_impl_.gamesubfolder_.Set(from._internal_gamesubfolder(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.desktopshortcut_, &from._impl_.desktopshortcut_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.languagesettings_) -
    reinterpret_cast<char*>(&_impl_.desktopshortcut_)) + sizeof(_impl_.languagesettings_));
  // @@protoc_insertion_point(copy_constructor:UserSettings)
}

inline void UserSettings::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.languages_){arena}
    , decltype(_impl_.installpath_){}
    , decltype(_impl_.playregion_){}
    , decltype(_impl_.selectedtextlanguage_){}
    , decltype(_impl_.selectedspeechlanguage_){}
    , decltype(_impl_.gfx_override_tags_){}
    , decltype(_impl_.versionbranch_){}
    , decltype(_impl_.accountcountry_){}
    , decltype(_impl_.geoipcountry_){}
    , decltype(_impl_.gamesubfolder_){}
    , decltype(_impl_.desktopshortcut_){0}
    , decltype(_impl_.startmenushortcut_){0}
    , decltype(_impl_.languagesettings_){0}
  };
  _impl_.installpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.installpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.playregion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.playregion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.selectedtextlanguage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.selectedtextlanguage_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.selectedspeechlanguage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.selectedspeechlanguage_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gfx_override_tags_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gfx_override_tags_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.versionbranch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.versionbranch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.accountcountry_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accountcountry_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.geoipcountry_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.geoipcountry_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gamesubfolder_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gamesubfolder_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserSettings::~UserSettings() {
  // @@protoc_insertion_point(destructor:UserSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.languages_.~RepeatedPtrField();
  _impl_.installpath_.Destroy();
  _impl_.playregion_.Destroy();
  _impl_.selectedtextlanguage_.Destroy();
  _impl_.selectedspeechlanguage_.Destroy();
  _impl_.gfx_override_tags_.Destroy();
  _impl_.versionbranch_.Destroy();
  _impl_.accountcountry_.Destroy();
  _impl_.geoipcountry_.Destroy();
  _impl_.gamesubfolder_.Destroy();
}

void UserSettings::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:UserSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.languages_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.installpath_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.playregion_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.selectedtextlanguage_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.selectedspeechlanguage_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.gfx_override_tags_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.versionbranch_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.accountcountry_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.geoipcountry_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    _impl_.gamesubfolder_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000e00u) {
    ::memset(&_impl_.desktopshortcut_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.languagesettings_) -
        reinterpret_cast<char*>(&_impl_.desktopshortcut_)) + sizeof(_impl_.languagesettings_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string installPath = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_installpath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string playRegion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_playregion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ShortcutOption desktopShortcut = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ShortcutOption_IsValid(val))) {
            _internal_set_desktopshortcut(static_cast<::ShortcutOption>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ShortcutOption startmenuShortcut = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ShortcutOption_IsValid(val))) {
            _internal_set_startmenushortcut(static_cast<::ShortcutOption>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .LanguageSettingType languageSettings = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::LanguageSettingType_IsValid(val))) {
            _internal_set_languagesettings(static_cast<::LanguageSettingType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string selectedTextLanguage = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_selectedtextlanguage();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string selectedSpeechLanguage = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_selectedspeechlanguage();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .LanguageSetting languages = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_languages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string gfx_override_tags = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_gfx_override_tags();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string versionbranch = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_versionbranch();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string accountCountry = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_accountcountry();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string geoIpCountry = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_geoipcountry();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gameSubfolder = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_gamesubfolder();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UserSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string installPath = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_installpath(), target);
  }

  // optional string playRegion = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_playregion(), target);
  }

  // optional .ShortcutOption desktopShortcut = 3;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_desktopshortcut(), target);
  }

  // optional .ShortcutOption startmenuShortcut = 4;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_startmenushortcut(), target);
  }

  // optional .LanguageSettingType languageSettings = 5;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_languagesettings(), target);
  }

  // optional string selectedTextLanguage = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_selectedtextlanguage(), target);
  }

  // optional string selectedSpeechLanguage = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_selectedspeechlanguage(), target);
  }

  // repeated .LanguageSetting languages = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_languages_size()); i < n; i++) {
    const auto& repfield = this->_internal_languages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string gfx_override_tags = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_gfx_override_tags(), target);
  }

  // optional string versionbranch = 10;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_versionbranch(), target);
  }

  // optional string accountCountry = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_accountcountry(), target);
  }

  // optional string geoIpCountry = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_geoipcountry(), target);
  }

  // optional string gameSubfolder = 13;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_gamesubfolder(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UserSettings)
  return target;
}

size_t UserSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UserSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .LanguageSetting languages = 8;
  total_size += 1UL * this->_internal_languages_size();
  for (const auto& msg : this->_impl_.languages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string installPath = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_installpath());
    }

    // optional string playRegion = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_playregion());
    }

    // optional string selectedTextLanguage = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_selectedtextlanguage());
    }

    // optional string selectedSpeechLanguage = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_selectedspeechlanguage());
    }

    // optional string gfx_override_tags = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gfx_override_tags());
    }

    // optional string versionbranch = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_versionbranch());
    }

    // optional string accountCountry = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_accountcountry());
    }

    // optional string geoIpCountry = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_geoipcountry());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional string gameSubfolder = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gamesubfolder());
    }

    // optional .ShortcutOption desktopShortcut = 3;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_desktopshortcut());
    }

    // optional .ShortcutOption startmenuShortcut = 4;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_startmenushortcut());
    }

    // optional .LanguageSettingType languageSettings = 5;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_languagesettings());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserSettings*>(
      &from));
}

void UserSettings::MergeFrom(const UserSettings& from) {
  UserSettings* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:UserSettings)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.languages_.MergeFrom(from._impl_.languages_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_installpath(from._internal_installpath());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_playregion(from._internal_playregion());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_selectedtextlanguage(from._internal_selectedtextlanguage());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_selectedspeechlanguage(from._internal_selectedspeechlanguage());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_gfx_override_tags(from._internal_gfx_override_tags());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_versionbranch(from._internal_versionbranch());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_accountcountry(from._internal_accountcountry());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_geoipcountry(from._internal_geoipcountry());
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_gamesubfolder(from._internal_gamesubfolder());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.desktopshortcut_ = from._impl_.desktopshortcut_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.startmenushortcut_ = from._impl_.startmenushortcut_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.languagesettings_ = from._impl_.languagesettings_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserSettings::CopyFrom(const UserSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UserSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserSettings::IsInitialized() const {
  return true;
}

void UserSettings::InternalSwap(UserSettings* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.languages_.InternalSwap(&other->_impl_.languages_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.installpath_, lhs_arena,
      &other->_impl_.installpath_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.playregion_, lhs_arena,
      &other->_impl_.playregion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.selectedtextlanguage_, lhs_arena,
      &other->_impl_.selectedtextlanguage_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.selectedspeechlanguage_, lhs_arena,
      &other->_impl_.selectedspeechlanguage_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gfx_override_tags_, lhs_arena,
      &other->_impl_.gfx_override_tags_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.versionbranch_, lhs_arena,
      &other->_impl_.versionbranch_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.accountcountry_, lhs_arena,
      &other->_impl_.accountcountry_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.geoipcountry_, lhs_arena,
      &other->_impl_.geoipcountry_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gamesubfolder_, lhs_arena,
      &other->_impl_.gamesubfolder_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserSettings, _impl_.languagesettings_)
      + sizeof(UserSettings::_impl_.languagesettings_)
      - PROTOBUF_FIELD_OFFSET(UserSettings, _impl_.desktopshortcut_)>(
          reinterpret_cast<char*>(&_impl_.desktopshortcut_),
          reinterpret_cast<char*>(&other->_impl_.desktopshortcut_));
}

std::string UserSettings::GetTypeName() const {
  return "UserSettings";
}


// ===================================================================

class InstallHandshake::_Internal {
 public:
  using HasBits = decltype(std::declval<InstallHandshake>()._impl_._has_bits_);
  static void set_has_product(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::UserSettings& settings(const InstallHandshake* msg);
  static void set_has_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::UserSettings&
InstallHandshake::_Internal::settings(const InstallHandshake* msg) {
  return *msg->_impl_.settings_;
}
InstallHandshake::InstallHandshake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:InstallHandshake)
}
InstallHandshake::InstallHandshake(const InstallHandshake& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  InstallHandshake* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.product_){}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.settings_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.product_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_product()) {
    _this->_impl_.product_.Set(from._internal_product(), 
      _this->GetArenaForAllocation());
  }
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_uid()) {
    _this->_impl_.uid_.Set(from._internal_uid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_settings()) {
    _this->_impl_.settings_ = new ::UserSettings(*from._impl_.settings_);
  }
  // @@protoc_insertion_point(copy_constructor:InstallHandshake)
}

inline void InstallHandshake::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.product_){}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.settings_){nullptr}
  };
  _impl_.product_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InstallHandshake::~InstallHandshake() {
  // @@protoc_insertion_point(destructor:InstallHandshake)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InstallHandshake::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.product_.Destroy();
  _impl_.uid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.settings_;
}

void InstallHandshake::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InstallHandshake::Clear() {
// @@protoc_insertion_point(message_clear_start:InstallHandshake)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.product_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.uid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.settings_ != nullptr);
      _impl_.settings_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InstallHandshake::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string product = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_product();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string uid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_uid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .UserSettings settings = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InstallHandshake::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:InstallHandshake)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string product = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_product(), target);
  }

  // optional string uid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_uid(), target);
  }

  // optional .UserSettings settings = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::settings(this),
        _Internal::settings(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:InstallHandshake)
  return target;
}

size_t InstallHandshake::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:InstallHandshake)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string product = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_product());
    }

    // optional string uid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_uid());
    }

    // optional .UserSettings settings = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.settings_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InstallHandshake::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InstallHandshake*>(
      &from));
}

void InstallHandshake::MergeFrom(const InstallHandshake& from) {
  InstallHandshake* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:InstallHandshake)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_product(from._internal_product());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_uid(from._internal_uid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_settings()->::UserSettings::MergeFrom(
          from._internal_settings());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InstallHandshake::CopyFrom(const InstallHandshake& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:InstallHandshake)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstallHandshake::IsInitialized() const {
  return true;
}

void InstallHandshake::InternalSwap(InstallHandshake* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.product_, lhs_arena,
      &other->_impl_.product_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uid_, lhs_arena,
      &other->_impl_.uid_, rhs_arena
  );
  swap(_impl_.settings_, other->_impl_.settings_);
}

std::string InstallHandshake::GetTypeName() const {
  return "InstallHandshake";
}


// ===================================================================

class BuildConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<BuildConfig>()._impl_._has_bits_);
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_buildconfig(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BuildConfig::BuildConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:BuildConfig)
}
BuildConfig::BuildConfig(const BuildConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BuildConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.region_){}
    , decltype(_impl_.buildconfig_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.region_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_region()) {
    _this->_impl_.region_.Set(from._internal_region(), 
      _this->GetArenaForAllocation());
  }
  _impl_.buildconfig_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.buildconfig_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_buildconfig()) {
    _this->_impl_.buildconfig_.Set(from._internal_buildconfig(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:BuildConfig)
}

inline void BuildConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.region_){}
    , decltype(_impl_.buildconfig_){}
  };
  _impl_.region_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.buildconfig_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.buildconfig_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BuildConfig::~BuildConfig() {
  // @@protoc_insertion_point(destructor:BuildConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BuildConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.region_.Destroy();
  _impl_.buildconfig_.Destroy();
}

void BuildConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BuildConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:BuildConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.region_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.buildconfig_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BuildConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string region = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_region();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string buildConfig = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_buildconfig();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BuildConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:BuildConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string region = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_region(), target);
  }

  // optional string buildConfig = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_buildconfig(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BuildConfig)
  return target;
}

size_t BuildConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:BuildConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string region = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_region());
    }

    // optional string buildConfig = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_buildconfig());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BuildConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BuildConfig*>(
      &from));
}

void BuildConfig::MergeFrom(const BuildConfig& from) {
  BuildConfig* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:BuildConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_region(from._internal_region());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_buildconfig(from._internal_buildconfig());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BuildConfig::CopyFrom(const BuildConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BuildConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuildConfig::IsInitialized() const {
  return true;
}

void BuildConfig::InternalSwap(BuildConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.region_, lhs_arena,
      &other->_impl_.region_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.buildconfig_, lhs_arena,
      &other->_impl_.buildconfig_, rhs_arena
  );
}

std::string BuildConfig::GetTypeName() const {
  return "BuildConfig";
}


// ===================================================================

class BaseProductState::_Internal {
 public:
  using HasBits = decltype(std::declval<BaseProductState>()._impl_._has_bits_);
  static void set_has_installed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_playable(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_updatecomplete(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_backgrounddownloadavailable(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_backgrounddownloadcomplete(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_currentversion(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_currentversionstr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_decryptionkey(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

BaseProductState::BaseProductState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:BaseProductState)
}
BaseProductState::BaseProductState(const BaseProductState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BaseProductState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.installedbuildconfig_){from._impl_.installedbuildconfig_}
    , decltype(_impl_.backgrounddownloadbuildconfig_){from._impl_.backgrounddownloadbuildconfig_}
    , decltype(_impl_.completedinstallactions_){from._impl_.completedinstallactions_}
    , decltype(_impl_.completedbuildkeys_){from._impl_.completedbuildkeys_}
    , decltype(_impl_.completedbgdlkeys_){from._impl_.completedbgdlkeys_}
    , decltype(_impl_.activebuildkey_){from._impl_.activebuildkey_}
    , decltype(_impl_.activebgdlkey_){from._impl_.activebgdlkey_}
    , decltype(_impl_.activeinstallkey_){from._impl_.activeinstallkey_}
    , decltype(_impl_.activetagstring_){from._impl_.activetagstring_}
    , decltype(_impl_.incompletebuildkey_){from._impl_.incompletebuildkey_}
    , decltype(_impl_.currentversion_){}
    , decltype(_impl_.currentversionstr_){}
    , decltype(_impl_.decryptionkey_){}
    , decltype(_impl_.installed_){}
    , decltype(_impl_.playable_){}
    , decltype(_impl_.updatecomplete_){}
    , decltype(_impl_.backgrounddownloadavailable_){}
    , decltype(_impl_.backgrounddownloadcomplete_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.currentversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currentversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_currentversion()) {
    _this->_impl_.currentversion_.Set(from._internal_currentversion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.currentversionstr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currentversionstr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_currentversionstr()) {
    _this->_impl_.currentversionstr_.Set(from._internal_currentversionstr(), 
      _this->GetArenaForAllocation());
  }
  _impl_.decryptionkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.decryptionkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_decryptionkey()) {
    _this->_impl_.decryptionkey_.Set(from._internal_decryptionkey(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.installed_, &from._impl_.installed_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.backgrounddownloadcomplete_) -
    reinterpret_cast<char*>(&_impl_.installed_)) + sizeof(_impl_.backgrounddownloadcomplete_));
  // @@protoc_insertion_point(copy_constructor:BaseProductState)
}

inline void BaseProductState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.installedbuildconfig_){arena}
    , decltype(_impl_.backgrounddownloadbuildconfig_){arena}
    , decltype(_impl_.completedinstallactions_){arena}
    , decltype(_impl_.completedbuildkeys_){arena}
    , decltype(_impl_.completedbgdlkeys_){arena}
    , decltype(_impl_.activebuildkey_){arena}
    , decltype(_impl_.activebgdlkey_){arena}
    , decltype(_impl_.activeinstallkey_){arena}
    , decltype(_impl_.activetagstring_){arena}
    , decltype(_impl_.incompletebuildkey_){arena}
    , decltype(_impl_.currentversion_){}
    , decltype(_impl_.currentversionstr_){}
    , decltype(_impl_.decryptionkey_){}
    , decltype(_impl_.installed_){false}
    , decltype(_impl_.playable_){false}
    , decltype(_impl_.updatecomplete_){false}
    , decltype(_impl_.backgrounddownloadavailable_){false}
    , decltype(_impl_.backgrounddownloadcomplete_){false}
  };
  _impl_.currentversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currentversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.currentversionstr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currentversionstr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.decryptionkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.decryptionkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BaseProductState::~BaseProductState() {
  // @@protoc_insertion_point(destructor:BaseProductState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BaseProductState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.installedbuildconfig_.~RepeatedPtrField();
  _impl_.backgrounddownloadbuildconfig_.~RepeatedPtrField();
  _impl_.completedinstallactions_.~RepeatedPtrField();
  _impl_.completedbuildkeys_.~RepeatedPtrField();
  _impl_.completedbgdlkeys_.~RepeatedPtrField();
  _impl_.activebuildkey_.~RepeatedPtrField();
  _impl_.activebgdlkey_.~RepeatedPtrField();
  _impl_.activeinstallkey_.~RepeatedPtrField();
  _impl_.activetagstring_.~RepeatedPtrField();
  _impl_.incompletebuildkey_.~RepeatedPtrField();
  _impl_.currentversion_.Destroy();
  _impl_.currentversionstr_.Destroy();
  _impl_.decryptionkey_.Destroy();
}

void BaseProductState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BaseProductState::Clear() {
// @@protoc_insertion_point(message_clear_start:BaseProductState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.installedbuildconfig_.Clear();
  _impl_.backgrounddownloadbuildconfig_.Clear();
  _impl_.completedinstallactions_.Clear();
  _impl_.completedbuildkeys_.Clear();
  _impl_.completedbgdlkeys_.Clear();
  _impl_.activebuildkey_.Clear();
  _impl_.activebgdlkey_.Clear();
  _impl_.activeinstallkey_.Clear();
  _impl_.activetagstring_.Clear();
  _impl_.incompletebuildkey_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.currentversion_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.currentversionstr_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.decryptionkey_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.installed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.backgrounddownloadcomplete_) -
        reinterpret_cast<char*>(&_impl_.installed_)) + sizeof(_impl_.backgrounddownloadcomplete_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BaseProductState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool installed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_installed(&has_bits);
          _impl_.installed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool playable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playable(&has_bits);
          _impl_.playable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool updateComplete = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_updatecomplete(&has_bits);
          _impl_.updatecomplete_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool backgroundDownloadAvailable = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_backgrounddownloadavailable(&has_bits);
          _impl_.backgrounddownloadavailable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool backgroundDownloadComplete = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_backgrounddownloadcomplete(&has_bits);
          _impl_.backgrounddownloadcomplete_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string currentVersion = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_currentversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string currentVersionStr = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_currentversionstr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .BuildConfig installedBuildConfig = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_installedbuildconfig(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .BuildConfig backgroundDownloadBuildConfig = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_backgrounddownloadbuildconfig(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string decryptionKey = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_decryptionkey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string completedInstallActions = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_completedinstallactions();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string completedBuildKeys = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_completedbuildkeys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string completedBgdlKeys = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_completedbgdlkeys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string activeBuildKey = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_activebuildkey();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string activeBgdlKey = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_activebgdlkey();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string activeInstallKey = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_activeinstallkey();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string activeTagString = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_activetagstring();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string incompleteBuildKey = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_incompletebuildkey();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BaseProductState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:BaseProductState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool installed = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_installed(), target);
  }

  // optional bool playable = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_playable(), target);
  }

  // optional bool updateComplete = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_updatecomplete(), target);
  }

  // optional bool backgroundDownloadAvailable = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_backgrounddownloadavailable(), target);
  }

  // optional bool backgroundDownloadComplete = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_backgrounddownloadcomplete(), target);
  }

  // optional string currentVersion = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_currentversion(), target);
  }

  // optional string currentVersionStr = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_currentversionstr(), target);
  }

  // repeated .BuildConfig installedBuildConfig = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_installedbuildconfig_size()); i < n; i++) {
    const auto& repfield = this->_internal_installedbuildconfig(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .BuildConfig backgroundDownloadBuildConfig = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_backgrounddownloadbuildconfig_size()); i < n; i++) {
    const auto& repfield = this->_internal_backgrounddownloadbuildconfig(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string decryptionKey = 10;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_decryptionkey(), target);
  }

  // repeated string completedInstallActions = 11;
  for (int i = 0, n = this->_internal_completedinstallactions_size(); i < n; i++) {
    const auto& s = this->_internal_completedinstallactions(i);
    target = stream->WriteString(11, s, target);
  }

  // repeated string completedBuildKeys = 12;
  for (int i = 0, n = this->_internal_completedbuildkeys_size(); i < n; i++) {
    const auto& s = this->_internal_completedbuildkeys(i);
    target = stream->WriteString(12, s, target);
  }

  // repeated string completedBgdlKeys = 13;
  for (int i = 0, n = this->_internal_completedbgdlkeys_size(); i < n; i++) {
    const auto& s = this->_internal_completedbgdlkeys(i);
    target = stream->WriteString(13, s, target);
  }

  // repeated string activeBuildKey = 14;
  for (int i = 0, n = this->_internal_activebuildkey_size(); i < n; i++) {
    const auto& s = this->_internal_activebuildkey(i);
    target = stream->WriteString(14, s, target);
  }

  // repeated string activeBgdlKey = 15;
  for (int i = 0, n = this->_internal_activebgdlkey_size(); i < n; i++) {
    const auto& s = this->_internal_activebgdlkey(i);
    target = stream->WriteString(15, s, target);
  }

  // repeated string activeInstallKey = 16;
  for (int i = 0, n = this->_internal_activeinstallkey_size(); i < n; i++) {
    const auto& s = this->_internal_activeinstallkey(i);
    target = stream->WriteString(16, s, target);
  }

  // repeated string activeTagString = 17;
  for (int i = 0, n = this->_internal_activetagstring_size(); i < n; i++) {
    const auto& s = this->_internal_activetagstring(i);
    target = stream->WriteString(17, s, target);
  }

  // repeated string incompleteBuildKey = 18;
  for (int i = 0, n = this->_internal_incompletebuildkey_size(); i < n; i++) {
    const auto& s = this->_internal_incompletebuildkey(i);
    target = stream->WriteString(18, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BaseProductState)
  return target;
}

size_t BaseProductState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:BaseProductState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .BuildConfig installedBuildConfig = 8;
  total_size += 1UL * this->_internal_installedbuildconfig_size();
  for (const auto& msg : this->_impl_.installedbuildconfig_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .BuildConfig backgroundDownloadBuildConfig = 9;
  total_size += 1UL * this->_internal_backgrounddownloadbuildconfig_size();
  for (const auto& msg : this->_impl_.backgrounddownloadbuildconfig_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string completedInstallActions = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.completedinstallactions_.size());
  for (int i = 0, n = _impl_.completedinstallactions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.completedinstallactions_.Get(i));
  }

  // repeated string completedBuildKeys = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.completedbuildkeys_.size());
  for (int i = 0, n = _impl_.completedbuildkeys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.completedbuildkeys_.Get(i));
  }

  // repeated string completedBgdlKeys = 13;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.completedbgdlkeys_.size());
  for (int i = 0, n = _impl_.completedbgdlkeys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.completedbgdlkeys_.Get(i));
  }

  // repeated string activeBuildKey = 14;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.activebuildkey_.size());
  for (int i = 0, n = _impl_.activebuildkey_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.activebuildkey_.Get(i));
  }

  // repeated string activeBgdlKey = 15;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.activebgdlkey_.size());
  for (int i = 0, n = _impl_.activebgdlkey_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.activebgdlkey_.Get(i));
  }

  // repeated string activeInstallKey = 16;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.activeinstallkey_.size());
  for (int i = 0, n = _impl_.activeinstallkey_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.activeinstallkey_.Get(i));
  }

  // repeated string activeTagString = 17;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.activetagstring_.size());
  for (int i = 0, n = _impl_.activetagstring_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.activetagstring_.Get(i));
  }

  // repeated string incompleteBuildKey = 18;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.incompletebuildkey_.size());
  for (int i = 0, n = _impl_.incompletebuildkey_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.incompletebuildkey_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string currentVersion = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_currentversion());
    }

    // optional string currentVersionStr = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_currentversionstr());
    }

    // optional string decryptionKey = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_decryptionkey());
    }

    // optional bool installed = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool playable = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool updateComplete = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool backgroundDownloadAvailable = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool backgroundDownloadComplete = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BaseProductState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BaseProductState*>(
      &from));
}

void BaseProductState::MergeFrom(const BaseProductState& from) {
  BaseProductState* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:BaseProductState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.installedbuildconfig_.MergeFrom(from._impl_.installedbuildconfig_);
  _this->_impl_.backgrounddownloadbuildconfig_.MergeFrom(from._impl_.backgrounddownloadbuildconfig_);
  _this->_impl_.completedinstallactions_.MergeFrom(from._impl_.completedinstallactions_);
  _this->_impl_.completedbuildkeys_.MergeFrom(from._impl_.completedbuildkeys_);
  _this->_impl_.completedbgdlkeys_.MergeFrom(from._impl_.completedbgdlkeys_);
  _this->_impl_.activebuildkey_.MergeFrom(from._impl_.activebuildkey_);
  _this->_impl_.activebgdlkey_.MergeFrom(from._impl_.activebgdlkey_);
  _this->_impl_.activeinstallkey_.MergeFrom(from._impl_.activeinstallkey_);
  _this->_impl_.activetagstring_.MergeFrom(from._impl_.activetagstring_);
  _this->_impl_.incompletebuildkey_.MergeFrom(from._impl_.incompletebuildkey_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_currentversion(from._internal_currentversion());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_currentversionstr(from._internal_currentversionstr());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_decryptionkey(from._internal_decryptionkey());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.installed_ = from._impl_.installed_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.playable_ = from._impl_.playable_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.updatecomplete_ = from._impl_.updatecomplete_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.backgrounddownloadavailable_ = from._impl_.backgrounddownloadavailable_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.backgrounddownloadcomplete_ = from._impl_.backgrounddownloadcomplete_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BaseProductState::CopyFrom(const BaseProductState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BaseProductState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseProductState::IsInitialized() const {
  return true;
}

void BaseProductState::InternalSwap(BaseProductState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.installedbuildconfig_.InternalSwap(&other->_impl_.installedbuildconfig_);
  _impl_.backgrounddownloadbuildconfig_.InternalSwap(&other->_impl_.backgrounddownloadbuildconfig_);
  _impl_.completedinstallactions_.InternalSwap(&other->_impl_.completedinstallactions_);
  _impl_.completedbuildkeys_.InternalSwap(&other->_impl_.completedbuildkeys_);
  _impl_.completedbgdlkeys_.InternalSwap(&other->_impl_.completedbgdlkeys_);
  _impl_.activebuildkey_.InternalSwap(&other->_impl_.activebuildkey_);
  _impl_.activebgdlkey_.InternalSwap(&other->_impl_.activebgdlkey_);
  _impl_.activeinstallkey_.InternalSwap(&other->_impl_.activeinstallkey_);
  _impl_.activetagstring_.InternalSwap(&other->_impl_.activetagstring_);
  _impl_.incompletebuildkey_.InternalSwap(&other->_impl_.incompletebuildkey_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.currentversion_, lhs_arena,
      &other->_impl_.currentversion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.currentversionstr_, lhs_arena,
      &other->_impl_.currentversionstr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.decryptionkey_, lhs_arena,
      &other->_impl_.decryptionkey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BaseProductState, _impl_.backgrounddownloadcomplete_)
      + sizeof(BaseProductState::_impl_.backgrounddownloadcomplete_)
      - PROTOBUF_FIELD_OFFSET(BaseProductState, _impl_.installed_)>(
          reinterpret_cast<char*>(&_impl_.installed_),
          reinterpret_cast<char*>(&other->_impl_.installed_));
}

std::string BaseProductState::GetTypeName() const {
  return "BaseProductState";
}


// ===================================================================

class BackfillProgress::_Internal {
 public:
  using HasBits = decltype(std::declval<BackfillProgress>()._impl_._has_bits_);
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_backgrounddownload(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_paused(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_downloadlimit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BackfillProgress::BackfillProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:BackfillProgress)
}
BackfillProgress::BackfillProgress(const BackfillProgress& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BackfillProgress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.progress_){}
    , decltype(_impl_.downloadlimit_){}
    , decltype(_impl_.backgrounddownload_){}
    , decltype(_impl_.paused_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.progress_, &from._impl_.progress_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.paused_) -
    reinterpret_cast<char*>(&_impl_.progress_)) + sizeof(_impl_.paused_));
  // @@protoc_insertion_point(copy_constructor:BackfillProgress)
}

inline void BackfillProgress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.progress_){0}
    , decltype(_impl_.downloadlimit_){uint64_t{0u}}
    , decltype(_impl_.backgrounddownload_){false}
    , decltype(_impl_.paused_){false}
  };
}

BackfillProgress::~BackfillProgress() {
  // @@protoc_insertion_point(destructor:BackfillProgress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BackfillProgress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BackfillProgress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BackfillProgress::Clear() {
// @@protoc_insertion_point(message_clear_start:BackfillProgress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.progress_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.paused_) -
        reinterpret_cast<char*>(&_impl_.progress_)) + sizeof(_impl_.paused_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BackfillProgress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double progress = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_progress(&has_bits);
          _impl_.progress_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool backgrounddownload = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_backgrounddownload(&has_bits);
          _impl_.backgrounddownload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool paused = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_paused(&has_bits);
          _impl_.paused_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 downloadLimit = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_downloadlimit(&has_bits);
          _impl_.downloadlimit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BackfillProgress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:BackfillProgress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double progress = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_progress(), target);
  }

  // optional bool backgrounddownload = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_backgrounddownload(), target);
  }

  // optional bool paused = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_paused(), target);
  }

  // optional uint64 downloadLimit = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_downloadlimit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BackfillProgress)
  return target;
}

size_t BackfillProgress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:BackfillProgress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional double progress = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint64 downloadLimit = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_downloadlimit());
    }

    // optional bool backgrounddownload = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool paused = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BackfillProgress::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BackfillProgress*>(
      &from));
}

void BackfillProgress::MergeFrom(const BackfillProgress& from) {
  BackfillProgress* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:BackfillProgress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.progress_ = from._impl_.progress_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.downloadlimit_ = from._impl_.downloadlimit_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.backgrounddownload_ = from._impl_.backgrounddownload_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.paused_ = from._impl_.paused_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BackfillProgress::CopyFrom(const BackfillProgress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BackfillProgress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BackfillProgress::IsInitialized() const {
  return true;
}

void BackfillProgress::InternalSwap(BackfillProgress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BackfillProgress, _impl_.paused_)
      + sizeof(BackfillProgress::_impl_.paused_)
      - PROTOBUF_FIELD_OFFSET(BackfillProgress, _impl_.progress_)>(
          reinterpret_cast<char*>(&_impl_.progress_),
          reinterpret_cast<char*>(&other->_impl_.progress_));
}

std::string BackfillProgress::GetTypeName() const {
  return "BackfillProgress";
}


// ===================================================================

class RepairProgress::_Internal {
 public:
  using HasBits = decltype(std::declval<RepairProgress>()._impl_._has_bits_);
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RepairProgress::RepairProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:RepairProgress)
}
RepairProgress::RepairProgress(const RepairProgress& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RepairProgress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.progress_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.progress_ = from._impl_.progress_;
  // @@protoc_insertion_point(copy_constructor:RepairProgress)
}

inline void RepairProgress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.progress_){0}
  };
}

RepairProgress::~RepairProgress() {
  // @@protoc_insertion_point(destructor:RepairProgress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RepairProgress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RepairProgress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RepairProgress::Clear() {
// @@protoc_insertion_point(message_clear_start:RepairProgress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.progress_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RepairProgress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double progress = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_progress(&has_bits);
          _impl_.progress_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RepairProgress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RepairProgress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double progress = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_progress(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RepairProgress)
  return target;
}

size_t RepairProgress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RepairProgress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional double progress = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RepairProgress::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RepairProgress*>(
      &from));
}

void RepairProgress::MergeFrom(const RepairProgress& from) {
  RepairProgress* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:RepairProgress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_progress()) {
    _this->_internal_set_progress(from._internal_progress());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RepairProgress::CopyFrom(const RepairProgress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RepairProgress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepairProgress::IsInitialized() const {
  return true;
}

void RepairProgress::InternalSwap(RepairProgress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.progress_, other->_impl_.progress_);
}

std::string RepairProgress::GetTypeName() const {
  return "RepairProgress";
}


// ===================================================================

class UpdateProgress::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateProgress>()._impl_._has_bits_);
  static void set_has_lastdiscsetused(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_discignored(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_totaltodownload(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_downloadremaining(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

UpdateProgress::UpdateProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UpdateProgress)
}
UpdateProgress::UpdateProgress(const UpdateProgress& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UpdateProgress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lastdiscsetused_){}
    , decltype(_impl_.progress_){}
    , decltype(_impl_.totaltodownload_){}
    , decltype(_impl_.downloadremaining_){}
    , decltype(_impl_.discignored_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.lastdiscsetused_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lastdiscsetused_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_lastdiscsetused()) {
    _this->_impl_.lastdiscsetused_.Set(from._internal_lastdiscsetused(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.progress_, &from._impl_.progress_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.discignored_) -
    reinterpret_cast<char*>(&_impl_.progress_)) + sizeof(_impl_.discignored_));
  // @@protoc_insertion_point(copy_constructor:UpdateProgress)
}

inline void UpdateProgress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lastdiscsetused_){}
    , decltype(_impl_.progress_){0}
    , decltype(_impl_.totaltodownload_){uint64_t{0u}}
    , decltype(_impl_.downloadremaining_){uint64_t{0u}}
    , decltype(_impl_.discignored_){false}
  };
  _impl_.lastdiscsetused_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lastdiscsetused_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UpdateProgress::~UpdateProgress() {
  // @@protoc_insertion_point(destructor:UpdateProgress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateProgress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.lastdiscsetused_.Destroy();
}

void UpdateProgress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateProgress::Clear() {
// @@protoc_insertion_point(message_clear_start:UpdateProgress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.lastdiscsetused_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.progress_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.discignored_) -
        reinterpret_cast<char*>(&_impl_.progress_)) + sizeof(_impl_.discignored_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UpdateProgress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string lastDiscSetUsed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_lastdiscsetused();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double progress = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_progress(&has_bits);
          _impl_.progress_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool discIgnored = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_discignored(&has_bits);
          _impl_.discignored_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 totalToDownload = 4 [default = 0];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_totaltodownload(&has_bits);
          _impl_.totaltodownload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 downloadRemaining = 5 [default = 0];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_downloadremaining(&has_bits);
          _impl_.downloadremaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateProgress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UpdateProgress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string lastDiscSetUsed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_lastdiscsetused(), target);
  }

  // optional double progress = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_progress(), target);
  }

  // optional bool discIgnored = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_discignored(), target);
  }

  // optional uint64 totalToDownload = 4 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_totaltodownload(), target);
  }

  // optional uint64 downloadRemaining = 5 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_downloadremaining(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UpdateProgress)
  return target;
}

size_t UpdateProgress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UpdateProgress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string lastDiscSetUsed = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_lastdiscsetused());
    }

    // optional double progress = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint64 totalToDownload = 4 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_totaltodownload());
    }

    // optional uint64 downloadRemaining = 5 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_downloadremaining());
    }

    // optional bool discIgnored = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UpdateProgress::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UpdateProgress*>(
      &from));
}

void UpdateProgress::MergeFrom(const UpdateProgress& from) {
  UpdateProgress* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:UpdateProgress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_lastdiscsetused(from._internal_lastdiscsetused());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.progress_ = from._impl_.progress_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.totaltodownload_ = from._impl_.totaltodownload_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.downloadremaining_ = from._impl_.downloadremaining_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.discignored_ = from._impl_.discignored_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UpdateProgress::CopyFrom(const UpdateProgress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UpdateProgress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateProgress::IsInitialized() const {
  return true;
}

void UpdateProgress::InternalSwap(UpdateProgress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.lastdiscsetused_, lhs_arena,
      &other->_impl_.lastdiscsetused_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateProgress, _impl_.discignored_)
      + sizeof(UpdateProgress::_impl_.discignored_)
      - PROTOBUF_FIELD_OFFSET(UpdateProgress, _impl_.progress_)>(
          reinterpret_cast<char*>(&_impl_.progress_),
          reinterpret_cast<char*>(&other->_impl_.progress_));
}

std::string UpdateProgress::GetTypeName() const {
  return "UpdateProgress";
}


// ===================================================================

class CachedProductState::_Internal {
 public:
  using HasBits = decltype(std::declval<CachedProductState>()._impl_._has_bits_);
  static const ::BaseProductState& baseproductstate(const CachedProductState* msg);
  static void set_has_baseproductstate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::BackfillProgress& backfillprogress(const CachedProductState* msg);
  static void set_has_backfillprogress(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::RepairProgress& repairprogress(const CachedProductState* msg);
  static void set_has_repairprogress(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::UpdateProgress& updateprogress(const CachedProductState* msg);
  static void set_has_updateprogress(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::BaseProductState&
CachedProductState::_Internal::baseproductstate(const CachedProductState* msg) {
  return *msg->_impl_.baseproductstate_;
}
const ::BackfillProgress&
CachedProductState::_Internal::backfillprogress(const CachedProductState* msg) {
  return *msg->_impl_.backfillprogress_;
}
const ::RepairProgress&
CachedProductState::_Internal::repairprogress(const CachedProductState* msg) {
  return *msg->_impl_.repairprogress_;
}
const ::UpdateProgress&
CachedProductState::_Internal::updateprogress(const CachedProductState* msg) {
  return *msg->_impl_.updateprogress_;
}
CachedProductState::CachedProductState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CachedProductState)
}
CachedProductState::CachedProductState(const CachedProductState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CachedProductState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.baseproductstate_){nullptr}
    , decltype(_impl_.backfillprogress_){nullptr}
    , decltype(_impl_.repairprogress_){nullptr}
    , decltype(_impl_.updateprogress_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_baseproductstate()) {
    _this->_impl_.baseproductstate_ = new ::BaseProductState(*from._impl_.baseproductstate_);
  }
  if (from._internal_has_backfillprogress()) {
    _this->_impl_.backfillprogress_ = new ::BackfillProgress(*from._impl_.backfillprogress_);
  }
  if (from._internal_has_repairprogress()) {
    _this->_impl_.repairprogress_ = new ::RepairProgress(*from._impl_.repairprogress_);
  }
  if (from._internal_has_updateprogress()) {
    _this->_impl_.updateprogress_ = new ::UpdateProgress(*from._impl_.updateprogress_);
  }
  // @@protoc_insertion_point(copy_constructor:CachedProductState)
}

inline void CachedProductState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.baseproductstate_){nullptr}
    , decltype(_impl_.backfillprogress_){nullptr}
    , decltype(_impl_.repairprogress_){nullptr}
    , decltype(_impl_.updateprogress_){nullptr}
  };
}

CachedProductState::~CachedProductState() {
  // @@protoc_insertion_point(destructor:CachedProductState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CachedProductState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.baseproductstate_;
  if (this != internal_default_instance()) delete _impl_.backfillprogress_;
  if (this != internal_default_instance()) delete _impl_.repairprogress_;
  if (this != internal_default_instance()) delete _impl_.updateprogress_;
}

void CachedProductState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CachedProductState::Clear() {
// @@protoc_insertion_point(message_clear_start:CachedProductState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.baseproductstate_ != nullptr);
      _impl_.baseproductstate_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.backfillprogress_ != nullptr);
      _impl_.backfillprogress_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.repairprogress_ != nullptr);
      _impl_.repairprogress_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.updateprogress_ != nullptr);
      _impl_.updateprogress_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CachedProductState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .BaseProductState baseProductState = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_baseproductstate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .BackfillProgress backfillProgress = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_backfillprogress(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .RepairProgress repairProgress = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_repairprogress(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .UpdateProgress updateProgress = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_updateprogress(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CachedProductState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CachedProductState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .BaseProductState baseProductState = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::baseproductstate(this),
        _Internal::baseproductstate(this).GetCachedSize(), target, stream);
  }

  // optional .BackfillProgress backfillProgress = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::backfillprogress(this),
        _Internal::backfillprogress(this).GetCachedSize(), target, stream);
  }

  // optional .RepairProgress repairProgress = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::repairprogress(this),
        _Internal::repairprogress(this).GetCachedSize(), target, stream);
  }

  // optional .UpdateProgress updateProgress = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::updateprogress(this),
        _Internal::updateprogress(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CachedProductState)
  return target;
}

size_t CachedProductState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CachedProductState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .BaseProductState baseProductState = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.baseproductstate_);
    }

    // optional .BackfillProgress backfillProgress = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.backfillprogress_);
    }

    // optional .RepairProgress repairProgress = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.repairprogress_);
    }

    // optional .UpdateProgress updateProgress = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.updateprogress_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CachedProductState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CachedProductState*>(
      &from));
}

void CachedProductState::MergeFrom(const CachedProductState& from) {
  CachedProductState* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CachedProductState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_baseproductstate()->::BaseProductState::MergeFrom(
          from._internal_baseproductstate());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_backfillprogress()->::BackfillProgress::MergeFrom(
          from._internal_backfillprogress());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_repairprogress()->::RepairProgress::MergeFrom(
          from._internal_repairprogress());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_updateprogress()->::UpdateProgress::MergeFrom(
          from._internal_updateprogress());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CachedProductState::CopyFrom(const CachedProductState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CachedProductState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CachedProductState::IsInitialized() const {
  return true;
}

void CachedProductState::InternalSwap(CachedProductState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CachedProductState, _impl_.updateprogress_)
      + sizeof(CachedProductState::_impl_.updateprogress_)
      - PROTOBUF_FIELD_OFFSET(CachedProductState, _impl_.baseproductstate_)>(
          reinterpret_cast<char*>(&_impl_.baseproductstate_),
          reinterpret_cast<char*>(&other->_impl_.baseproductstate_));
}

std::string CachedProductState::GetTypeName() const {
  return "CachedProductState";
}


// ===================================================================

class ProductOperations::_Internal {
 public:
  using HasBits = decltype(std::declval<ProductOperations>()._impl_._has_bits_);
  static void set_has_activeoperation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ProductOperations::ProductOperations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProductOperations)
}
ProductOperations::ProductOperations(const ProductOperations& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ProductOperations* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.priority_){}
    , decltype(_impl_.activeoperation_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.priority_, &from._impl_.priority_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.activeoperation_) -
    reinterpret_cast<char*>(&_impl_.priority_)) + sizeof(_impl_.activeoperation_));
  // @@protoc_insertion_point(copy_constructor:ProductOperations)
}

inline void ProductOperations::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.priority_){uint64_t{0u}}
    , decltype(_impl_.activeoperation_){-1}
  };
}

ProductOperations::~ProductOperations() {
  // @@protoc_insertion_point(destructor:ProductOperations)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProductOperations::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProductOperations::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProductOperations::Clear() {
// @@protoc_insertion_point(message_clear_start:ProductOperations)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.priority_ = uint64_t{0u};
    _impl_.activeoperation_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ProductOperations::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .Operation activeOperation = 1 [default = OP_NONE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Operation_IsValid(val))) {
            _internal_set_activeoperation(static_cast<::Operation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 priority = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_priority(&has_bits);
          _impl_.priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProductOperations::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProductOperations)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .Operation activeOperation = 1 [default = OP_NONE];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_activeoperation(), target);
  }

  // optional uint64 priority = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_priority(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProductOperations)
  return target;
}

size_t ProductOperations::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProductOperations)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 priority = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_priority());
    }

    // optional .Operation activeOperation = 1 [default = OP_NONE];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_activeoperation());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProductOperations::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ProductOperations*>(
      &from));
}

void ProductOperations::MergeFrom(const ProductOperations& from) {
  ProductOperations* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:ProductOperations)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.priority_ = from._impl_.priority_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.activeoperation_ = from._impl_.activeoperation_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProductOperations::CopyFrom(const ProductOperations& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProductOperations)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProductOperations::IsInitialized() const {
  return true;
}

void ProductOperations::InternalSwap(ProductOperations* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.priority_, other->_impl_.priority_);
  swap(_impl_.activeoperation_, other->_impl_.activeoperation_);
}

std::string ProductOperations::GetTypeName() const {
  return "ProductOperations";
}


// ===================================================================

class ProductInstall::_Internal {
 public:
  using HasBits = decltype(std::declval<ProductInstall>()._impl_._has_bits_);
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_productcode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::UserSettings& settings(const ProductInstall* msg);
  static void set_has_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CachedProductState& cachedproductstate(const ProductInstall* msg);
  static void set_has_cachedproductstate(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::ProductOperations& productoperations(const ProductInstall* msg);
  static void set_has_productoperations(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_productfamily(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hidden(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_persistentjsonstorage(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::UserSettings&
ProductInstall::_Internal::settings(const ProductInstall* msg) {
  return *msg->_impl_.settings_;
}
const ::CachedProductState&
ProductInstall::_Internal::cachedproductstate(const ProductInstall* msg) {
  return *msg->_impl_.cachedproductstate_;
}
const ::ProductOperations&
ProductInstall::_Internal::productoperations(const ProductInstall* msg) {
  return *msg->_impl_.productoperations_;
}
ProductInstall::ProductInstall(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProductInstall)
}
ProductInstall::ProductInstall(const ProductInstall& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ProductInstall* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.productcode_){}
    , decltype(_impl_.productfamily_){}
    , decltype(_impl_.persistentjsonstorage_){}
    , decltype(_impl_.settings_){nullptr}
    , decltype(_impl_.cachedproductstate_){nullptr}
    , decltype(_impl_.productoperations_){nullptr}
    , decltype(_impl_.hidden_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_uid()) {
    _this->_impl_.uid_.Set(from._internal_uid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.productcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_productcode()) {
    _this->_impl_.productcode_.Set(from._internal_productcode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.productfamily_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productfamily_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_productfamily()) {
    _this->_impl_.productfamily_.Set(from._internal_productfamily(), 
      _this->GetArenaForAllocation());
  }
  _impl_.persistentjsonstorage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.persistentjsonstorage_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_persistentjsonstorage()) {
    _this->_impl_.persistentjsonstorage_.Set(from._internal_persistentjsonstorage(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_settings()) {
    _this->_impl_.settings_ = new ::UserSettings(*from._impl_.settings_);
  }
  if (from._internal_has_cachedproductstate()) {
    _this->_impl_.cachedproductstate_ = new ::CachedProductState(*from._impl_.cachedproductstate_);
  }
  if (from._internal_has_productoperations()) {
    _this->_impl_.productoperations_ = new ::ProductOperations(*from._impl_.productoperations_);
  }
  _this->_impl_.hidden_ = from._impl_.hidden_;
  // @@protoc_insertion_point(copy_constructor:ProductInstall)
}

inline void ProductInstall::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.productcode_){}
    , decltype(_impl_.productfamily_){}
    , decltype(_impl_.persistentjsonstorage_){}
    , decltype(_impl_.settings_){nullptr}
    , decltype(_impl_.cachedproductstate_){nullptr}
    , decltype(_impl_.productoperations_){nullptr}
    , decltype(_impl_.hidden_){false}
  };
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productfamily_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productfamily_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.persistentjsonstorage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.persistentjsonstorage_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ProductInstall::~ProductInstall() {
  // @@protoc_insertion_point(destructor:ProductInstall)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProductInstall::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uid_.Destroy();
  _impl_.productcode_.Destroy();
  _impl_.productfamily_.Destroy();
  _impl_.persistentjsonstorage_.Destroy();
  if (this != internal_default_instance()) delete _impl_.settings_;
  if (this != internal_default_instance()) delete _impl_.cachedproductstate_;
  if (this != internal_default_instance()) delete _impl_.productoperations_;
}

void ProductInstall::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProductInstall::Clear() {
// @@protoc_insertion_point(message_clear_start:ProductInstall)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.uid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.productcode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.productfamily_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.persistentjsonstorage_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.settings_ != nullptr);
      _impl_.settings_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.cachedproductstate_ != nullptr);
      _impl_.cachedproductstate_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.productoperations_ != nullptr);
      _impl_.productoperations_->Clear();
    }
  }
  _impl_.hidden_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ProductInstall::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string uid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_uid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string productCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_productcode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .UserSettings settings = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CachedProductState cachedProductState = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_cachedproductstate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ProductOperations productOperations = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_productoperations(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string productFamily = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_productfamily();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool Hidden = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_hidden(&has_bits);
          _impl_.hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string persistentJsonStorage = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_persistentjsonstorage();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProductInstall::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProductInstall)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string uid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_uid(), target);
  }

  // optional string productCode = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_productcode(), target);
  }

  // optional .UserSettings settings = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::settings(this),
        _Internal::settings(this).GetCachedSize(), target, stream);
  }

  // optional .CachedProductState cachedProductState = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::cachedproductstate(this),
        _Internal::cachedproductstate(this).GetCachedSize(), target, stream);
  }

  // optional .ProductOperations productOperations = 5;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::productoperations(this),
        _Internal::productoperations(this).GetCachedSize(), target, stream);
  }

  // optional string productFamily = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_productfamily(), target);
  }

  // optional bool Hidden = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_hidden(), target);
  }

  // optional string persistentJsonStorage = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_persistentjsonstorage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProductInstall)
  return target;
}

size_t ProductInstall::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProductInstall)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string uid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_uid());
    }

    // optional string productCode = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_productcode());
    }

    // optional string productFamily = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_productfamily());
    }

    // optional string persistentJsonStorage = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_persistentjsonstorage());
    }

    // optional .UserSettings settings = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.settings_);
    }

    // optional .CachedProductState cachedProductState = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cachedproductstate_);
    }

    // optional .ProductOperations productOperations = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.productoperations_);
    }

    // optional bool Hidden = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProductInstall::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ProductInstall*>(
      &from));
}

void ProductInstall::MergeFrom(const ProductInstall& from) {
  ProductInstall* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:ProductInstall)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_uid(from._internal_uid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_productcode(from._internal_productcode());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_productfamily(from._internal_productfamily());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_persistentjsonstorage(from._internal_persistentjsonstorage());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_settings()->::UserSettings::MergeFrom(
          from._internal_settings());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_cachedproductstate()->::CachedProductState::MergeFrom(
          from._internal_cachedproductstate());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_productoperations()->::ProductOperations::MergeFrom(
          from._internal_productoperations());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.hidden_ = from._impl_.hidden_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProductInstall::CopyFrom(const ProductInstall& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProductInstall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProductInstall::IsInitialized() const {
  return true;
}

void ProductInstall::InternalSwap(ProductInstall* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uid_, lhs_arena,
      &other->_impl_.uid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.productcode_, lhs_arena,
      &other->_impl_.productcode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.productfamily_, lhs_arena,
      &other->_impl_.productfamily_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.persistentjsonstorage_, lhs_arena,
      &other->_impl_.persistentjsonstorage_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProductInstall, _impl_.hidden_)
      + sizeof(ProductInstall::_impl_.hidden_)
      - PROTOBUF_FIELD_OFFSET(ProductInstall, _impl_.settings_)>(
          reinterpret_cast<char*>(&_impl_.settings_),
          reinterpret_cast<char*>(&other->_impl_.settings_));
}

std::string ProductInstall::GetTypeName() const {
  return "ProductInstall";
}


// ===================================================================

class ProductConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<ProductConfig>()._impl_._has_bits_);
  static void set_has_productcode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_metadatahash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ProductConfig::ProductConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProductConfig)
}
ProductConfig::ProductConfig(const ProductConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ProductConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.productcode_){}
    , decltype(_impl_.metadatahash_){}
    , decltype(_impl_.timestamp_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.productcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_productcode()) {
    _this->_impl_.productcode_.Set(from._internal_productcode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.metadatahash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.metadatahash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_metadatahash()) {
    _this->_impl_.metadatahash_.Set(from._internal_metadatahash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.timestamp_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.timestamp_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_.Set(from._internal_timestamp(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:ProductConfig)
}

inline void ProductConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.productcode_){}
    , decltype(_impl_.metadatahash_){}
    , decltype(_impl_.timestamp_){}
  };
  _impl_.productcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.metadatahash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.metadatahash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.timestamp_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ProductConfig::~ProductConfig() {
  // @@protoc_insertion_point(destructor:ProductConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProductConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.productcode_.Destroy();
  _impl_.metadatahash_.Destroy();
  _impl_.timestamp_.Destroy();
}

void ProductConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProductConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:ProductConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.productcode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.metadatahash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.timestamp_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ProductConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string productCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_productcode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string metadataHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_metadatahash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_timestamp();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProductConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProductConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string productCode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_productcode(), target);
  }

  // optional string metadataHash = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_metadatahash(), target);
  }

  // optional string timestamp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProductConfig)
  return target;
}

size_t ProductConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProductConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string productCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_productcode());
    }

    // optional string metadataHash = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_metadatahash());
    }

    // optional string timestamp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_timestamp());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProductConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ProductConfig*>(
      &from));
}

void ProductConfig::MergeFrom(const ProductConfig& from) {
  ProductConfig* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:ProductConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_productcode(from._internal_productcode());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_metadatahash(from._internal_metadatahash());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_timestamp(from._internal_timestamp());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProductConfig::CopyFrom(const ProductConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProductConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProductConfig::IsInitialized() const {
  return true;
}

void ProductConfig::InternalSwap(ProductConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.productcode_, lhs_arena,
      &other->_impl_.productcode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.metadatahash_, lhs_arena,
      &other->_impl_.metadatahash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.timestamp_, lhs_arena,
      &other->_impl_.timestamp_, rhs_arena
  );
}

std::string ProductConfig::GetTypeName() const {
  return "ProductConfig";
}


// ===================================================================

class ActiveProcess::_Internal {
 public:
  using HasBits = decltype(std::declval<ActiveProcess>()._impl_._has_bits_);
  static void set_has_processname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ActiveProcess::ActiveProcess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ActiveProcess)
}
ActiveProcess::ActiveProcess(const ActiveProcess& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ActiveProcess* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uri_){from._impl_.uri_}
    , decltype(_impl_.processname_){}
    , decltype(_impl_.pid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.processname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.processname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_processname()) {
    _this->_impl_.processname_.Set(from._internal_processname(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.pid_ = from._impl_.pid_;
  // @@protoc_insertion_point(copy_constructor:ActiveProcess)
}

inline void ActiveProcess::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uri_){arena}
    , decltype(_impl_.processname_){}
    , decltype(_impl_.pid_){0}
  };
  _impl_.processname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.processname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ActiveProcess::~ActiveProcess() {
  // @@protoc_insertion_point(destructor:ActiveProcess)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActiveProcess::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uri_.~RepeatedPtrField();
  _impl_.processname_.Destroy();
}

void ActiveProcess::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActiveProcess::Clear() {
// @@protoc_insertion_point(message_clear_start:ActiveProcess)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.uri_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.processname_.ClearNonDefaultToEmpty();
  }
  _impl_.pid_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ActiveProcess::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string processName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_processname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string uri = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_uri();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActiveProcess::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ActiveProcess)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string processName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_processname(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // repeated string uri = 3;
  for (int i = 0, n = this->_internal_uri_size(); i < n; i++) {
    const auto& s = this->_internal_uri(i);
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ActiveProcess)
  return target;
}

size_t ActiveProcess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ActiveProcess)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string uri = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.uri_.size());
  for (int i = 0, n = _impl_.uri_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.uri_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string processName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_processname());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActiveProcess::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ActiveProcess*>(
      &from));
}

void ActiveProcess::MergeFrom(const ActiveProcess& from) {
  ActiveProcess* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:ActiveProcess)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.uri_.MergeFrom(from._impl_.uri_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_processname(from._internal_processname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActiveProcess::CopyFrom(const ActiveProcess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ActiveProcess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActiveProcess::IsInitialized() const {
  return true;
}

void ActiveProcess::InternalSwap(ActiveProcess* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.uri_.InternalSwap(&other->_impl_.uri_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.processname_, lhs_arena,
      &other->_impl_.processname_, rhs_arena
  );
  swap(_impl_.pid_, other->_impl_.pid_);
}

std::string ActiveProcess::GetTypeName() const {
  return "ActiveProcess";
}


// ===================================================================

class DownloadSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<DownloadSettings>()._impl_._has_bits_);
  static void set_has_downloadlimit(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_backfilllimit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DownloadSettings::DownloadSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DownloadSettings)
}
DownloadSettings::DownloadSettings(const DownloadSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DownloadSettings* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.downloadlimit_){}
    , decltype(_impl_.backfilllimit_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.downloadlimit_, &from._impl_.downloadlimit_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.backfilllimit_) -
    reinterpret_cast<char*>(&_impl_.downloadlimit_)) + sizeof(_impl_.backfilllimit_));
  // @@protoc_insertion_point(copy_constructor:DownloadSettings)
}

inline void DownloadSettings::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.downloadlimit_){-1}
    , decltype(_impl_.backfilllimit_){-1}
  };
}

DownloadSettings::~DownloadSettings() {
  // @@protoc_insertion_point(destructor:DownloadSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownloadSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DownloadSettings::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DownloadSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:DownloadSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.downloadlimit_ = -1;
    _impl_.backfilllimit_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DownloadSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 downloadLimit = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_downloadlimit(&has_bits);
          _impl_.downloadlimit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 backfillLimit = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_backfilllimit(&has_bits);
          _impl_.backfilllimit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownloadSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DownloadSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 downloadLimit = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_downloadlimit(), target);
  }

  // optional int32 backfillLimit = 2 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_backfilllimit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DownloadSettings)
  return target;
}

size_t DownloadSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DownloadSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 downloadLimit = 1 [default = -1];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_downloadlimit());
    }

    // optional int32 backfillLimit = 2 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_backfilllimit());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DownloadSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DownloadSettings*>(
      &from));
}

void DownloadSettings::MergeFrom(const DownloadSettings& from) {
  DownloadSettings* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:DownloadSettings)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.downloadlimit_ = from._impl_.downloadlimit_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.backfilllimit_ = from._impl_.backfilllimit_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DownloadSettings::CopyFrom(const DownloadSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DownloadSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownloadSettings::IsInitialized() const {
  return true;
}

void DownloadSettings::InternalSwap(DownloadSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.downloadlimit_, other->_impl_.downloadlimit_);
  swap(_impl_.backfilllimit_, other->_impl_.backfilllimit_);
}

std::string DownloadSettings::GetTypeName() const {
  return "DownloadSettings";
}


// ===================================================================

class Database::_Internal {
 public:
  using HasBits = decltype(std::declval<Database>()._impl_._has_bits_);
  static const ::DownloadSettings& downloadsettings(const Database* msg);
  static void set_has_downloadsettings(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::DownloadSettings&
Database::_Internal::downloadsettings(const Database* msg) {
  return *msg->_impl_.downloadsettings_;
}
Database::Database(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Database)
}
Database::Database(const Database& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Database* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.productinstall_){from._impl_.productinstall_}
    , decltype(_impl_.activeinstalls_){from._impl_.activeinstalls_}
    , decltype(_impl_.activeprocesses_){from._impl_.activeprocesses_}
    , decltype(_impl_.productconfigs_){from._impl_.productconfigs_}
    , decltype(_impl_.downloadsettings_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_downloadsettings()) {
    _this->_impl_.downloadsettings_ = new ::DownloadSettings(*from._impl_.downloadsettings_);
  }
  // @@protoc_insertion_point(copy_constructor:Database)
}

inline void Database::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.productinstall_){arena}
    , decltype(_impl_.activeinstalls_){arena}
    , decltype(_impl_.activeprocesses_){arena}
    , decltype(_impl_.productconfigs_){arena}
    , decltype(_impl_.downloadsettings_){nullptr}
  };
}

Database::~Database() {
  // @@protoc_insertion_point(destructor:Database)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Database::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.productinstall_.~RepeatedPtrField();
  _impl_.activeinstalls_.~RepeatedPtrField();
  _impl_.activeprocesses_.~RepeatedPtrField();
  _impl_.productconfigs_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.downloadsettings_;
}

void Database::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Database::Clear() {
// @@protoc_insertion_point(message_clear_start:Database)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.productinstall_.Clear();
  _impl_.activeinstalls_.Clear();
  _impl_.activeprocesses_.Clear();
  _impl_.productconfigs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.downloadsettings_ != nullptr);
    _impl_.downloadsettings_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Database::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ProductInstall productInstall = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_productinstall(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .InstallHandshake activeInstalls = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_activeinstalls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ActiveProcess activeProcesses = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_activeprocesses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ProductConfig productConfigs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_productconfigs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .DownloadSettings downloadSettings = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_downloadsettings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Database::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Database)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ProductInstall productInstall = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_productinstall_size()); i < n; i++) {
    const auto& repfield = this->_internal_productinstall(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .InstallHandshake activeInstalls = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_activeinstalls_size()); i < n; i++) {
    const auto& repfield = this->_internal_activeinstalls(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ActiveProcess activeProcesses = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_activeprocesses_size()); i < n; i++) {
    const auto& repfield = this->_internal_activeprocesses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ProductConfig productConfigs = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_productconfigs_size()); i < n; i++) {
    const auto& repfield = this->_internal_productconfigs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .DownloadSettings downloadSettings = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::downloadsettings(this),
        _Internal::downloadsettings(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Database)
  return target;
}

size_t Database::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Database)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ProductInstall productInstall = 1;
  total_size += 1UL * this->_internal_productinstall_size();
  for (const auto& msg : this->_impl_.productinstall_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .InstallHandshake activeInstalls = 2;
  total_size += 1UL * this->_internal_activeinstalls_size();
  for (const auto& msg : this->_impl_.activeinstalls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ActiveProcess activeProcesses = 3;
  total_size += 1UL * this->_internal_activeprocesses_size();
  for (const auto& msg : this->_impl_.activeprocesses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ProductConfig productConfigs = 4;
  total_size += 1UL * this->_internal_productconfigs_size();
  for (const auto& msg : this->_impl_.productconfigs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .DownloadSettings downloadSettings = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.downloadsettings_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Database::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Database*>(
      &from));
}

void Database::MergeFrom(const Database& from) {
  Database* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Database)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.productinstall_.MergeFrom(from._impl_.productinstall_);
  _this->_impl_.activeinstalls_.MergeFrom(from._impl_.activeinstalls_);
  _this->_impl_.activeprocesses_.MergeFrom(from._impl_.activeprocesses_);
  _this->_impl_.productconfigs_.MergeFrom(from._impl_.productconfigs_);
  if (from._internal_has_downloadsettings()) {
    _this->_internal_mutable_downloadsettings()->::DownloadSettings::MergeFrom(
        from._internal_downloadsettings());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Database::CopyFrom(const Database& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Database)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Database::IsInitialized() const {
  return true;
}

void Database::InternalSwap(Database* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.productinstall_.InternalSwap(&other->_impl_.productinstall_);
  _impl_.activeinstalls_.InternalSwap(&other->_impl_.activeinstalls_);
  _impl_.activeprocesses_.InternalSwap(&other->_impl_.activeprocesses_);
  _impl_.productconfigs_.InternalSwap(&other->_impl_.productconfigs_);
  swap(_impl_.downloadsettings_, other->_impl_.downloadsettings_);
}

std::string Database::GetTypeName() const {
  return "Database";
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::LanguageSetting*
Arena::CreateMaybeMessage< ::LanguageSetting >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LanguageSetting >(arena);
}
template<> PROTOBUF_NOINLINE ::UserSettings*
Arena::CreateMaybeMessage< ::UserSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UserSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::InstallHandshake*
Arena::CreateMaybeMessage< ::InstallHandshake >(Arena* arena) {
  return Arena::CreateMessageInternal< ::InstallHandshake >(arena);
}
template<> PROTOBUF_NOINLINE ::BuildConfig*
Arena::CreateMaybeMessage< ::BuildConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::BuildConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::BaseProductState*
Arena::CreateMaybeMessage< ::BaseProductState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::BaseProductState >(arena);
}
template<> PROTOBUF_NOINLINE ::BackfillProgress*
Arena::CreateMaybeMessage< ::BackfillProgress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::BackfillProgress >(arena);
}
template<> PROTOBUF_NOINLINE ::RepairProgress*
Arena::CreateMaybeMessage< ::RepairProgress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RepairProgress >(arena);
}
template<> PROTOBUF_NOINLINE ::UpdateProgress*
Arena::CreateMaybeMessage< ::UpdateProgress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UpdateProgress >(arena);
}
template<> PROTOBUF_NOINLINE ::CachedProductState*
Arena::CreateMaybeMessage< ::CachedProductState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CachedProductState >(arena);
}
template<> PROTOBUF_NOINLINE ::ProductOperations*
Arena::CreateMaybeMessage< ::ProductOperations >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProductOperations >(arena);
}
template<> PROTOBUF_NOINLINE ::ProductInstall*
Arena::CreateMaybeMessage< ::ProductInstall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProductInstall >(arena);
}
template<> PROTOBUF_NOINLINE ::ProductConfig*
Arena::CreateMaybeMessage< ::ProductConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProductConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::ActiveProcess*
Arena::CreateMaybeMessage< ::ActiveProcess >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ActiveProcess >(arena);
}
template<> PROTOBUF_NOINLINE ::DownloadSettings*
Arena::CreateMaybeMessage< ::DownloadSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DownloadSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::Database*
Arena::CreateMaybeMessage< ::Database >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Database >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
