#version 100

struct modelWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDir_FogStart;
    vec4 uSunColor_uFogEnd;
    vec4 uAmbientLight;
    vec4 FogColor;
    int uNewFormula;
};

uniform modelWideBlockPS _65;

uniform sampler2D uDiffuseTexture;
uniform sampler2D uNormalTexture;

varying vec2 vChunkCoords;
varying vec3 vPosition;

void main()
{
    vec2 TextureCoords = vec2(vChunkCoords.x, vChunkCoords.y);
    vec4 texDiffuse = texture2D(uDiffuseTexture, TextureCoords);
    vec3 matDiffuse = texDiffuse.xyz;
    vec3 vNormal = (texture2D(uNormalTexture, TextureCoords).xyz * 2.0) - vec3(1.0);
    vNormal = vec3(-vNormal.z, -vNormal.x, vNormal.y);
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 fogColor = _65.FogColor.xyz;
    float fog_start = _65.uSunDir_FogStart.w;
    float fog_end = _65.uSunColor_uFogEnd.w;
    float fog_rate = 1.5;
    float fog_bias = 0.00999999977648258209228515625;
    float distanceToCamera = length(vPosition);
    float z_depth = distanceToCamera - fog_bias;
    float expFog = 1.0 / exp(max(0.0, z_depth - fog_start) * fog_rate);
    float heightFog = 1.0;
    expFog += heightFog;
    float endFadeFog = clamp((fog_end - distanceToCamera) / (0.699999988079071044921875 * fog_end), 0.0, 1.0);
    vec3 _123 = mix(fogColor, finalColor.xyz, vec3(min(expFog, endFadeFog)));
    finalColor = vec4(_123.x, _123.y, _123.z, finalColor.w);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct modelWideBlockVS
{
    vec3 uPos;
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform modelWideBlockVS _55;

attribute float aIndex;
attribute float aHeight;
varying vec2 vChunkCoords;
varying vec3 vPosition;

void main()
{
    float stepX = floor(aIndex / 16641.0);
    float division = 129.0;
    bool _20 = stepX > 0.100000001490116119384765625;
    if (_20)
    {
        division = 128.0;
    }
    float offset = (stepX * 129.0) * 129.0;
    float iX = mod(aIndex - offset, division) + (stepX * 0.5);
    float iY = floor((aIndex - offset) / division) + (stepX * 0.5);
    vec4 worldPoint = vec4(_55.uPos.x - (iY * 4.166666507720947265625), _55.uPos.y - (iX * 4.166666507720947265625), aHeight, 1.0);
    vChunkCoords = vec2(iX / 128.0, iY / 128.0);
    vPosition = (_55.uLookAtMat * worldPoint).xyz;
    gl_Position = (_55.uPMatrix * _55.uLookAtMat) * worldPoint;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _221[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _228[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct meshWideBlockPS
{
    vec4 uHeightScale;
    vec4 uHeightOffset;
    mat4 animationMat[4];
};

uniform meshWideBlockPS _454;

struct modelWideBlockPS
{
    ivec4 uUseHeightMixFormula;
};

uniform modelWideBlockPS _494;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _736;

uniform sampler2D uAlphaTexture;
uniform sampler2D uLayerHeight0;
uniform sampler2D uLayerHeight1;
uniform sampler2D uLayerHeight2;
uniform sampler2D uLayerHeight3;
uniform sampler2D uLayer0;
uniform sampler2D uLayer1;
uniform sampler2D uLayer2;
uniform sampler2D uLayer3;

varying vec2 vChunkCoords;
varying vec4 vColor;
varying vec3 vNormal;
varying vec3 vVertexLighting;
varying vec3 vPosition;

vec4 mixTextures(vec4 tex0, vec4 tex1, float alpha)
{
    return ((tex1 - tex0) * alpha) + tex0;
}

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _57 = !applyLight;
    if (_57)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _73 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_73)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _110 = nDotUp >= 0.0;
        if (_110)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _150 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_150)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _174 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_174)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _221[blendMode], vec3(_228[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _240 = blendMode == 13;
    if (_240)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _392 = nDotSun > 0.0;
    if (_392)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec2 vTexCoord = vChunkCoords;
    vec2 alphaCoord = vec2(vChunkCoords.x / 8.0, vChunkCoords.y / 8.0);
    vec3 alphaBlend = texture2D(uAlphaTexture, alphaCoord).yzw;
    vec2 tcLayer0 = (_454.animationMat[0] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer1 = (_454.animationMat[1] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer2 = (_454.animationMat[2] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer3 = (_454.animationMat[3] * vec4(vTexCoord, 0.0, 1.0)).xy;
    bool _498 = _494.uUseHeightMixFormula.x > 0;
    vec4 final;
    if (_498)
    {
        float minusAlphaBlendSum = 1.0 - clamp(dot(alphaBlend, vec3(1.0)), 0.0, 1.0);
        vec4 weightsVector = vec4(minusAlphaBlendSum, alphaBlend);
        float weightedTexture_x = minusAlphaBlendSum * ((texture2D(uLayerHeight0, tcLayer0).w * _454.uHeightScale.x) + _454.uHeightOffset.x);
        float weightedTexture_y = weightsVector.y * ((texture2D(uLayerHeight1, tcLayer1).w * _454.uHeightScale.y) + _454.uHeightOffset.y);
        float weightedTexture_z = weightsVector.z * ((texture2D(uLayerHeight2, tcLayer2).w * _454.uHeightScale.z) + _454.uHeightOffset.z);
        float weightedTexture_w = weightsVector.w * ((texture2D(uLayerHeight3, tcLayer3).w * _454.uHeightScale.w) + _454.uHeightOffset.w);
        vec4 weights = vec4(weightedTexture_x, weightedTexture_y, weightedTexture_z, weightedTexture_w);
        vec4 weights_temp = weights * (vec4(1.0) - clamp(vec4(max(max(weightedTexture_x, weightedTexture_y), max(weightedTexture_z, weightedTexture_w))) - weights, vec4(0.0), vec4(1.0)));
        vec4 weightsNormalized = weights_temp / vec4(dot(vec4(1.0), weights_temp));
        vec4 weightedLayer_0 = texture2D(uLayer0, tcLayer0) * weightsNormalized.x;
        vec3 matDiffuse_0 = weightedLayer_0.xyz;
        float specBlend_0 = weightedLayer_0.w;
        vec4 weightedLayer_1 = texture2D(uLayer1, tcLayer1) * weightsNormalized.y;
        vec3 matDiffuse_1 = matDiffuse_0 + weightedLayer_1.xyz;
        float specBlend_1 = specBlend_0 + weightedLayer_1.w;
        vec4 weightedLayer_2 = texture2D(uLayer2, tcLayer2) * weightsNormalized.z;
        vec3 matDiffuse_2 = matDiffuse_1 + weightedLayer_2.xyz;
        float specBlend_2 = specBlend_1 + weightedLayer_2.w;
        vec4 weightedLayer_3 = texture2D(uLayer3, tcLayer3) * weightsNormalized.w;
        vec3 matDiffuse_3 = matDiffuse_2 + weightedLayer_3.xyz;
        float specBlend_3 = specBlend_2 + weightedLayer_3.w;
        final = vec4(matDiffuse_3, specBlend_3);
    }
    else
    {
        vec4 tex1 = texture2D(uLayer0, tcLayer0);
        vec4 tex2 = texture2D(uLayer1, tcLayer1);
        vec4 tex3 = texture2D(uLayer2, tcLayer2);
        vec4 tex4 = texture2D(uLayer3, tcLayer3);
        vec4 param = tex1;
        vec4 param_1 = tex2;
        float param_2 = alphaBlend.x;
        vec4 param_3 = mixTextures(param, param_1, param_2);
        vec4 param_4 = tex3;
        float param_5 = alphaBlend.y;
        vec4 param_6 = mixTextures(param_3, param_4, param_5);
        vec4 param_7 = tex4;
        float param_8 = alphaBlend.z;
        final = mixTextures(param_6, param_7, param_8);
    }
    vec3 matDiffuse = (final.xyz * 2.0) * vColor.xyz;
    vec3 param_9 = matDiffuse;
    vec3 param_10 = vNormal;
    bool param_11 = true;
    float param_12 = 0.0;
    SceneWideParams param_13;
    param_13.uLookAtMat = _736.scene.uLookAtMat;
    param_13.uPMatrix = _736.scene.uPMatrix;
    param_13.uViewUp = _736.scene.uViewUp;
    param_13.uInteriorSunDir = _736.scene.uInteriorSunDir;
    param_13.extLight.uExteriorAmbientColor = _736.scene.extLight.uExteriorAmbientColor;
    param_13.extLight.uExteriorHorizontAmbientColor = _736.scene.extLight.uExteriorHorizontAmbientColor;
    param_13.extLight.uExteriorGroundAmbientColor = _736.scene.extLight.uExteriorGroundAmbientColor;
    param_13.extLight.uExteriorDirectColor = _736.scene.extLight.uExteriorDirectColor;
    param_13.extLight.uExteriorDirectColorDir = _736.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_14 = InteriorLightParam(vec4(0.0), vec4(0.0, 0.0, 0.0, 1.0));
    vec3 param_15 = vVertexLighting;
    vec4 finalColor = vec4(calcLight(param_9, param_10, param_11, param_12, param_13, param_14, param_15, vec3(0.0), vec3(0.0)), 1.0);
    float specBlend = final.w;
    vec3 halfVec = -normalize(_736.scene.extLight.uExteriorDirectColorDir.xyz + normalize(vPosition));
    vec3 lSpecular = _736.scene.extLight.uExteriorDirectColor.xyz * pow(max(0.0, dot(halfVec, vNormal)), 20.0);
    vec3 specTerm = vec3(specBlend) * lSpecular;
    vec3 _814 = finalColor.xyz + specTerm;
    finalColor = vec4(_814.x, _814.y, _814.z, finalColor.w);
    PSFog arg;
    arg.densityParams = _736.fogData.densityParams;
    arg.heightPlane = _736.fogData.heightPlane;
    arg.color_and_heightRate = _736.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _736.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _736.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _736.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _736.fogData.sunPercentage;
    vec3 param_16 = finalColor.xyz;
    vec3 param_17 = vPosition;
    vec3 param_18 = _736.scene.extLight.uExteriorDirectColorDir.xyz;
    int param_19 = 0;
    vec3 _848 = makeFog(arg, param_16, param_17, param_18, param_19);
    finalColor = vec4(_848.x, _848.y, _848.z, finalColor.w);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _91;

struct meshWideBlockVS
{
    vec4 uPos;
};

uniform meshWideBlockVS _139;

attribute float aIndex;
attribute vec3 aHeight;
varying vec2 vChunkCoords;
varying vec3 vPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec3 vVertexLighting;
attribute vec4 aVertexLighting;
varying vec3 vNormal;
attribute vec3 aNormal;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

void main()
{
    float iX = mod(aIndex, 17.0);
    float iY = floor(aIndex / 17.0);
    bool _61 = iX > 8.0100002288818359375;
    if (_61)
    {
        iY += 0.5;
        iX -= 8.5;
    }
    vec4 worldPoint = vec4(aHeight, 1.0);
    vChunkCoords = vec2(iX, iY);
    vPosition = (_91.scene.uLookAtMat * worldPoint).xyz;
    vColor = aColor;
    vVertexLighting = aVertexLighting.xyz;
    mat4 param = _91.scene.uLookAtMat;
    vNormal = blizzTranspose(param) * aNormal;
    gl_Position = (_91.scene.uPMatrix * _91.scene.uLookAtMat) * worldPoint;
}


#version 100

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
};

uniform modelWideBlockVS _13;

void main()
{
    vec4 finalColor = _13.uColor;
    gl_FragData[0] = finalColor;
}


#version 100

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
};

uniform modelWideBlockVS _21;

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _59;

attribute vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4((aPosition.x * _21.uBBScale.x) + _21.uBBCenter.x, (aPosition.y * _21.uBBScale.y) + _21.uBBCenter.y, (aPosition.z * _21.uBBScale.z) + _21.uBBCenter.z, 1.0);
    gl_Position = ((_59.uPMatrix * _59.uLookAtMat) * _21.uPlacementMat) * worldPoint;
}


#version 100

struct meshWideBlockPS
{
    int drawDepth;
    float uFarPlane;
    float uNearPlane;
};

uniform meshWideBlockPS _10;

uniform sampler2D diffuse;

varying vec2 texCoord;

void main()
{
    bool _17 = _10.drawDepth == 1;
    vec4 finalColor;
    if (_17)
    {
        float f = _10.uFarPlane;
        float n = _10.uNearPlane;
        float z = (2.0 * n) / ((f + n) - (texture2D(diffuse, texCoord).x * (f - n)));
        finalColor = vec4(z, z, z, 255.0);
    }
    else
    {
        finalColor = vec4(texture2D(diffuse, texCoord).xyz, 255.0);
    }
    gl_FragData[0] = finalColor;
}


#version 100

struct meshWideBlockPS
{
    vec3 uColor;
};

uniform meshWideBlockPS _22;

void main()
{
    vec4 finalColor = vec4(1.0);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _13;

attribute vec3 aPosition;

void main()
{
    vec4 c_world = inverse(_13.uPMatrix) * vec4(aPosition, 1.0);
    c_world = (c_world * 1.0) / vec4(c_world.w);
    gl_Position = (_13.uPMatrix * _13.uLookAtMat) * vec4(c_world.xyz, 1.0);
}


#version 100

struct modelWideBlockPS
{
    vec3 uColor;
};

uniform modelWideBlockPS _19;

void main()
{
    vec4 finalColor = vec4(1.0, 1.0, 0.0, 1.0);
    gl_FragData[0] = finalColor;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _19;

attribute vec2 aPosition;

void main()
{
    gl_Position = (_19.uPMatrix * _19.uLookAtMat) * vec4(aPosition, 0.0, 1.0);
}


#version 100

struct modelWideBlockVS
{
    vec3 uColor;
};

uniform modelWideBlockVS _13;

varying vec4 vPos;

void main()
{
    gl_FragData[0] = vec4(_13.uColor, 1.0);
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _19;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _29;

attribute vec3 aPosition;
varying vec4 vPos;

void main()
{
    gl_Position = ((_19.uPMatrix * _19.uLookAtMat) * _29.uPlacementMat) * vec4(aPosition, 1.0);
    gl_PointSize = 10.0;
}


#version 100

struct modelWideBlockVS
{
    vec4 uColor;
};

uniform modelWideBlockVS _12;

void main()
{
    vec4 finalColor = _12.uColor;
    gl_FragData[0] = finalColor;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _30;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _40;

attribute vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4(aPosition, 1.0);
    gl_Position = ((_30.uPMatrix * _30.uLookAtMat) * _40.uPlacementMat) * worldPoint;
}


#version 100

struct meshWideBlockVS
{
    float uWidth;
    float uHeight;
    float uX;
    float uY;
};

uniform meshWideBlockVS _36;

varying vec2 texCoord;
attribute vec2 position;

void main()
{
    texCoord = (position * 0.5) + vec2(0.5);
    gl_Position = vec4((((((position.x + 1.0) / 2.0) * _36.uWidth) + _36.uX) * 2.0) - 1.0, (((((position.y + 1.0) / 2.0) * _36.uHeight) + _36.uY) * 2.0) - 1.0, 0.5, 1.0);
}


#version 100

struct meshWideBlockPS
{
    vec4 texOffsetX;
    vec4 texOffsetY;
};

uniform meshWideBlockPS _33;

uniform sampler2D texture0;

varying vec2 texCoord;

void main()
{
    vec2 tex_offset = vec2(0.001000000047497451305389404296875);
    vec3 result = texture2D(texture0, texCoord).xyz * 0.0;
    result = vec3(0.0);
    result += (texture2D(texture0, texCoord + vec2(_33.texOffsetX.x * tex_offset.x, _33.texOffsetY.x * tex_offset.y)).xyz * 0.125);
    result += (texture2D(texture0, texCoord + vec2(_33.texOffsetX.y * tex_offset.x, _33.texOffsetY.y * tex_offset.y)).xyz * 0.375);
    result += (texture2D(texture0, texCoord + vec2(_33.texOffsetX.z * tex_offset.x, _33.texOffsetY.z * tex_offset.y)).xyz * 0.375);
    result += (texture2D(texture0, texCoord + vec2(_33.texOffsetX.w * tex_offset.x, _33.texOffsetY.w * tex_offset.y)).xyz * 0.125);
    gl_FragData[0] = vec4(result, 1.0);
}


#version 100

struct meshWideBlockPS
{
    vec4 blurAmount;
};

uniform meshWideBlockPS _34;

uniform sampler2D screenTex;
uniform sampler2D blurTex;

varying vec2 texCoord;

void main()
{
    vec4 screen = texture2D(screenTex, texCoord);
    vec3 blurred = texture2D(blurTex, texCoord).xyz;
    vec3 mixed = mix(screen.xyz, blurred, vec3(_34.blurAmount.z));
    vec3 glow = (blurred * blurred) * _34.blurAmount.w;
    gl_FragData[0] = vec4(mixed + glow, screen.w);
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

uniform sampler2D Texture;

varying vec4 Frag_Color;
varying vec2 Frag_UV;

void main()
{
    gl_FragData[0] = Frag_Color * texture2D(Texture, Frag_UV);
}


#version 100

struct modelWideBlockVS
{
    mat4 ProjMtx;
};

uniform modelWideBlockVS _30;

varying vec2 Frag_UV;
attribute vec2 UV;
varying vec4 Frag_Color;
attribute vec4 Color;
attribute vec2 Position;

void main()
{
    Frag_UV = UV;
    Frag_Color = Color;
    gl_Position = _30.ProjMtx * vec4(Position, 0.0, 1.0);
}


#version 100

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _36[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _43[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct meshWideBlockPS
{
    vec4 uAlphaTestv;
    ivec4 uPixelShaderv;
};

uniform meshWideBlockPS _266;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _431;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

varying vec2 vTexcoord0;
varying vec2 vTexcoord1;
varying vec2 vTexcoord2;
varying vec4 vColor;
varying vec3 vPosition;

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _36[blendMode], vec3(_43[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _57 = blendMode == 13;
    if (_57)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _216 = nDotSun > 0.0;
    if (_216)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec4 tex = texture2D(uTexture, vTexcoord0);
    vec4 tex2 = texture2D(uTexture2, vTexcoord1);
    vec4 tex3 = texture2D(uTexture3, vTexcoord2);
    float uAlphaTest = _266.uAlphaTestv.x;
    bool _273 = tex.w < uAlphaTest;
    if (_273)
    {
        discard;
    }
    vec4 finalColor = vec4((tex * vColor).xyz, tex.w * vColor.w);
    int uNonOptPixelShader = _266.uPixelShaderv.x;
    bool _299 = uNonOptPixelShader == 0;
    if (_299)
    {
        vec3 matDiffuse = vColor.xyz * tex.xyz;
        finalColor = vec4(matDiffuse, tex.w * vColor.w);
    }
    else
    {
        bool _320 = uNonOptPixelShader == 1;
        if (_320)
        {
            vec4 textureMod = tex * tex2;
            float texAlpha = textureMod.w * tex3.w;
            float opacity = texAlpha * vColor.w;
            vec3 matDiffuse_1 = vColor.xyz * textureMod.xyz;
            finalColor = vec4(matDiffuse_1, opacity);
        }
        else
        {
            bool _352 = uNonOptPixelShader == 2;
            if (_352)
            {
                vec4 textureMod_1 = (tex * tex2) * tex3;
                float texAlpha_1 = textureMod_1.w;
                float opacity_1 = texAlpha_1 * vColor.w;
                vec3 matDiffuse_2 = vColor.xyz * textureMod_1.xyz;
                finalColor = vec4(matDiffuse_2, opacity_1);
            }
            else
            {
                bool _383 = uNonOptPixelShader == 3;
                if (_383)
                {
                    vec4 textureMod_2 = (tex * tex2) * tex3;
                    float texAlpha_2 = textureMod_2.w;
                    float opacity_2 = texAlpha_2 * vColor.w;
                    vec3 matDiffuse_3 = vColor.xyz * textureMod_2.xyz;
                    finalColor = vec4(matDiffuse_3, opacity_2);
                }
                else
                {
                    bool _414 = uNonOptPixelShader == 4;
                    if (_414)
                    {
                    }
                }
            }
        }
    }
    bool _420 = finalColor.w < uAlphaTest;
    if (_420)
    {
        discard;
    }
    vec3 sunDir = _431.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _431.fogData.densityParams;
    arg.heightPlane = _431.fogData.heightPlane;
    arg.color_and_heightRate = _431.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _431.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _431.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _431.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _431.fogData.sunPercentage;
    vec3 param = finalColor.xyz;
    vec3 param_1 = vPosition;
    vec3 param_2 = sunDir;
    int param_3 = _266.uPixelShaderv.y;
    vec3 _469 = makeFog(arg, param, param_1, param_2, param_3);
    finalColor = vec4(_469.x, _469.y, _469.z, finalColor.w);
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _43;

attribute vec3 aPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec2 vTexcoord0;
attribute vec2 aTexcoord0;
varying vec2 vTexcoord1;
attribute vec2 aTexcoord1;
varying vec2 vTexcoord2;
attribute vec2 aTexcoord2;
varying vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vTexcoord1 = aTexcoord1;
    vTexcoord2 = aTexcoord2;
    vec4 vertexViewSpace = _43.scene.uLookAtMat * aPositionVec4;
    vPosition = vertexViewSpace.xyz;
    gl_Position = _43.scene.uPMatrix * vertexViewSpace;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _215[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _222[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct LocalLight
{
    vec4 color;
    vec4 position;
    vec4 attenuation;
};

struct meshWideBlockPS
{
    ivec4 PixelShader_UnFogged_IsAffectedByLight_blendMode;
    vec4 uFogColorAndAlphaTest;
    vec4 uTexSampleAlpha;
    vec4 uPcColor;
};

uniform meshWideBlockPS _461;

struct modelWideBlockPS
{
    InteriorLightParam intLight;
    LocalLight pc_lights[4];
    ivec4 lightCountAndBcHack;
    vec4 interiorExteriorBlend;
};

uniform modelWideBlockPS _484;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _523;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
};

uniform modelWideBlockVS _531;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;
uniform sampler2D uTexture4;

varying vec2 vTexCoord;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vDiffuseColor;
varying vec3 vPosition;
varying vec3 vNormal;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _50 = !applyLight;
    if (_50)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _66 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_66)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _104 = nDotUp >= 0.0;
        if (_104)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _144 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_144)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _168 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_168)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _215[blendMode], vec3(_222[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _234 = blendMode == 13;
    if (_234)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _386 = nDotSun > 0.0;
    if (_386)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec2 texCoord = vTexCoord;
    vec2 texCoord2 = vTexCoord2;
    vec2 texCoord3 = vTexCoord3;
    vec4 tex = texture2D(uTexture, texCoord);
    vec4 tex2 = texture2D(uTexture2, texCoord2);
    vec4 tex3 = texture2D(uTexture3, texCoord3);
    vec4 tex2WithTextCoord1 = texture2D(uTexture2, texCoord);
    vec4 tex3WithTextCoord1 = texture2D(uTexture3, texCoord);
    vec4 tex4WithTextCoord2 = texture2D(uTexture4, texCoord2);
    vec4 finalColor = vec4(0.0);
    vec4 meshResColor = vDiffuseColor;
    bool _465 = _461.PixelShader_UnFogged_IsAffectedByLight_blendMode.z == 1;
    vec3 accumLight;
    if (_465)
    {
        vec3 vPos3 = vPosition;
        vec3 vNormal3 = normalize(vNormal);
        vec3 lightColor = vec3(0.0);
        int count = int(_484.pc_lights[0].attenuation.w);
        LocalLight lightRecord;
        for (int index = 0; index < 4; index++)
        {
            bool _500 = index >= _484.lightCountAndBcHack.x;
            if (_500)
            {
                break;
            }
            lightRecord.color = _484.pc_lights[index].color;
            lightRecord.position = _484.pc_lights[index].position;
            lightRecord.attenuation = _484.pc_lights[index].attenuation;
            vec3 vectorToLight = (_523.scene.uLookAtMat * (_531.uPlacementMat * lightRecord.position)).xyz - vPos3;
            float distanceToLightSqr = dot(vectorToLight, vectorToLight);
            float distanceToLightInv = inversesqrt(distanceToLightSqr);
            float distanceToLight = distanceToLightSqr * distanceToLightInv;
            float diffuseTerm1 = max(dot(vectorToLight, vNormal3) * distanceToLightInv, 0.0);
            vec4 attenuationRec = lightRecord.attenuation;
            float attenuation = 1.0 - clamp((distanceToLight - attenuationRec.x) * (1.0 / (attenuationRec.z - attenuationRec.x)), 0.0, 1.0);
            vec3 attenuatedColor = lightRecord.color.xyz * attenuation;
            lightColor += vec3((attenuatedColor * attenuatedColor) * diffuseTerm1);
        }
        vec3 _598 = clamp(lightColor, vec3(0.0), vec3(1.0));
        meshResColor = vec4(_598.x, _598.y, _598.z, meshResColor.w);
        accumLight = mix(lightColor, meshResColor.xyz, vec3(float(_484.lightCountAndBcHack.y)));
    }
    float finalOpacity = 0.0;
    vec3 specular = vec3(0.0);
    vec3 visParams = vec3(1.0);
    vec4 genericParams[3];
    genericParams[0] = vec4(1.0);
    genericParams[1] = vec4(1.0);
    genericParams[2] = vec4(1.0);
    int uPixelShader = _461.PixelShader_UnFogged_IsAffectedByLight_blendMode.x;
    bool _624 = uPixelShader == 0;
    vec3 matDiffuse;
    float opacity;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _645 = uPixelShader == 1;
    #if (FRAGMENTSHADER == 1)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _665 = uPixelShader == 2;
    #if (FRAGMENTSHADER == 2)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex2.w * vDiffuseColor.w;
    opacity = tex2.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _693 = uPixelShader == 3;
    #if (FRAGMENTSHADER == 3)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = (tex2.w * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _718 = uPixelShader == 4;
    #if (FRAGMENTSHADER == 4)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _739 = uPixelShader == 5;
    #if (FRAGMENTSHADER == 5)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _759 = uPixelShader == 6;
    #if (FRAGMENTSHADER == 6)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = (tex.w * tex2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _786 = uPixelShader == 7;
    #if (FRAGMENTSHADER == 7)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = ((tex.w * tex2.w) * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _815 = uPixelShader == 8;
    #if (FRAGMENTSHADER == 8)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _841 = uPixelShader == 9;
    #if (FRAGMENTSHADER == 9)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _866 = uPixelShader == 10;
    #if (FRAGMENTSHADER == 10)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _889 = uPixelShader == 11;
    #if (FRAGMENTSHADER == 11)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _913 = uPixelShader == 12;
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _940 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = tex2.xyz * tex2.w;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _963 = uPixelShader == 14;
    #if (FRAGMENTSHADER == 14)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _990 = uPixelShader == 15;
    #if (FRAGMENTSHADER == 15)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    specular = (tex3.xyz * tex3.w) * _461.uTexSampleAlpha.z;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1026 = uPixelShader == 16;
    #if (FRAGMENTSHADER == 16)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz * tex2.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1052 = uPixelShader == 17;
    #if (FRAGMENTSHADER == 17)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + (tex2.w * (((0.300000011920928955078125 * tex2.x) + (0.589999973773956298828125 * tex2.y)) + (0.10999999940395355224609375 * tex2.z)))) * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1100 = uPixelShader == 18;
    #if (FRAGMENTSHADER == 18)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex.xyz, tex2.xyz, vec3(tex2.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1130 = uPixelShader == 19;
    #if (FRAGMENTSHADER == 19)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1158 = uPixelShader == 20;
    #if (FRAGMENTSHADER == 20)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * _461.uTexSampleAlpha.y;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1184 = uPixelShader == 21;
    #if (FRAGMENTSHADER == 21)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1214 = uPixelShader == 22;
    #if (FRAGMENTSHADER == 22)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * tex2.xyz, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1241 = uPixelShader == 23;
    #if (FRAGMENTSHADER == 23)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * _461.uTexSampleAlpha.y;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1270 = uPixelShader == 24;
    #if (FRAGMENTSHADER == 24)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    specular = (tex.xyz * tex.w) * _461.uTexSampleAlpha.x;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1302 = uPixelShader == 25;
    #if (FRAGMENTSHADER == 25)
    float glowOpacity = clamp(tex3.w * _461.uTexSampleAlpha.z, 0.0, 1.0);
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w))) * (1.0 - glowOpacity);
    specular = tex3.xyz * glowOpacity;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1344 = uPixelShader == 26;
    #if (FRAGMENTSHADER == 26)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.z, 0.0, 1.0))).xyz;
    opacity = mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.z, 0.0, 1.0))).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1389 = uPixelShader == 27;
    #if (FRAGMENTSHADER == 27)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1423 = uPixelShader == 28;
    #if (FRAGMENTSHADER == 28)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.z, 0.0, 1.0))).xyz;
    opacity = (mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.z, 0.0, 1.0))).w * tex4WithTextCoord2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1471 = uPixelShader == 29;
    #if (FRAGMENTSHADER == 29)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1495 = uPixelShader == 30;
    #if (FRAGMENTSHADER == 30)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1540 = uPixelShader == 31;
    #if (FRAGMENTSHADER == 31)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1575 = uPixelShader == 32;
    #if (FRAGMENTSHADER == 32)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1617 = uPixelShader == 33;
    #if (FRAGMENTSHADER == 33)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w * vDiffuseColor.w) * visParams.x;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1641 = uPixelShader == 34;
    #if (FRAGMENTSHADER == 34)
    finalColor = vec4(1.0);
    #endif
    bool _1647 = uPixelShader == 35;
    #if (FRAGMENTSHADER == 35)
    vec4 pc_channelScaler = vec4(1.0);
    matDiffuse = (vDiffuseColor.xyz * 2.0) * (((tex * tex2) * tex3) * pc_channelScaler).xyz;
    opacity = (((tex * tex2) * tex3) * pc_channelScaler).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1681 = uPixelShader == 36;
    #if (FRAGMENTSHADER == 36)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = (tex.w * tex2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = _461.PixelShader_UnFogged_IsAffectedByLight_blendMode.z > 0;
    float param_3 = _484.interiorExteriorBlend.x;
    SceneWideParams param_4;
    param_4.uLookAtMat = _523.scene.uLookAtMat;
    param_4.uPMatrix = _523.scene.uPMatrix;
    param_4.uViewUp = _523.scene.uViewUp;
    param_4.uInteriorSunDir = _523.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _523.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _523.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _523.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _523.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _523.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _484.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _484.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = accumLight;
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0), specular), finalOpacity);
    bool _1763 = finalColor.w < _461.uFogColorAndAlphaTest.w;
    if (_1763)
    {
        discard;
    }
    int uUnFogged = _461.PixelShader_UnFogged_IsAffectedByLight_blendMode.y;
    bool _1771 = uUnFogged == 0;
    if (_1771)
    {
        vec3 sunDir = mix(_523.scene.uInteriorSunDir, _523.scene.extLight.uExteriorDirectColorDir, vec4(_484.interiorExteriorBlend.x)).xyz;
        PSFog arg;
        arg.densityParams = _523.fogData.densityParams;
        arg.heightPlane = _523.fogData.heightPlane;
        arg.color_and_heightRate = _523.fogData.color_and_heightRate;
        arg.heightDensity_and_endColor = _523.fogData.heightDensity_and_endColor;
        arg.sunAngle_and_sunColor = _523.fogData.sunAngle_and_sunColor;
        arg.heightColor_and_endFogDistance = _523.fogData.heightColor_and_endFogDistance;
        arg.sunPercentage = _523.fogData.sunPercentage;
        vec3 param_7 = finalColor.xyz;
        vec3 param_8 = vPosition;
        vec3 param_9 = sunDir;
        int param_10 = _461.PixelShader_UnFogged_IsAffectedByLight_blendMode.w;
        vec3 _1816 = makeFog(arg, param_7, param_8, param_9, param_10);
        finalColor = vec4(_1816.x, _1816.y, _1816.z, finalColor.w);
    }
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
};

uniform modelWideBlockVS _133;

struct meshWideBlockVS
{
    ivec4 vertexShader_IsAffectedByLight;
    vec4 color_Transparency;
    mat4 uTextMat[2];
};

uniform meshWideBlockVS _230;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _240;

attribute vec3 aPosition;
attribute vec4 boneWeights;
attribute vec4 bones;
attribute vec3 aNormal;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vDiffuseColor;
varying vec2 vTexCoord;
attribute vec2 aTexCoord;
attribute vec2 aTexCoord2;
varying vec3 vNormal;
varying vec3 vPosition;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

float edgeScan(vec3 position, vec3 normal)
{
    float dotProductClamped = clamp(dot(-normalize(position), normal), 0.0, 1.0);
    return clamp(((2.7000000476837158203125 * dotProductClamped) * dotProductClamped) - 0.4000000059604644775390625, 0.0, 1.0);
}

void main()
{
    vec4 modelPoint = vec4(0.0);
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 boneTransformMat = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));
    mat4 _143 = _133.uBoneMatrixes[bones.x] * boneWeights.x;
    boneTransformMat = mat4(boneTransformMat[0] + _143[0], boneTransformMat[1] + _143[1], boneTransformMat[2] + _143[2], boneTransformMat[3] + _143[3]);
    mat4 _164 = _133.uBoneMatrixes[bones.y] * boneWeights.y;
    boneTransformMat = mat4(boneTransformMat[0] + _164[0], boneTransformMat[1] + _164[1], boneTransformMat[2] + _164[2], boneTransformMat[3] + _164[3]);
    mat4 _185 = _133.uBoneMatrixes[bones.z] * boneWeights.z;
    boneTransformMat = mat4(boneTransformMat[0] + _185[0], boneTransformMat[1] + _185[1], boneTransformMat[2] + _185[2], boneTransformMat[3] + _185[3]);
    mat4 _207 = _133.uBoneMatrixes[bones.w] * boneWeights.w;
    boneTransformMat = mat4(boneTransformMat[0] + _207[0], boneTransformMat[1] + _207[1], boneTransformMat[2] + _207[2], boneTransformMat[3] + _207[3]);
    mat4 placementMat = _133.uPlacementMat;
    vec4 lDiffuseColor = _230.color_Transparency;
    mat4 cameraMatrix = (_240.scene.uLookAtMat * placementMat) * boneTransformMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    mat4 param = _240.scene.uLookAtMat;
    mat4 param_1 = placementMat;
    mat4 param_2 = boneTransformMat;
    mat3 viewModelMatTransposed = (blizzTranspose(param) * blizzTranspose(param_1)) * blizzTranspose(param_2);
    vec3 normal = normalize(viewModelMatTransposed * aNormal);
    vec4 combinedColor = clamp(lDiffuseColor, vec4(0.0), vec4(1.0));
    vec4 combinedColorHalved = combinedColor * 0.5;
    vec3 param_3 = cameraPoint.xyz;
    vec3 param_4 = normal;
    vec2 envCoord = posToTexCoord(param_3, param_4);
    vec3 param_5 = cameraPoint.xyz;
    vec3 param_6 = normal;
    float edgeScanVal = edgeScan(param_5, param_6);
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vec2(0.0);
    int uVertexShader = _230.vertexShader_IsAffectedByLight.x;
    bool _305 = uVertexShader == 0;
    #if (VERTEXSHADER == 0)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _332 = uVertexShader == 1;
    #if (VERTEXSHADER == 1)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    #endif
    bool _347 = uVertexShader == 2;
    #if (VERTEXSHADER == 2)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _379 = uVertexShader == 3;
    #if (VERTEXSHADER == 3)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    #endif
    bool _403 = uVertexShader == 4;
    #if (VERTEXSHADER == 4)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _427 = uVertexShader == 5;
    #if (VERTEXSHADER == 5)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = envCoord;
    #endif
    bool _444 = uVertexShader == 6;
    #if (VERTEXSHADER == 6)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _476 = uVertexShader == 7;
    #if (VERTEXSHADER == 7)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _507 = uVertexShader == 8;
    #if (VERTEXSHADER == 8)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _546 = uVertexShader == 9;
    #if (VERTEXSHADER == 9)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _571 = uVertexShader == 10;
    #if (VERTEXSHADER == 10)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _594 = uVertexShader == 11;
    #if (VERTEXSHADER == 11)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _626 = uVertexShader == 12;
    #if (VERTEXSHADER == 12)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _659 = uVertexShader == 13;
    #if (VERTEXSHADER == 13)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = envCoord;
    #endif
    bool _677 = uVertexShader == 14;
    #if (VERTEXSHADER == 14)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _716 = uVertexShader == 15;
    #if (VERTEXSHADER == 15)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = vTexCoord3;
    #endif
    bool _748 = uVertexShader == 16;
    #if (VERTEXSHADER == 16)
    vec4 in_col0 = vec4(1.0);
    vDiffuseColor = vec4((in_col0.xyz * 0.5).x, (in_col0.xyz * 0.5).y, (in_col0.xyz * 0.5).z, in_col0.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vTexCoord3;
    #endif
    bool _780 = uVertexShader == 17;
    #if (VERTEXSHADER == 17)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _803 = uVertexShader == 18;
    #if (VERTEXSHADER == 18)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    gl_Position = _240.scene.uPMatrix * cameraPoint;
    vNormal = normal;
    vPosition = cameraPoint.xyz;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _215[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _222[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct LocalLight
{
    vec4 color;
    vec4 position;
    vec4 attenuation;
};

struct meshWideBlockPS
{
    ivec4 PixelShader_UnFogged_IsAffectedByLight_blendMode;
    vec4 uFogColorAndAlphaTest;
    vec4 uPcColor;
};

uniform meshWideBlockPS _448;

struct modelWideBlockPS
{
    InteriorLightParam intLight;
    LocalLight pc_lights[4];
    ivec4 lightCountAndBcHack;
    vec4 interiorExteriorBlend;
};

uniform modelWideBlockPS _471;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _510;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
};

uniform modelWideBlockVS _518;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;
uniform sampler2D uTexture4;

varying vec2 vTexCoord;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vDiffuseColor;
varying vec3 vPosition;
varying vec3 vNormal;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _50 = !applyLight;
    if (_50)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _66 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_66)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _104 = nDotUp >= 0.0;
        if (_104)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _144 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_144)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _168 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_168)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _215[blendMode], vec3(_222[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _234 = blendMode == 13;
    if (_234)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _386 = nDotSun > 0.0;
    if (_386)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec2 texCoord = vTexCoord;
    vec2 texCoord2 = vTexCoord2;
    vec2 texCoord3 = vTexCoord3;
    vec4 tex = texture2D(uTexture, texCoord);
    vec4 tex2 = texture2D(uTexture2, texCoord2);
    vec4 tex3 = texture2D(uTexture3, texCoord3);
    vec4 finalColor = vec4(0.0);
    vec4 meshResColor = vDiffuseColor;
    bool _452 = _448.PixelShader_UnFogged_IsAffectedByLight_blendMode.z == 1;
    vec3 accumLight;
    if (_452)
    {
        vec3 vPos3 = vPosition;
        vec3 vNormal3 = normalize(vNormal);
        vec3 lightColor = vec3(0.0);
        int count = int(_471.pc_lights[0].attenuation.w);
        LocalLight lightRecord;
        for (int index = 0; index < 4; index++)
        {
            bool _487 = index >= _471.lightCountAndBcHack.x;
            if (_487)
            {
                break;
            }
            lightRecord.color = _471.pc_lights[index].color;
            lightRecord.position = _471.pc_lights[index].position;
            lightRecord.attenuation = _471.pc_lights[index].attenuation;
            vec3 vectorToLight = (_510.scene.uLookAtMat * (_518.uPlacementMat * lightRecord.position)).xyz - vPos3;
            float distanceToLightSqr = dot(vectorToLight, vectorToLight);
            float distanceToLightInv = inversesqrt(distanceToLightSqr);
            float distanceToLight = distanceToLightSqr * distanceToLightInv;
            float diffuseTerm1 = max(dot(vectorToLight, vNormal3) * distanceToLightInv, 0.0);
            vec4 attenuationRec = lightRecord.attenuation;
            float attenuation = 1.0 - clamp((distanceToLight - attenuationRec.x) * (1.0 / (attenuationRec.z - attenuationRec.x)), 0.0, 1.0);
            vec3 attenuatedColor = lightRecord.color.xyz * attenuation;
            lightColor += vec3((attenuatedColor * attenuatedColor) * diffuseTerm1);
        }
        vec3 _585 = clamp(lightColor, vec3(0.0), vec3(1.0));
        meshResColor = vec4(_585.x, _585.y, _585.z, meshResColor.w);
        accumLight = mix(lightColor, meshResColor.xyz, vec3(float(_471.lightCountAndBcHack.y)));
    }
    float finalOpacity = 0.0;
    vec3 specular = vec3(0.0);
    vec3 matDiffuse;
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = _448.PixelShader_UnFogged_IsAffectedByLight_blendMode.z > 0;
    float param_3 = _471.interiorExteriorBlend.x;
    SceneWideParams param_4;
    param_4.uLookAtMat = _510.scene.uLookAtMat;
    param_4.uPMatrix = _510.scene.uPMatrix;
    param_4.uViewUp = _510.scene.uViewUp;
    param_4.uInteriorSunDir = _510.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _510.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _510.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _510.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _510.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _510.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _471.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _471.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = accumLight;
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0), specular), finalOpacity);
    bool _658 = finalColor.w < _448.uFogColorAndAlphaTest.w;
    if (_658)
    {
        discard;
    }
    int uUnFogged = _448.PixelShader_UnFogged_IsAffectedByLight_blendMode.y;
    bool _666 = uUnFogged == 0;
    if (_666)
    {
        vec3 sunDir = mix(_510.scene.uInteriorSunDir, _510.scene.extLight.uExteriorDirectColorDir, vec4(_471.interiorExteriorBlend.x)).xyz;
        PSFog arg;
        arg.densityParams = _510.fogData.densityParams;
        arg.heightPlane = _510.fogData.heightPlane;
        arg.color_and_heightRate = _510.fogData.color_and_heightRate;
        arg.heightDensity_and_endColor = _510.fogData.heightDensity_and_endColor;
        arg.sunAngle_and_sunColor = _510.fogData.sunAngle_and_sunColor;
        arg.heightColor_and_endFogDistance = _510.fogData.heightColor_and_endFogDistance;
        arg.sunPercentage = _510.fogData.sunPercentage;
        vec3 param_7 = finalColor.xyz;
        vec3 param_8 = vPosition;
        vec3 param_9 = sunDir;
        int param_10 = _448.PixelShader_UnFogged_IsAffectedByLight_blendMode.w;
        vec3 _711 = makeFog(arg, param_7, param_8, param_9, param_10);
        finalColor = vec4(_711.x, _711.y, _711.z, finalColor.w);
    }
    gl_FragData[0] = finalColor;
}


#version 100

struct meshWideBlockPS
{
    float gauss_offsets[5];
    float gauss_weights[5];
    vec2 uResolution;
};

uniform meshWideBlockPS _34;

uniform sampler2D u_sampler;
uniform sampler2D u_depth;

varying vec2 v_texcoord;

void main()
{
    float FXAA_SPAN_MAX = 8.0;
    float FXAA_REDUCE_MUL = 0.125;
    float FXAA_REDUCE_MIN = 0.0078125;
    vec3 rgbNW = texture2D(u_sampler, v_texcoord + (vec2(-1.0) / _34.uResolution)).xyz;
    vec3 rgbNE = texture2D(u_sampler, v_texcoord + (vec2(1.0, -1.0) / _34.uResolution)).xyz;
    vec3 rgbSW = texture2D(u_sampler, v_texcoord + (vec2(-1.0, 1.0) / _34.uResolution)).xyz;
    vec3 rgbSE = texture2D(u_sampler, v_texcoord + (vec2(1.0) / _34.uResolution)).xyz;
    vec3 rgbM = texture2D(u_sampler, v_texcoord).xyz;
    vec3 luma = vec3(0.2989999949932098388671875, 0.58700001239776611328125, 0.114000000059604644775390625);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM = dot(rgbM, luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y = (lumaNW + lumaSW) - (lumaNE + lumaSE);
    float dirReduce = max((((lumaNW + lumaNE) + lumaSW) + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) / _34.uResolution;
    vec3 rgbA = (texture2D(u_sampler, v_texcoord + (dir * (-0.16666667163372039794921875))).xyz + texture2D(u_sampler, v_texcoord + (dir * 0.16666667163372039794921875)).xyz) * 0.5;
    vec3 rgbB = (rgbA * 0.5) + ((texture2D(u_sampler, v_texcoord + (dir * (-0.5))).xyz + texture2D(u_sampler, v_texcoord + (dir * 0.5)).xyz) * 0.25);
    float lumaB = dot(rgbB, luma);
    bool _240 = (lumaB < lumaMin) || (lumaB > lumaMax);
    if (_240)
    {
        gl_FragData[0] = vec4(rgbA.x, rgbA.y, rgbA.z, gl_FragData[0].w);
    }
    else
    {
        gl_FragData[0] = vec4(rgbB.x, rgbB.y, rgbB.z, gl_FragData[0].w);
    }
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

attribute vec4 a_position;
varying vec2 v_texcoord;

void main()
{
    gl_Position = a_position;
    v_texcoord = (a_position.xy * 0.5) + vec2(0.5);
}


#version 100

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _36[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _43[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _275;

struct meshWideBlockPS
{
    vec4 uAlphaTestv;
    ivec4 uPixelShaderv;
};

uniform meshWideBlockPS _288;

uniform sampler2D uTexture;

varying vec2 vTexcoord0;
varying vec4 vColor;
varying vec3 vPosition;

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _36[blendMode], vec3(_43[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _57 = blendMode == 13;
    if (_57)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _216 = nDotSun > 0.0;
    if (_216)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec4 tex = texture2D(uTexture, vTexcoord0);
    vec4 finalColor = vec4(vColor.xyz * tex.xyz, tex.w * vColor.w);
    vec3 sunDir = _275.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _275.fogData.densityParams;
    arg.heightPlane = _275.fogData.heightPlane;
    arg.color_and_heightRate = _275.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _275.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _275.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _275.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _275.fogData.sunPercentage;
    vec3 param = finalColor.xyz;
    vec3 param_1 = vPosition;
    vec3 param_2 = sunDir;
    int param_3 = _288.uPixelShaderv.y;
    vec3 _318 = makeFog(arg, param, param_1, param_2, param_3);
    finalColor = vec4(_318.x, _318.y, _318.z, finalColor.w);
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _37;

attribute vec3 aPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec2 vTexcoord0;
attribute vec2 aTexcoord0;
varying vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vec4 vertexViewSpace = _37.scene.uLookAtMat * aPositionVec4;
    vPosition = vertexViewSpace.xyz;
    gl_Position = _37.scene.uPMatrix * vertexViewSpace;
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

varying vec4 vColor;

void main()
{
    gl_FragData[0] = vec4(vColor.xyz, 1.0);
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _51;

struct meshWideBlockVS
{
    vec4 skyColor[6];
};

uniform meshWideBlockVS _83;

attribute vec4 aPosition;
varying vec4 vColor;

void main()
{
    vec3 inputPos = aPosition.xyz;
    vec2 _20 = inputPos.xy / vec2(0.6875);
    inputPos = vec3(_20.x, _20.y, inputPos.z);
    bool _30 = inputPos.z > 0.0;
    float _31;
    if (_30)
    {
        _31 = inputPos.z / 0.292800009250640869140625;
    }
    else
    {
        _31 = inputPos.z;
    }
    inputPos.z = _31;
    vec4 cameraPos = _51.scene.uLookAtMat * vec4(inputPos, 1.0);
    vec3 _71 = cameraPos.xyz - _51.scene.uLookAtMat[3].xyz;
    cameraPos = vec4(_71.x, _71.y, _71.z, cameraPos.w);
    cameraPos.z = cameraPos.z;
    vColor = vec4(_83.skyColor[int(aPosition.w)].xyz, 1.0);
    gl_Position = _51.scene.uPMatrix * cameraPos;
}


#version 100

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _36[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _43[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct meshWideBlockPS
{
    vec4 color;
};

uniform meshWideBlockPS _242;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _266;

uniform sampler2D uTexture;

varying vec2 vTextCoords;
varying vec3 vPosition;

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _36[blendMode], vec3(_43[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _57 = blendMode == 13;
    if (_57)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _216 = nDotSun > 0.0;
    if (_216)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec3 finalColor = _242.color.xyz + texture2D(uTexture, vTextCoords).xyz;
    vec3 sunDir = _266.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _266.fogData.densityParams;
    arg.heightPlane = _266.fogData.heightPlane;
    arg.color_and_heightRate = _266.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _266.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _266.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _266.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _266.fogData.sunPercentage;
    vec3 param = finalColor;
    vec3 param_1 = vPosition;
    vec3 param_2 = sunDir;
    int param_3 = 2;
    finalColor = makeFog(arg, param, param_1, param_2, param_3);
    gl_FragData[0] = vec4(finalColor, 0.699999988079071044921875);
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _28;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _36;

attribute vec4 aPositionTransp;
varying vec2 vTextCoords;
varying vec3 vPosition;
attribute vec2 aTexCoord;

void main()
{
    vec4 aPositionVec4 = vec4(aPositionTransp.xyz, 1.0);
    mat4 cameraMatrix = _28.scene.uLookAtMat * _36.uPlacementMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    vTextCoords = aPositionVec4.xy * 0.02999999932944774627685546875;
    gl_Position = _28.scene.uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _215[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _222[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct meshWideBlockPS
{
    ivec4 UseLitColor_EnableAlpha_PixelShader_BlendMode;
    vec4 FogColor_AlphaTest;
};

uniform meshWideBlockPS _435;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _898;

struct modelWideBlockPS
{
    InteriorLightParam intLight;
};

uniform modelWideBlockPS _902;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

varying vec2 vTexCoord;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vColor;
varying vec4 vColor2;
varying vec3 vNormal;
varying vec4 vPosition;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _50 = !applyLight;
    if (_50)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _66 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_66)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _104 = nDotUp >= 0.0;
        if (_104)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _144 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_144)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _168 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_168)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _215[blendMode], vec3(_222[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _234 = blendMode == 13;
    if (_234)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _386 = nDotSun > 0.0;
    if (_386)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec4 tex = texture2D(uTexture, vTexCoord);
    vec4 tex2 = texture2D(uTexture2, vTexCoord2);
    vec4 tex3 = texture2D(uTexture3, vTexCoord3);
    bool _439 = _435.UseLitColor_EnableAlpha_PixelShader_BlendMode.y == 1;
    if (_439)
    {
        bool _446 = (tex.w - 0.501960813999176025390625) < 0.0;
        if (_446)
        {
            discard;
        }
    }
    int uPixelShader = _435.UseLitColor_EnableAlpha_PixelShader_BlendMode.z;
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 matDiffuse = vec3(0.0);
    vec3 env = vec3(0.0);
    float finalOpacity = 0.0;
    bool _460 = uPixelShader == (-1);
    #if (FRAGMENTSHADER == (-1))
    matDiffuse = (tex.xyz * vColor.xyz) + (tex2.xyz * vColor2.zyx);
    finalOpacity = tex.w;
    #endif
    bool _481 = uPixelShader == 0;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _496 = uPixelShader == 1;
    #if (FRAGMENTSHADER == 1)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _509 = uPixelShader == 2;
    #if (FRAGMENTSHADER == 2)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _522 = uPixelShader == 3;
    #if (FRAGMENTSHADER == 3)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = tex2.xyz * tex.w;
    finalOpacity = vColor.w;
    #endif
    bool _540 = uPixelShader == 4;
    #if (FRAGMENTSHADER == 4)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _553 = uPixelShader == 5;
    #if (FRAGMENTSHADER == 5)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = (tex.xyz * tex.w) * tex2.xyz;
    finalOpacity = vColor.w;
    #endif
    bool _574 = uPixelShader == 6;
    #if (FRAGMENTSHADER == 6)
    vec3 layer1 = tex.xyz;
    vec3 layer2 = mix(layer1, tex2.xyz, vec3(tex2.w));
    matDiffuse = (vColor.xyz * 2.0) * mix(layer2, layer1, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    bool _603 = uPixelShader == 7;
    #if (FRAGMENTSHADER == 7)
    vec4 colorMix = mix(tex2, tex, vec4(vColor2.w));
    matDiffuse = colorMix.xyz * (vColor.xyz * 2.0);
    env = (colorMix.xyz * colorMix.w) * tex3.xyz;
    finalOpacity = vColor.w;
    #endif
    bool _632 = uPixelShader == 8;
    #if (FRAGMENTSHADER == 8)
    vec3 layer1_1 = tex.xyz;
    vec3 layer2_1 = tex2.xyz;
    matDiffuse = (vColor.xyz * 2.0) * mix(layer2_1, layer1_1, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    bool _656 = uPixelShader == 9;
    #if (FRAGMENTSHADER == 9)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = (tex2.xyz * tex2.w) * vColor2.w;
    finalOpacity = vColor.w;
    #endif
    bool _678 = uPixelShader == 10;
    #if (FRAGMENTSHADER == 10)
    float mixFactor = clamp(tex3.w * vColor2.w, 0.0, 1.0);
    matDiffuse = (vColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(mixFactor)), tex.xyz, vec3(tex.w));
    finalOpacity = vColor.w;
    #endif
    bool _714 = uPixelShader == 11;
    #if (FRAGMENTSHADER == 11)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = ((tex.xyz * tex.w) * tex2.xyz) + ((tex3.xyz * tex3.w) * vColor2.w);
    finalOpacity = vColor.w;
    #endif
    bool _745 = uPixelShader == 12;
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vColor.xyz * 2.0) * mix(tex2.xyz, tex.xyz, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    bool _764 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    vec3 t1diffuse = tex2.xyz * (1.0 - tex2.w);
    matDiffuse = (vColor.xyz * 2.0) * mix(t1diffuse, tex.xyz, vec3(vColor2.w));
    env = (tex2.xyz * tex2.w) * (1.0 - vColor2.w);
    finalOpacity = vColor.w;
    #endif
    bool _798 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _812 = uPixelShader == 14;
    #if (FRAGMENTSHADER == 14)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _826 = uPixelShader == 15;
    #if (FRAGMENTSHADER == 15)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _839 = uPixelShader == 16;
    #if (FRAGMENTSHADER == 16)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _852 = uPixelShader == 17;
    #if (FRAGMENTSHADER == 17)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _865 = uPixelShader == 18;
    #if (FRAGMENTSHADER == 18)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _878 = uPixelShader == 19;
    #if (FRAGMENTSHADER == 19)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = true;
    float param_3 = vPosition.w;
    SceneWideParams param_4;
    param_4.uLookAtMat = _898.scene.uLookAtMat;
    param_4.uPMatrix = _898.scene.uPMatrix;
    param_4.uViewUp = _898.scene.uViewUp;
    param_4.uInteriorSunDir = _898.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _898.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _898.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _898.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _898.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _898.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _902.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _902.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = vec3(0.0);
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vColor2.xyz, vec3(0.0)), finalOpacity);
    bool _959 = finalColor.w < _435.FogColor_AlphaTest.w;
    if (_959)
    {
        discard;
    }
    PSFog arg;
    arg.densityParams = _898.fogData.densityParams;
    arg.heightPlane = _898.fogData.heightPlane;
    arg.color_and_heightRate = _898.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _898.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _898.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _898.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _898.fogData.sunPercentage;
    vec3 param_7 = finalColor.xyz;
    vec3 param_8 = vPosition.xyz;
    vec3 param_9 = _898.scene.extLight.uExteriorDirectColorDir.xyz;
    int param_10 = _435.UseLitColor_EnableAlpha_PixelShader_BlendMode.w;
    vec3 _998 = makeFog(arg, param_7, param_8, param_9, param_10);
    finalColor = vec4(_998.x, _998.y, _998.z, finalColor.w);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _93;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _111;

struct meshWideBlockVS
{
    ivec4 VertexShader_UseLitColor;
};

uniform meshWideBlockVS _182;

attribute vec3 aPosition;
varying vec4 vPosition;
attribute vec4 aColor;
varying vec3 vNormal;
attribute vec3 aNormal;
varying vec4 vColor;
varying vec4 vColor2;
attribute vec4 aColor2;
varying vec2 vTexCoord;
attribute vec2 aTexCoord;
varying vec2 vTexCoord2;
attribute vec2 aTexCoord2;
varying vec2 vTexCoord3;
attribute vec2 aTexCoord3;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

void main()
{
    vec4 worldPoint = _93.uPlacementMat * vec4(aPosition, 1.0);
    vec4 cameraPoint = _111.scene.uLookAtMat * worldPoint;
    mat4 viewModelMat = _111.scene.uLookAtMat * _93.uPlacementMat;
    mat4 param = _111.scene.uLookAtMat;
    mat4 param_1 = _93.uPlacementMat;
    mat3 viewModelMatTransposed = blizzTranspose(param) * blizzTranspose(param_1);
    gl_Position = _111.scene.uPMatrix * cameraPoint;
    vPosition = vec4(cameraPoint.xyz, aColor.w);
    vNormal = normalize(viewModelMatTransposed * aNormal);
    vColor = vec4(0.5, 0.499989986419677734375, 0.5, 1.0);
    vColor2 = vec4(aColor.zyx * 2.0, aColor2.w);
    int uVertexShader = _182.VertexShader_UseLitColor.x;
    #if (VERTEXSHADER == (-1))
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 0)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 1)
    vTexCoord = aTexCoord;
    vTexCoord2 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 2)
    vTexCoord = aTexCoord;
    vec3 param_2 = vPosition.xyz;
    vec3 param_3 = vNormal;
    vTexCoord2 = posToTexCoord(param_2, param_3);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 3)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 4)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 5)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    #endif
    #if (VERTEXSHADER == 6)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 7)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 8)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
}


#version 330

layout(std140) uniform modelWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDir_FogStart;
    vec4 uSunColor_uFogEnd;
    vec4 uAmbientLight;
    vec4 FogColor;
    int uNewFormula;
} _65;

uniform sampler2D uDiffuseTexture;
uniform sampler2D uNormalTexture;

in vec2 vChunkCoords;
in vec3 vPosition;
layout(location = 0) out vec4 fragColor;

void main()
{
    vec2 TextureCoords = vec2(vChunkCoords.x, vChunkCoords.y);
    vec4 texDiffuse = texture(uDiffuseTexture, TextureCoords);
    vec3 matDiffuse = texDiffuse.xyz;
    vec3 vNormal = (texture(uNormalTexture, TextureCoords).xyz * 2.0) - vec3(1.0);
    vNormal = vec3(-vNormal.z, -vNormal.x, vNormal.y);
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 fogColor = _65.FogColor.xyz;
    float fog_start = _65.uSunDir_FogStart.w;
    float fog_end = _65.uSunColor_uFogEnd.w;
    float fog_rate = 1.5;
    float fog_bias = 0.00999999977648258209228515625;
    float distanceToCamera = length(vPosition);
    float z_depth = distanceToCamera - fog_bias;
    float expFog = 1.0 / exp(max(0.0, z_depth - fog_start) * fog_rate);
    float heightFog = 1.0;
    expFog += heightFog;
    float endFadeFog = clamp((fog_end - distanceToCamera) / (0.699999988079071044921875 * fog_end), 0.0, 1.0);
    vec3 _123 = mix(fogColor, finalColor.xyz, vec3(min(expFog, endFadeFog)));
    finalColor = vec4(_123.x, _123.y, _123.z, finalColor.w);
    finalColor.w = 1.0;
    fragColor = finalColor;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    vec3 uPos;
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _55;

layout(location = 1) in float aIndex;
layout(location = 0) in float aHeight;
out vec2 vChunkCoords;
out vec3 vPosition;

void main()
{
    float stepX = floor(aIndex / 16641.0);
    float division = 129.0;
    bool _20 = stepX > 0.100000001490116119384765625;
    if (_20)
    {
        division = 128.0;
    }
    float offset = (stepX * 129.0) * 129.0;
    float iX = mod(aIndex - offset, division) + (stepX * 0.5);
    float iY = floor((aIndex - offset) / division) + (stepX * 0.5);
    vec4 worldPoint = vec4(_55.uPos.x - (iY * 4.166666507720947265625), _55.uPos.y - (iX * 4.166666507720947265625), aHeight, 1.0);
    vChunkCoords = vec2(iX / 128.0, iY / 128.0);
    vPosition = (_55.uLookAtMat * worldPoint).xyz;
    gl_Position = (_55.uPMatrix * _55.uLookAtMat) * worldPoint;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _221[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _228[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

layout(std140) uniform meshWideBlockPS
{
    vec4 uHeightScale;
    vec4 uHeightOffset;
    mat4 animationMat[4];
} _454;

layout(std140) uniform modelWideBlockPS
{
    ivec4 uUseHeightMixFormula;
} _494;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _736;

uniform sampler2D uAlphaTexture;
uniform sampler2D uLayerHeight0;
uniform sampler2D uLayerHeight1;
uniform sampler2D uLayerHeight2;
uniform sampler2D uLayerHeight3;
uniform sampler2D uLayer0;
uniform sampler2D uLayer1;
uniform sampler2D uLayer2;
uniform sampler2D uLayer3;

in vec2 vChunkCoords;
in vec4 vColor;
in vec3 vNormal;
in vec3 vVertexLighting;
in vec3 vPosition;
layout(location = 0) out vec4 outColor;

vec4 mixTextures(vec4 tex0, vec4 tex1, float alpha)
{
    return ((tex1 - tex0) * alpha) + tex0;
}

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _57 = !applyLight;
    if (_57)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _73 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_73)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _110 = nDotUp >= 0.0;
        if (_110)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _150 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_150)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _174 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_174)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _221[blendMode], vec3(_228[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _240 = blendMode == 13;
    if (_240)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _392 = nDotSun > 0.0;
    if (_392)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec2 vTexCoord = vChunkCoords;
    vec2 alphaCoord = vec2(vChunkCoords.x / 8.0, vChunkCoords.y / 8.0);
    vec3 alphaBlend = texture(uAlphaTexture, alphaCoord).yzw;
    vec2 tcLayer0 = (_454.animationMat[0] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer1 = (_454.animationMat[1] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer2 = (_454.animationMat[2] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer3 = (_454.animationMat[3] * vec4(vTexCoord, 0.0, 1.0)).xy;
    bool _498 = _494.uUseHeightMixFormula.x > 0;
    vec4 final;
    if (_498)
    {
        float minusAlphaBlendSum = 1.0 - clamp(dot(alphaBlend, vec3(1.0)), 0.0, 1.0);
        vec4 weightsVector = vec4(minusAlphaBlendSum, alphaBlend);
        float weightedTexture_x = minusAlphaBlendSum * ((texture(uLayerHeight0, tcLayer0).w * _454.uHeightScale.x) + _454.uHeightOffset.x);
        float weightedTexture_y = weightsVector.y * ((texture(uLayerHeight1, tcLayer1).w * _454.uHeightScale.y) + _454.uHeightOffset.y);
        float weightedTexture_z = weightsVector.z * ((texture(uLayerHeight2, tcLayer2).w * _454.uHeightScale.z) + _454.uHeightOffset.z);
        float weightedTexture_w = weightsVector.w * ((texture(uLayerHeight3, tcLayer3).w * _454.uHeightScale.w) + _454.uHeightOffset.w);
        vec4 weights = vec4(weightedTexture_x, weightedTexture_y, weightedTexture_z, weightedTexture_w);
        vec4 weights_temp = weights * (vec4(1.0) - clamp(vec4(max(max(weightedTexture_x, weightedTexture_y), max(weightedTexture_z, weightedTexture_w))) - weights, vec4(0.0), vec4(1.0)));
        vec4 weightsNormalized = weights_temp / vec4(dot(vec4(1.0), weights_temp));
        vec4 weightedLayer_0 = texture(uLayer0, tcLayer0) * weightsNormalized.x;
        vec3 matDiffuse_0 = weightedLayer_0.xyz;
        float specBlend_0 = weightedLayer_0.w;
        vec4 weightedLayer_1 = texture(uLayer1, tcLayer1) * weightsNormalized.y;
        vec3 matDiffuse_1 = matDiffuse_0 + weightedLayer_1.xyz;
        float specBlend_1 = specBlend_0 + weightedLayer_1.w;
        vec4 weightedLayer_2 = texture(uLayer2, tcLayer2) * weightsNormalized.z;
        vec3 matDiffuse_2 = matDiffuse_1 + weightedLayer_2.xyz;
        float specBlend_2 = specBlend_1 + weightedLayer_2.w;
        vec4 weightedLayer_3 = texture(uLayer3, tcLayer3) * weightsNormalized.w;
        vec3 matDiffuse_3 = matDiffuse_2 + weightedLayer_3.xyz;
        float specBlend_3 = specBlend_2 + weightedLayer_3.w;
        final = vec4(matDiffuse_3, specBlend_3);
    }
    else
    {
        vec4 tex1 = texture(uLayer0, tcLayer0);
        vec4 tex2 = texture(uLayer1, tcLayer1);
        vec4 tex3 = texture(uLayer2, tcLayer2);
        vec4 tex4 = texture(uLayer3, tcLayer3);
        vec4 param = tex1;
        vec4 param_1 = tex2;
        float param_2 = alphaBlend.x;
        vec4 param_3 = mixTextures(param, param_1, param_2);
        vec4 param_4 = tex3;
        float param_5 = alphaBlend.y;
        vec4 param_6 = mixTextures(param_3, param_4, param_5);
        vec4 param_7 = tex4;
        float param_8 = alphaBlend.z;
        final = mixTextures(param_6, param_7, param_8);
    }
    vec3 matDiffuse = (final.xyz * 2.0) * vColor.xyz;
    vec3 param_9 = matDiffuse;
    vec3 param_10 = vNormal;
    bool param_11 = true;
    float param_12 = 0.0;
    SceneWideParams param_13;
    param_13.uLookAtMat = _736.scene.uLookAtMat;
    param_13.uPMatrix = _736.scene.uPMatrix;
    param_13.uViewUp = _736.scene.uViewUp;
    param_13.uInteriorSunDir = _736.scene.uInteriorSunDir;
    param_13.extLight.uExteriorAmbientColor = _736.scene.extLight.uExteriorAmbientColor;
    param_13.extLight.uExteriorHorizontAmbientColor = _736.scene.extLight.uExteriorHorizontAmbientColor;
    param_13.extLight.uExteriorGroundAmbientColor = _736.scene.extLight.uExteriorGroundAmbientColor;
    param_13.extLight.uExteriorDirectColor = _736.scene.extLight.uExteriorDirectColor;
    param_13.extLight.uExteriorDirectColorDir = _736.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_14 = InteriorLightParam(vec4(0.0), vec4(0.0, 0.0, 0.0, 1.0));
    vec3 param_15 = vVertexLighting;
    vec4 finalColor = vec4(calcLight(param_9, param_10, param_11, param_12, param_13, param_14, param_15, vec3(0.0), vec3(0.0)), 1.0);
    float specBlend = final.w;
    vec3 halfVec = -normalize(_736.scene.extLight.uExteriorDirectColorDir.xyz + normalize(vPosition));
    vec3 lSpecular = _736.scene.extLight.uExteriorDirectColor.xyz * pow(max(0.0, dot(halfVec, vNormal)), 20.0);
    vec3 specTerm = vec3(specBlend) * lSpecular;
    vec3 _814 = finalColor.xyz + specTerm;
    finalColor = vec4(_814.x, _814.y, _814.z, finalColor.w);
    PSFog arg;
    arg.densityParams = _736.fogData.densityParams;
    arg.heightPlane = _736.fogData.heightPlane;
    arg.color_and_heightRate = _736.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _736.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _736.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _736.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _736.fogData.sunPercentage;
    vec3 param_16 = finalColor.xyz;
    vec3 param_17 = vPosition;
    vec3 param_18 = _736.scene.extLight.uExteriorDirectColorDir.xyz;
    int param_19 = 0;
    vec3 _848 = makeFog(arg, param_16, param_17, param_18, param_19);
    finalColor = vec4(_848.x, _848.y, _848.z, finalColor.w);
    finalColor.w = 1.0;
    outColor = finalColor;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _91;

layout(std140) uniform meshWideBlockVS
{
    vec4 uPos;
} _139;

layout(location = 4) in float aIndex;
layout(location = 0) in vec3 aHeight;
out vec2 vChunkCoords;
out vec3 vPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec3 vVertexLighting;
layout(location = 2) in vec4 aVertexLighting;
out vec3 vNormal;
layout(location = 3) in vec3 aNormal;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

void main()
{
    float iX = mod(aIndex, 17.0);
    float iY = floor(aIndex / 17.0);
    bool _61 = iX > 8.0100002288818359375;
    if (_61)
    {
        iY += 0.5;
        iX -= 8.5;
    }
    vec4 worldPoint = vec4(aHeight, 1.0);
    vChunkCoords = vec2(iX, iY);
    vPosition = (_91.scene.uLookAtMat * worldPoint).xyz;
    vColor = aColor;
    vVertexLighting = aVertexLighting.xyz;
    mat4 param = _91.scene.uLookAtMat;
    vNormal = blizzTranspose(param) * aNormal;
    gl_Position = (_91.scene.uPMatrix * _91.scene.uLookAtMat) * worldPoint;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
} _13;

layout(location = 0) out vec4 outColor;

void main()
{
    vec4 finalColor = _13.uColor;
    outColor = finalColor;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
} _21;

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _59;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4((aPosition.x * _21.uBBScale.x) + _21.uBBCenter.x, (aPosition.y * _21.uBBScale.y) + _21.uBBCenter.y, (aPosition.z * _21.uBBScale.z) + _21.uBBCenter.z, 1.0);
    gl_Position = ((_59.uPMatrix * _59.uLookAtMat) * _21.uPlacementMat) * worldPoint;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    int drawDepth;
    float uFarPlane;
    float uNearPlane;
} _10;

uniform sampler2D diffuse;

in vec2 texCoord;
layout(location = 0) out vec4 fragColor;

void main()
{
    bool _17 = _10.drawDepth == 1;
    vec4 finalColor;
    if (_17)
    {
        float f = _10.uFarPlane;
        float n = _10.uNearPlane;
        float z = (2.0 * n) / ((f + n) - (texture(diffuse, texCoord).x * (f - n)));
        finalColor = vec4(z, z, z, 255.0);
    }
    else
    {
        finalColor = vec4(texture(diffuse, texCoord).xyz, 255.0);
    }
    fragColor = finalColor;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    vec3 uColor;
} _22;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor = vec4(1.0);
    finalColor.w = 1.0;
    fragColor = finalColor;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _13;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 c_world = inverse(_13.uPMatrix) * vec4(aPosition, 1.0);
    c_world = (c_world * 1.0) / vec4(c_world.w);
    gl_Position = (_13.uPMatrix * _13.uLookAtMat) * vec4(c_world.xyz, 1.0);
}


#version 330

layout(std140) uniform modelWideBlockPS
{
    vec3 uColor;
} _19;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor = vec4(1.0, 1.0, 0.0, 1.0);
    fragColor = finalColor;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _19;

layout(location = 0) in vec2 aPosition;

void main()
{
    gl_Position = (_19.uPMatrix * _19.uLookAtMat) * vec4(aPosition, 0.0, 1.0);
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    vec3 uColor;
} _13;

layout(location = 0) out vec4 fragColor;
in vec4 vPos;

void main()
{
    fragColor = vec4(_13.uColor, 1.0);
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _19;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _29;

layout(location = 0) in vec3 aPosition;
out vec4 vPos;

void main()
{
    gl_Position = ((_19.uPMatrix * _19.uLookAtMat) * _29.uPlacementMat) * vec4(aPosition, 1.0);
    gl_PointSize = 10.0;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    vec4 uColor;
} _12;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor = _12.uColor;
    fragColor = finalColor;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _30;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _40;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4(aPosition, 1.0);
    gl_Position = ((_30.uPMatrix * _30.uLookAtMat) * _40.uPlacementMat) * worldPoint;
}


#version 330

layout(std140) uniform meshWideBlockVS
{
    float uWidth;
    float uHeight;
    float uX;
    float uY;
} _36;

out vec2 texCoord;
layout(location = 0) in vec2 position;

void main()
{
    texCoord = (position * 0.5) + vec2(0.5);
    gl_Position = vec4((((((position.x + 1.0) / 2.0) * _36.uWidth) + _36.uX) * 2.0) - 1.0, (((((position.y + 1.0) / 2.0) * _36.uHeight) + _36.uY) * 2.0) - 1.0, 0.5, 1.0);
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    vec4 texOffsetX;
    vec4 texOffsetY;
} _33;

uniform sampler2D texture0;

in vec2 texCoord;
layout(location = 0) out vec4 out_result;

void main()
{
    vec2 tex_offset = vec2(0.001000000047497451305389404296875);
    vec3 result = texture(texture0, texCoord).xyz * 0.0;
    result = vec3(0.0);
    result += (texture(texture0, texCoord + vec2(_33.texOffsetX.x * tex_offset.x, _33.texOffsetY.x * tex_offset.y)).xyz * 0.125);
    result += (texture(texture0, texCoord + vec2(_33.texOffsetX.y * tex_offset.x, _33.texOffsetY.y * tex_offset.y)).xyz * 0.375);
    result += (texture(texture0, texCoord + vec2(_33.texOffsetX.z * tex_offset.x, _33.texOffsetY.z * tex_offset.y)).xyz * 0.375);
    result += (texture(texture0, texCoord + vec2(_33.texOffsetX.w * tex_offset.x, _33.texOffsetY.w * tex_offset.y)).xyz * 0.125);
    out_result = vec4(result, 1.0);
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    vec4 blurAmount;
} _34;

uniform sampler2D screenTex;
uniform sampler2D blurTex;

in vec2 texCoord;
layout(location = 0) out vec4 Out_Color;

void main()
{
    vec4 screen = texture(screenTex, texCoord);
    vec3 blurred = texture(blurTex, texCoord).xyz;
    vec3 mixed = mix(screen.xyz, blurred, vec3(_34.blurAmount.z));
    vec3 glow = (blurred * blurred) * _34.blurAmount.w;
    Out_Color = vec4(mixed + glow, screen.w);
}


#version 330
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

uniform sampler2D Texture;

layout(location = 0) out vec4 Out_Color;
in vec4 Frag_Color;
in vec2 Frag_UV;

void main()
{
    Out_Color = Frag_Color * texture(Texture, Frag_UV);
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    mat4 ProjMtx;
} _30;

out vec2 Frag_UV;
layout(location = 1) in vec2 UV;
out vec4 Frag_Color;
layout(location = 2) in vec4 Color;
layout(location = 0) in vec2 Position;

void main()
{
    Frag_UV = UV;
    Frag_Color = Color;
    gl_Position = _30.ProjMtx * vec4(Position, 0.0, 1.0);
}


#version 330

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _36[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _43[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform meshWideBlockPS
{
    vec4 uAlphaTestv;
    ivec4 uPixelShaderv;
} _266;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _431;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

in vec2 vTexcoord0;
in vec2 vTexcoord1;
in vec2 vTexcoord2;
in vec4 vColor;
in vec3 vPosition;
layout(location = 0) out vec4 outputColor;

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _36[blendMode], vec3(_43[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _57 = blendMode == 13;
    if (_57)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _216 = nDotSun > 0.0;
    if (_216)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec4 tex = texture(uTexture, vTexcoord0);
    vec4 tex2 = texture(uTexture2, vTexcoord1);
    vec4 tex3 = texture(uTexture3, vTexcoord2);
    float uAlphaTest = _266.uAlphaTestv.x;
    bool _273 = tex.w < uAlphaTest;
    if (_273)
    {
        discard;
    }
    vec4 finalColor = vec4((tex * vColor).xyz, tex.w * vColor.w);
    int uNonOptPixelShader = _266.uPixelShaderv.x;
    bool _299 = uNonOptPixelShader == 0;
    if (_299)
    {
        vec3 matDiffuse = vColor.xyz * tex.xyz;
        finalColor = vec4(matDiffuse, tex.w * vColor.w);
    }
    else
    {
        bool _320 = uNonOptPixelShader == 1;
        if (_320)
        {
            vec4 textureMod = tex * tex2;
            float texAlpha = textureMod.w * tex3.w;
            float opacity = texAlpha * vColor.w;
            vec3 matDiffuse_1 = vColor.xyz * textureMod.xyz;
            finalColor = vec4(matDiffuse_1, opacity);
        }
        else
        {
            bool _352 = uNonOptPixelShader == 2;
            if (_352)
            {
                vec4 textureMod_1 = (tex * tex2) * tex3;
                float texAlpha_1 = textureMod_1.w;
                float opacity_1 = texAlpha_1 * vColor.w;
                vec3 matDiffuse_2 = vColor.xyz * textureMod_1.xyz;
                finalColor = vec4(matDiffuse_2, opacity_1);
            }
            else
            {
                bool _383 = uNonOptPixelShader == 3;
                if (_383)
                {
                    vec4 textureMod_2 = (tex * tex2) * tex3;
                    float texAlpha_2 = textureMod_2.w;
                    float opacity_2 = texAlpha_2 * vColor.w;
                    vec3 matDiffuse_3 = vColor.xyz * textureMod_2.xyz;
                    finalColor = vec4(matDiffuse_3, opacity_2);
                }
                else
                {
                    bool _414 = uNonOptPixelShader == 4;
                    if (_414)
                    {
                    }
                }
            }
        }
    }
    bool _420 = finalColor.w < uAlphaTest;
    if (_420)
    {
        discard;
    }
    vec3 sunDir = _431.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _431.fogData.densityParams;
    arg.heightPlane = _431.fogData.heightPlane;
    arg.color_and_heightRate = _431.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _431.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _431.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _431.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _431.fogData.sunPercentage;
    vec3 param = finalColor.xyz;
    vec3 param_1 = vPosition;
    vec3 param_2 = sunDir;
    int param_3 = _266.uPixelShaderv.y;
    vec3 _469 = makeFog(arg, param, param_1, param_2, param_3);
    finalColor = vec4(_469.x, _469.y, _469.z, finalColor.w);
    outputColor = finalColor;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _43;

layout(location = 0) in vec3 aPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec2 vTexcoord0;
layout(location = 2) in vec2 aTexcoord0;
out vec2 vTexcoord1;
layout(location = 3) in vec2 aTexcoord1;
out vec2 vTexcoord2;
layout(location = 4) in vec2 aTexcoord2;
out vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vTexcoord1 = aTexcoord1;
    vTexcoord2 = aTexcoord2;
    vec4 vertexViewSpace = _43.scene.uLookAtMat * aPositionVec4;
    vPosition = vertexViewSpace.xyz;
    gl_Position = _43.scene.uPMatrix * vertexViewSpace;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _215[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _222[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct LocalLight
{
    vec4 color;
    vec4 position;
    vec4 attenuation;
};

layout(std140) uniform meshWideBlockPS
{
    ivec4 PixelShader_UnFogged_IsAffectedByLight_blendMode;
    vec4 uFogColorAndAlphaTest;
    vec4 uTexSampleAlpha;
    vec4 uPcColor;
} _461;

layout(std140) uniform modelWideBlockPS
{
    InteriorLightParam intLight;
    LocalLight pc_lights[4];
    ivec4 lightCountAndBcHack;
    vec4 interiorExteriorBlend;
} _484;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _523;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
} _531;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;
uniform sampler2D uTexture4;

in vec2 vTexCoord;
in vec2 vTexCoord2;
in vec2 vTexCoord3;
in vec4 vDiffuseColor;
in vec3 vPosition;
in vec3 vNormal;
layout(location = 0) out vec4 outputColor;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _50 = !applyLight;
    if (_50)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _66 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_66)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _104 = nDotUp >= 0.0;
        if (_104)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _144 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_144)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _168 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_168)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _215[blendMode], vec3(_222[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _234 = blendMode == 13;
    if (_234)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _386 = nDotSun > 0.0;
    if (_386)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec2 texCoord = vTexCoord;
    vec2 texCoord2 = vTexCoord2;
    vec2 texCoord3 = vTexCoord3;
    vec4 tex = texture(uTexture, texCoord);
    vec4 tex2 = texture(uTexture2, texCoord2);
    vec4 tex3 = texture(uTexture3, texCoord3);
    vec4 tex2WithTextCoord1 = texture(uTexture2, texCoord);
    vec4 tex3WithTextCoord1 = texture(uTexture3, texCoord);
    vec4 tex4WithTextCoord2 = texture(uTexture4, texCoord2);
    vec4 finalColor = vec4(0.0);
    vec4 meshResColor = vDiffuseColor;
    bool _465 = _461.PixelShader_UnFogged_IsAffectedByLight_blendMode.z == 1;
    vec3 accumLight;
    if (_465)
    {
        vec3 vPos3 = vPosition;
        vec3 vNormal3 = normalize(vNormal);
        vec3 lightColor = vec3(0.0);
        int count = int(_484.pc_lights[0].attenuation.w);
        LocalLight lightRecord;
        for (int index = 0; index < 4; index++)
        {
            bool _500 = index >= _484.lightCountAndBcHack.x;
            if (_500)
            {
                break;
            }
            lightRecord.color = _484.pc_lights[index].color;
            lightRecord.position = _484.pc_lights[index].position;
            lightRecord.attenuation = _484.pc_lights[index].attenuation;
            vec3 vectorToLight = (_523.scene.uLookAtMat * (_531.uPlacementMat * lightRecord.position)).xyz - vPos3;
            float distanceToLightSqr = dot(vectorToLight, vectorToLight);
            float distanceToLightInv = inversesqrt(distanceToLightSqr);
            float distanceToLight = distanceToLightSqr * distanceToLightInv;
            float diffuseTerm1 = max(dot(vectorToLight, vNormal3) * distanceToLightInv, 0.0);
            vec4 attenuationRec = lightRecord.attenuation;
            float attenuation = 1.0 - clamp((distanceToLight - attenuationRec.x) * (1.0 / (attenuationRec.z - attenuationRec.x)), 0.0, 1.0);
            vec3 attenuatedColor = lightRecord.color.xyz * attenuation;
            lightColor += vec3((attenuatedColor * attenuatedColor) * diffuseTerm1);
        }
        vec3 _598 = clamp(lightColor, vec3(0.0), vec3(1.0));
        meshResColor = vec4(_598.x, _598.y, _598.z, meshResColor.w);
        accumLight = mix(lightColor, meshResColor.xyz, vec3(float(_484.lightCountAndBcHack.y)));
    }
    float finalOpacity = 0.0;
    vec3 specular = vec3(0.0);
    vec3 visParams = vec3(1.0);
    vec4 genericParams[3];
    genericParams[0] = vec4(1.0);
    genericParams[1] = vec4(1.0);
    genericParams[2] = vec4(1.0);
    int uPixelShader = _461.PixelShader_UnFogged_IsAffectedByLight_blendMode.x;
    bool _624 = uPixelShader == 0;
    vec3 matDiffuse;
    float opacity;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _645 = uPixelShader == 1;
    #if (FRAGMENTSHADER == 1)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _665 = uPixelShader == 2;
    #if (FRAGMENTSHADER == 2)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex2.w * vDiffuseColor.w;
    opacity = tex2.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _693 = uPixelShader == 3;
    #if (FRAGMENTSHADER == 3)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = (tex2.w * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _718 = uPixelShader == 4;
    #if (FRAGMENTSHADER == 4)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _739 = uPixelShader == 5;
    #if (FRAGMENTSHADER == 5)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _759 = uPixelShader == 6;
    #if (FRAGMENTSHADER == 6)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = (tex.w * tex2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _786 = uPixelShader == 7;
    #if (FRAGMENTSHADER == 7)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = ((tex.w * tex2.w) * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _815 = uPixelShader == 8;
    #if (FRAGMENTSHADER == 8)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _841 = uPixelShader == 9;
    #if (FRAGMENTSHADER == 9)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _866 = uPixelShader == 10;
    #if (FRAGMENTSHADER == 10)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _889 = uPixelShader == 11;
    #if (FRAGMENTSHADER == 11)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _913 = uPixelShader == 12;
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _940 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = tex2.xyz * tex2.w;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _963 = uPixelShader == 14;
    #if (FRAGMENTSHADER == 14)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _990 = uPixelShader == 15;
    #if (FRAGMENTSHADER == 15)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    specular = (tex3.xyz * tex3.w) * _461.uTexSampleAlpha.z;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1026 = uPixelShader == 16;
    #if (FRAGMENTSHADER == 16)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz * tex2.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1052 = uPixelShader == 17;
    #if (FRAGMENTSHADER == 17)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + (tex2.w * (((0.300000011920928955078125 * tex2.x) + (0.589999973773956298828125 * tex2.y)) + (0.10999999940395355224609375 * tex2.z)))) * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1100 = uPixelShader == 18;
    #if (FRAGMENTSHADER == 18)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex.xyz, tex2.xyz, vec3(tex2.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1130 = uPixelShader == 19;
    #if (FRAGMENTSHADER == 19)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1158 = uPixelShader == 20;
    #if (FRAGMENTSHADER == 20)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * _461.uTexSampleAlpha.y;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1184 = uPixelShader == 21;
    #if (FRAGMENTSHADER == 21)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1214 = uPixelShader == 22;
    #if (FRAGMENTSHADER == 22)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * tex2.xyz, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1241 = uPixelShader == 23;
    #if (FRAGMENTSHADER == 23)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * _461.uTexSampleAlpha.y;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1270 = uPixelShader == 24;
    #if (FRAGMENTSHADER == 24)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    specular = (tex.xyz * tex.w) * _461.uTexSampleAlpha.x;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1302 = uPixelShader == 25;
    #if (FRAGMENTSHADER == 25)
    float glowOpacity = clamp(tex3.w * _461.uTexSampleAlpha.z, 0.0, 1.0);
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w))) * (1.0 - glowOpacity);
    specular = tex3.xyz * glowOpacity;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1344 = uPixelShader == 26;
    #if (FRAGMENTSHADER == 26)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.z, 0.0, 1.0))).xyz;
    opacity = mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.z, 0.0, 1.0))).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1389 = uPixelShader == 27;
    #if (FRAGMENTSHADER == 27)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1423 = uPixelShader == 28;
    #if (FRAGMENTSHADER == 28)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.z, 0.0, 1.0))).xyz;
    opacity = (mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_461.uTexSampleAlpha.z, 0.0, 1.0))).w * tex4WithTextCoord2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1471 = uPixelShader == 29;
    #if (FRAGMENTSHADER == 29)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1495 = uPixelShader == 30;
    #if (FRAGMENTSHADER == 30)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1540 = uPixelShader == 31;
    #if (FRAGMENTSHADER == 31)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1575 = uPixelShader == 32;
    #if (FRAGMENTSHADER == 32)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1617 = uPixelShader == 33;
    #if (FRAGMENTSHADER == 33)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w * vDiffuseColor.w) * visParams.x;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1641 = uPixelShader == 34;
    #if (FRAGMENTSHADER == 34)
    finalColor = vec4(1.0);
    #endif
    bool _1647 = uPixelShader == 35;
    #if (FRAGMENTSHADER == 35)
    vec4 pc_channelScaler = vec4(1.0);
    matDiffuse = (vDiffuseColor.xyz * 2.0) * (((tex * tex2) * tex3) * pc_channelScaler).xyz;
    opacity = (((tex * tex2) * tex3) * pc_channelScaler).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1681 = uPixelShader == 36;
    #if (FRAGMENTSHADER == 36)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = (tex.w * tex2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = _461.PixelShader_UnFogged_IsAffectedByLight_blendMode.z > 0;
    float param_3 = _484.interiorExteriorBlend.x;
    SceneWideParams param_4;
    param_4.uLookAtMat = _523.scene.uLookAtMat;
    param_4.uPMatrix = _523.scene.uPMatrix;
    param_4.uViewUp = _523.scene.uViewUp;
    param_4.uInteriorSunDir = _523.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _523.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _523.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _523.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _523.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _523.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _484.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _484.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = accumLight;
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0), specular), finalOpacity);
    bool _1763 = finalColor.w < _461.uFogColorAndAlphaTest.w;
    if (_1763)
    {
        discard;
    }
    int uUnFogged = _461.PixelShader_UnFogged_IsAffectedByLight_blendMode.y;
    bool _1771 = uUnFogged == 0;
    if (_1771)
    {
        vec3 sunDir = mix(_523.scene.uInteriorSunDir, _523.scene.extLight.uExteriorDirectColorDir, vec4(_484.interiorExteriorBlend.x)).xyz;
        PSFog arg;
        arg.densityParams = _523.fogData.densityParams;
        arg.heightPlane = _523.fogData.heightPlane;
        arg.color_and_heightRate = _523.fogData.color_and_heightRate;
        arg.heightDensity_and_endColor = _523.fogData.heightDensity_and_endColor;
        arg.sunAngle_and_sunColor = _523.fogData.sunAngle_and_sunColor;
        arg.heightColor_and_endFogDistance = _523.fogData.heightColor_and_endFogDistance;
        arg.sunPercentage = _523.fogData.sunPercentage;
        vec3 param_7 = finalColor.xyz;
        vec3 param_8 = vPosition;
        vec3 param_9 = sunDir;
        int param_10 = _461.PixelShader_UnFogged_IsAffectedByLight_blendMode.w;
        vec3 _1816 = makeFog(arg, param_7, param_8, param_9, param_10);
        finalColor = vec4(_1816.x, _1816.y, _1816.z, finalColor.w);
    }
    outputColor = finalColor;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
} _133;

layout(std140) uniform meshWideBlockVS
{
    ivec4 vertexShader_IsAffectedByLight;
    vec4 color_Transparency;
    mat4 uTextMat[2];
} _230;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _240;

layout(location = 0) in vec3 aPosition;
layout(location = 3) in vec4 boneWeights;
layout(location = 2) in vec4 bones;
layout(location = 1) in vec3 aNormal;
out vec2 vTexCoord2;
out vec2 vTexCoord3;
out vec4 vDiffuseColor;
out vec2 vTexCoord;
layout(location = 4) in vec2 aTexCoord;
layout(location = 5) in vec2 aTexCoord2;
out vec3 vNormal;
out vec3 vPosition;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

float edgeScan(vec3 position, vec3 normal)
{
    float dotProductClamped = clamp(dot(-normalize(position), normal), 0.0, 1.0);
    return clamp(((2.7000000476837158203125 * dotProductClamped) * dotProductClamped) - 0.4000000059604644775390625, 0.0, 1.0);
}

void main()
{
    vec4 modelPoint = vec4(0.0);
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 boneTransformMat = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));
    mat4 _143 = _133.uBoneMatrixes[bones.x] * boneWeights.x;
    boneTransformMat = mat4(boneTransformMat[0] + _143[0], boneTransformMat[1] + _143[1], boneTransformMat[2] + _143[2], boneTransformMat[3] + _143[3]);
    mat4 _164 = _133.uBoneMatrixes[bones.y] * boneWeights.y;
    boneTransformMat = mat4(boneTransformMat[0] + _164[0], boneTransformMat[1] + _164[1], boneTransformMat[2] + _164[2], boneTransformMat[3] + _164[3]);
    mat4 _185 = _133.uBoneMatrixes[bones.z] * boneWeights.z;
    boneTransformMat = mat4(boneTransformMat[0] + _185[0], boneTransformMat[1] + _185[1], boneTransformMat[2] + _185[2], boneTransformMat[3] + _185[3]);
    mat4 _207 = _133.uBoneMatrixes[bones.w] * boneWeights.w;
    boneTransformMat = mat4(boneTransformMat[0] + _207[0], boneTransformMat[1] + _207[1], boneTransformMat[2] + _207[2], boneTransformMat[3] + _207[3]);
    mat4 placementMat = _133.uPlacementMat;
    vec4 lDiffuseColor = _230.color_Transparency;
    mat4 cameraMatrix = (_240.scene.uLookAtMat * placementMat) * boneTransformMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    mat4 param = _240.scene.uLookAtMat;
    mat4 param_1 = placementMat;
    mat4 param_2 = boneTransformMat;
    mat3 viewModelMatTransposed = (blizzTranspose(param) * blizzTranspose(param_1)) * blizzTranspose(param_2);
    vec3 normal = normalize(viewModelMatTransposed * aNormal);
    vec4 combinedColor = clamp(lDiffuseColor, vec4(0.0), vec4(1.0));
    vec4 combinedColorHalved = combinedColor * 0.5;
    vec3 param_3 = cameraPoint.xyz;
    vec3 param_4 = normal;
    vec2 envCoord = posToTexCoord(param_3, param_4);
    vec3 param_5 = cameraPoint.xyz;
    vec3 param_6 = normal;
    float edgeScanVal = edgeScan(param_5, param_6);
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vec2(0.0);
    int uVertexShader = _230.vertexShader_IsAffectedByLight.x;
    bool _305 = uVertexShader == 0;
    #if (VERTEXSHADER == 0)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _332 = uVertexShader == 1;
    #if (VERTEXSHADER == 1)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    #endif
    bool _347 = uVertexShader == 2;
    #if (VERTEXSHADER == 2)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _379 = uVertexShader == 3;
    #if (VERTEXSHADER == 3)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    #endif
    bool _403 = uVertexShader == 4;
    #if (VERTEXSHADER == 4)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _427 = uVertexShader == 5;
    #if (VERTEXSHADER == 5)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = envCoord;
    #endif
    bool _444 = uVertexShader == 6;
    #if (VERTEXSHADER == 6)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _476 = uVertexShader == 7;
    #if (VERTEXSHADER == 7)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _507 = uVertexShader == 8;
    #if (VERTEXSHADER == 8)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _546 = uVertexShader == 9;
    #if (VERTEXSHADER == 9)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _571 = uVertexShader == 10;
    #if (VERTEXSHADER == 10)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _594 = uVertexShader == 11;
    #if (VERTEXSHADER == 11)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _626 = uVertexShader == 12;
    #if (VERTEXSHADER == 12)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _659 = uVertexShader == 13;
    #if (VERTEXSHADER == 13)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = envCoord;
    #endif
    bool _677 = uVertexShader == 14;
    #if (VERTEXSHADER == 14)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _716 = uVertexShader == 15;
    #if (VERTEXSHADER == 15)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = vTexCoord3;
    #endif
    bool _748 = uVertexShader == 16;
    #if (VERTEXSHADER == 16)
    vec4 in_col0 = vec4(1.0);
    vDiffuseColor = vec4((in_col0.xyz * 0.5).x, (in_col0.xyz * 0.5).y, (in_col0.xyz * 0.5).z, in_col0.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vTexCoord3;
    #endif
    bool _780 = uVertexShader == 17;
    #if (VERTEXSHADER == 17)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _803 = uVertexShader == 18;
    #if (VERTEXSHADER == 18)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    gl_Position = _240.scene.uPMatrix * cameraPoint;
    vNormal = normal;
    vPosition = cameraPoint.xyz;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _215[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _222[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct LocalLight
{
    vec4 color;
    vec4 position;
    vec4 attenuation;
};

layout(std140) uniform meshWideBlockPS
{
    ivec4 PixelShader_UnFogged_IsAffectedByLight_blendMode;
    vec4 uFogColorAndAlphaTest;
    vec4 uPcColor;
} _448;

layout(std140) uniform modelWideBlockPS
{
    InteriorLightParam intLight;
    LocalLight pc_lights[4];
    ivec4 lightCountAndBcHack;
    vec4 interiorExteriorBlend;
} _471;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _510;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
} _518;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;
uniform sampler2D uTexture4;

in vec2 vTexCoord;
in vec2 vTexCoord2;
in vec2 vTexCoord3;
in vec4 vDiffuseColor;
in vec3 vPosition;
in vec3 vNormal;
layout(location = 0) out vec4 outputColor;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _50 = !applyLight;
    if (_50)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _66 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_66)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _104 = nDotUp >= 0.0;
        if (_104)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _144 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_144)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _168 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_168)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _215[blendMode], vec3(_222[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _234 = blendMode == 13;
    if (_234)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _386 = nDotSun > 0.0;
    if (_386)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec2 texCoord = vTexCoord;
    vec2 texCoord2 = vTexCoord2;
    vec2 texCoord3 = vTexCoord3;
    vec4 tex = texture(uTexture, texCoord);
    vec4 tex2 = texture(uTexture2, texCoord2);
    vec4 tex3 = texture(uTexture3, texCoord3);
    vec4 finalColor = vec4(0.0);
    vec4 meshResColor = vDiffuseColor;
    bool _452 = _448.PixelShader_UnFogged_IsAffectedByLight_blendMode.z == 1;
    vec3 accumLight;
    if (_452)
    {
        vec3 vPos3 = vPosition;
        vec3 vNormal3 = normalize(vNormal);
        vec3 lightColor = vec3(0.0);
        int count = int(_471.pc_lights[0].attenuation.w);
        LocalLight lightRecord;
        for (int index = 0; index < 4; index++)
        {
            bool _487 = index >= _471.lightCountAndBcHack.x;
            if (_487)
            {
                break;
            }
            lightRecord.color = _471.pc_lights[index].color;
            lightRecord.position = _471.pc_lights[index].position;
            lightRecord.attenuation = _471.pc_lights[index].attenuation;
            vec3 vectorToLight = (_510.scene.uLookAtMat * (_518.uPlacementMat * lightRecord.position)).xyz - vPos3;
            float distanceToLightSqr = dot(vectorToLight, vectorToLight);
            float distanceToLightInv = inversesqrt(distanceToLightSqr);
            float distanceToLight = distanceToLightSqr * distanceToLightInv;
            float diffuseTerm1 = max(dot(vectorToLight, vNormal3) * distanceToLightInv, 0.0);
            vec4 attenuationRec = lightRecord.attenuation;
            float attenuation = 1.0 - clamp((distanceToLight - attenuationRec.x) * (1.0 / (attenuationRec.z - attenuationRec.x)), 0.0, 1.0);
            vec3 attenuatedColor = lightRecord.color.xyz * attenuation;
            lightColor += vec3((attenuatedColor * attenuatedColor) * diffuseTerm1);
        }
        vec3 _585 = clamp(lightColor, vec3(0.0), vec3(1.0));
        meshResColor = vec4(_585.x, _585.y, _585.z, meshResColor.w);
        accumLight = mix(lightColor, meshResColor.xyz, vec3(float(_471.lightCountAndBcHack.y)));
    }
    float finalOpacity = 0.0;
    vec3 specular = vec3(0.0);
    vec3 matDiffuse;
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = _448.PixelShader_UnFogged_IsAffectedByLight_blendMode.z > 0;
    float param_3 = _471.interiorExteriorBlend.x;
    SceneWideParams param_4;
    param_4.uLookAtMat = _510.scene.uLookAtMat;
    param_4.uPMatrix = _510.scene.uPMatrix;
    param_4.uViewUp = _510.scene.uViewUp;
    param_4.uInteriorSunDir = _510.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _510.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _510.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _510.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _510.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _510.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _471.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _471.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = accumLight;
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0), specular), finalOpacity);
    bool _658 = finalColor.w < _448.uFogColorAndAlphaTest.w;
    if (_658)
    {
        discard;
    }
    int uUnFogged = _448.PixelShader_UnFogged_IsAffectedByLight_blendMode.y;
    bool _666 = uUnFogged == 0;
    if (_666)
    {
        vec3 sunDir = mix(_510.scene.uInteriorSunDir, _510.scene.extLight.uExteriorDirectColorDir, vec4(_471.interiorExteriorBlend.x)).xyz;
        PSFog arg;
        arg.densityParams = _510.fogData.densityParams;
        arg.heightPlane = _510.fogData.heightPlane;
        arg.color_and_heightRate = _510.fogData.color_and_heightRate;
        arg.heightDensity_and_endColor = _510.fogData.heightDensity_and_endColor;
        arg.sunAngle_and_sunColor = _510.fogData.sunAngle_and_sunColor;
        arg.heightColor_and_endFogDistance = _510.fogData.heightColor_and_endFogDistance;
        arg.sunPercentage = _510.fogData.sunPercentage;
        vec3 param_7 = finalColor.xyz;
        vec3 param_8 = vPosition;
        vec3 param_9 = sunDir;
        int param_10 = _448.PixelShader_UnFogged_IsAffectedByLight_blendMode.w;
        vec3 _711 = makeFog(arg, param_7, param_8, param_9, param_10);
        finalColor = vec4(_711.x, _711.y, _711.z, finalColor.w);
    }
    outputColor = finalColor;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    float gauss_offsets[5];
    float gauss_weights[5];
    vec2 uResolution;
} _34;

uniform sampler2D u_sampler;
uniform sampler2D u_depth;

in vec2 v_texcoord;
layout(location = 0) out vec4 outputColor;

void main()
{
    float FXAA_SPAN_MAX = 8.0;
    float FXAA_REDUCE_MUL = 0.125;
    float FXAA_REDUCE_MIN = 0.0078125;
    vec3 rgbNW = texture(u_sampler, v_texcoord + (vec2(-1.0) / _34.uResolution)).xyz;
    vec3 rgbNE = texture(u_sampler, v_texcoord + (vec2(1.0, -1.0) / _34.uResolution)).xyz;
    vec3 rgbSW = texture(u_sampler, v_texcoord + (vec2(-1.0, 1.0) / _34.uResolution)).xyz;
    vec3 rgbSE = texture(u_sampler, v_texcoord + (vec2(1.0) / _34.uResolution)).xyz;
    vec3 rgbM = texture(u_sampler, v_texcoord).xyz;
    vec3 luma = vec3(0.2989999949932098388671875, 0.58700001239776611328125, 0.114000000059604644775390625);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM = dot(rgbM, luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y = (lumaNW + lumaSW) - (lumaNE + lumaSE);
    float dirReduce = max((((lumaNW + lumaNE) + lumaSW) + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) / _34.uResolution;
    vec3 rgbA = (texture(u_sampler, v_texcoord + (dir * (-0.16666667163372039794921875))).xyz + texture(u_sampler, v_texcoord + (dir * 0.16666667163372039794921875)).xyz) * 0.5;
    vec3 rgbB = (rgbA * 0.5) + ((texture(u_sampler, v_texcoord + (dir * (-0.5))).xyz + texture(u_sampler, v_texcoord + (dir * 0.5)).xyz) * 0.25);
    float lumaB = dot(rgbB, luma);
    bool _240 = (lumaB < lumaMin) || (lumaB > lumaMax);
    if (_240)
    {
        outputColor = vec4(rgbA.x, rgbA.y, rgbA.z, outputColor.w);
    }
    else
    {
        outputColor = vec4(rgbB.x, rgbB.y, rgbB.z, outputColor.w);
    }
}


#version 330
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(location = 0) in vec4 a_position;
out vec2 v_texcoord;

void main()
{
    gl_Position = a_position;
    v_texcoord = (a_position.xy * 0.5) + vec2(0.5);
}


#version 330

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _36[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _43[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _275;

layout(std140) uniform meshWideBlockPS
{
    vec4 uAlphaTestv;
    ivec4 uPixelShaderv;
} _288;

uniform sampler2D uTexture;

in vec2 vTexcoord0;
in vec4 vColor;
in vec3 vPosition;
layout(location = 0) out vec4 outputColor;

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _36[blendMode], vec3(_43[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _57 = blendMode == 13;
    if (_57)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _216 = nDotSun > 0.0;
    if (_216)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec4 tex = texture(uTexture, vTexcoord0);
    vec4 finalColor = vec4(vColor.xyz * tex.xyz, tex.w * vColor.w);
    vec3 sunDir = _275.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _275.fogData.densityParams;
    arg.heightPlane = _275.fogData.heightPlane;
    arg.color_and_heightRate = _275.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _275.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _275.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _275.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _275.fogData.sunPercentage;
    vec3 param = finalColor.xyz;
    vec3 param_1 = vPosition;
    vec3 param_2 = sunDir;
    int param_3 = _288.uPixelShaderv.y;
    vec3 _318 = makeFog(arg, param, param_1, param_2, param_3);
    finalColor = vec4(_318.x, _318.y, _318.z, finalColor.w);
    outputColor = finalColor;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _37;

layout(location = 0) in vec3 aPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec2 vTexcoord0;
layout(location = 2) in vec2 aTexcoord0;
out vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vec4 vertexViewSpace = _37.scene.uLookAtMat * aPositionVec4;
    vPosition = vertexViewSpace.xyz;
    gl_Position = _37.scene.uPMatrix * vertexViewSpace;
}


#version 330
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(location = 0) out vec4 outputColor;
in vec4 vColor;

void main()
{
    outputColor = vec4(vColor.xyz, 1.0);
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _51;

layout(std140) uniform meshWideBlockVS
{
    vec4 skyColor[6];
} _83;

layout(location = 0) in vec4 aPosition;
out vec4 vColor;

void main()
{
    vec3 inputPos = aPosition.xyz;
    vec2 _20 = inputPos.xy / vec2(0.6875);
    inputPos = vec3(_20.x, _20.y, inputPos.z);
    bool _30 = inputPos.z > 0.0;
    float _31;
    if (_30)
    {
        _31 = inputPos.z / 0.292800009250640869140625;
    }
    else
    {
        _31 = inputPos.z;
    }
    inputPos.z = _31;
    vec4 cameraPos = _51.scene.uLookAtMat * vec4(inputPos, 1.0);
    vec3 _71 = cameraPos.xyz - _51.scene.uLookAtMat[3].xyz;
    cameraPos = vec4(_71.x, _71.y, _71.z, cameraPos.w);
    cameraPos.z = cameraPos.z;
    vColor = vec4(_83.skyColor[int(aPosition.w)].xyz, 1.0);
    gl_Position = _51.scene.uPMatrix * cameraPos;
}


#version 330

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _36[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _43[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform meshWideBlockPS
{
    vec4 color;
} _242;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _266;

uniform sampler2D uTexture;

in vec2 vTextCoords;
in vec3 vPosition;
layout(location = 0) out vec4 outputColor;

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _36[blendMode], vec3(_43[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _57 = blendMode == 13;
    if (_57)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _216 = nDotSun > 0.0;
    if (_216)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec3 finalColor = _242.color.xyz + texture(uTexture, vTextCoords).xyz;
    vec3 sunDir = _266.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _266.fogData.densityParams;
    arg.heightPlane = _266.fogData.heightPlane;
    arg.color_and_heightRate = _266.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _266.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _266.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _266.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _266.fogData.sunPercentage;
    vec3 param = finalColor;
    vec3 param_1 = vPosition;
    vec3 param_2 = sunDir;
    int param_3 = 2;
    finalColor = makeFog(arg, param, param_1, param_2, param_3);
    outputColor = vec4(finalColor, 0.699999988079071044921875);
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _28;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _36;

layout(location = 0) in vec4 aPositionTransp;
out vec2 vTextCoords;
out vec3 vPosition;
layout(location = 1) in vec2 aTexCoord;

void main()
{
    vec4 aPositionVec4 = vec4(aPositionTransp.xyz, 1.0);
    mat4 cameraMatrix = _28.scene.uLookAtMat * _36.uPlacementMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    vTextCoords = aPositionVec4.xy * 0.02999999932944774627685546875;
    gl_Position = _28.scene.uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

const vec3 _215[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _222[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

layout(std140) uniform meshWideBlockPS
{
    ivec4 UseLitColor_EnableAlpha_PixelShader_BlendMode;
    vec4 FogColor_AlphaTest;
} _435;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _898;

layout(std140) uniform modelWideBlockPS
{
    InteriorLightParam intLight;
} _902;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

in vec2 vTexCoord;
in vec2 vTexCoord2;
in vec2 vTexCoord3;
in vec4 vColor;
in vec4 vColor2;
in vec3 vNormal;
in vec4 vPosition;
layout(location = 0) out vec4 outputColor;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _50 = !applyLight;
    if (_50)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _66 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_66)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _104 = nDotUp >= 0.0;
        if (_104)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _144 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_144)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _168 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_168)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 validateFogColor(vec3 fogColor, int blendMode)
{
    return mix(fogColor, _215[blendMode], vec3(_222[blendMode]));
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    bool _234 = blendMode == 13;
    if (_234)
    {
        return final;
    }
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _386 = nDotSun > 0.0;
    if (_386)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec4 tex = texture(uTexture, vTexCoord);
    vec4 tex2 = texture(uTexture2, vTexCoord2);
    vec4 tex3 = texture(uTexture3, vTexCoord3);
    bool _439 = _435.UseLitColor_EnableAlpha_PixelShader_BlendMode.y == 1;
    if (_439)
    {
        bool _446 = (tex.w - 0.501960813999176025390625) < 0.0;
        if (_446)
        {
            discard;
        }
    }
    int uPixelShader = _435.UseLitColor_EnableAlpha_PixelShader_BlendMode.z;
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 matDiffuse = vec3(0.0);
    vec3 env = vec3(0.0);
    float finalOpacity = 0.0;
    bool _460 = uPixelShader == (-1);
    #if (FRAGMENTSHADER == (-1))
    matDiffuse = (tex.xyz * vColor.xyz) + (tex2.xyz * vColor2.zyx);
    finalOpacity = tex.w;
    #endif
    bool _481 = uPixelShader == 0;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _496 = uPixelShader == 1;
    #if (FRAGMENTSHADER == 1)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _509 = uPixelShader == 2;
    #if (FRAGMENTSHADER == 2)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _522 = uPixelShader == 3;
    #if (FRAGMENTSHADER == 3)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = tex2.xyz * tex.w;
    finalOpacity = vColor.w;
    #endif
    bool _540 = uPixelShader == 4;
    #if (FRAGMENTSHADER == 4)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _553 = uPixelShader == 5;
    #if (FRAGMENTSHADER == 5)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = (tex.xyz * tex.w) * tex2.xyz;
    finalOpacity = vColor.w;
    #endif
    bool _574 = uPixelShader == 6;
    #if (FRAGMENTSHADER == 6)
    vec3 layer1 = tex.xyz;
    vec3 layer2 = mix(layer1, tex2.xyz, vec3(tex2.w));
    matDiffuse = (vColor.xyz * 2.0) * mix(layer2, layer1, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    bool _603 = uPixelShader == 7;
    #if (FRAGMENTSHADER == 7)
    vec4 colorMix = mix(tex2, tex, vec4(vColor2.w));
    matDiffuse = colorMix.xyz * (vColor.xyz * 2.0);
    env = (colorMix.xyz * colorMix.w) * tex3.xyz;
    finalOpacity = vColor.w;
    #endif
    bool _632 = uPixelShader == 8;
    #if (FRAGMENTSHADER == 8)
    vec3 layer1_1 = tex.xyz;
    vec3 layer2_1 = tex2.xyz;
    matDiffuse = (vColor.xyz * 2.0) * mix(layer2_1, layer1_1, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    bool _656 = uPixelShader == 9;
    #if (FRAGMENTSHADER == 9)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = (tex2.xyz * tex2.w) * vColor2.w;
    finalOpacity = vColor.w;
    #endif
    bool _678 = uPixelShader == 10;
    #if (FRAGMENTSHADER == 10)
    float mixFactor = clamp(tex3.w * vColor2.w, 0.0, 1.0);
    matDiffuse = (vColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(mixFactor)), tex.xyz, vec3(tex.w));
    finalOpacity = vColor.w;
    #endif
    bool _714 = uPixelShader == 11;
    #if (FRAGMENTSHADER == 11)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = ((tex.xyz * tex.w) * tex2.xyz) + ((tex3.xyz * tex3.w) * vColor2.w);
    finalOpacity = vColor.w;
    #endif
    bool _745 = uPixelShader == 12;
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vColor.xyz * 2.0) * mix(tex2.xyz, tex.xyz, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    bool _764 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    vec3 t1diffuse = tex2.xyz * (1.0 - tex2.w);
    matDiffuse = (vColor.xyz * 2.0) * mix(t1diffuse, tex.xyz, vec3(vColor2.w));
    env = (tex2.xyz * tex2.w) * (1.0 - vColor2.w);
    finalOpacity = vColor.w;
    #endif
    bool _798 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _812 = uPixelShader == 14;
    #if (FRAGMENTSHADER == 14)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _826 = uPixelShader == 15;
    #if (FRAGMENTSHADER == 15)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _839 = uPixelShader == 16;
    #if (FRAGMENTSHADER == 16)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _852 = uPixelShader == 17;
    #if (FRAGMENTSHADER == 17)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _865 = uPixelShader == 18;
    #if (FRAGMENTSHADER == 18)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _878 = uPixelShader == 19;
    #if (FRAGMENTSHADER == 19)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = true;
    float param_3 = vPosition.w;
    SceneWideParams param_4;
    param_4.uLookAtMat = _898.scene.uLookAtMat;
    param_4.uPMatrix = _898.scene.uPMatrix;
    param_4.uViewUp = _898.scene.uViewUp;
    param_4.uInteriorSunDir = _898.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _898.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _898.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _898.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _898.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _898.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _902.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _902.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = vec3(0.0);
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vColor2.xyz, vec3(0.0)), finalOpacity);
    bool _959 = finalColor.w < _435.FogColor_AlphaTest.w;
    if (_959)
    {
        discard;
    }
    PSFog arg;
    arg.densityParams = _898.fogData.densityParams;
    arg.heightPlane = _898.fogData.heightPlane;
    arg.color_and_heightRate = _898.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _898.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _898.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _898.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _898.fogData.sunPercentage;
    vec3 param_7 = finalColor.xyz;
    vec3 param_8 = vPosition.xyz;
    vec3 param_9 = _898.scene.extLight.uExteriorDirectColorDir.xyz;
    int param_10 = _435.UseLitColor_EnableAlpha_PixelShader_BlendMode.w;
    vec3 _998 = makeFog(arg, param_7, param_8, param_9, param_10);
    finalColor = vec4(_998.x, _998.y, _998.z, finalColor.w);
    finalColor.w = 1.0;
    outputColor = finalColor;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _93;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _111;

layout(std140) uniform meshWideBlockVS
{
    ivec4 VertexShader_UseLitColor;
} _182;

layout(location = 0) in vec3 aPosition;
out vec4 vPosition;
layout(location = 5) in vec4 aColor;
out vec3 vNormal;
layout(location = 1) in vec3 aNormal;
out vec4 vColor;
out vec4 vColor2;
layout(location = 6) in vec4 aColor2;
out vec2 vTexCoord;
layout(location = 2) in vec2 aTexCoord;
out vec2 vTexCoord2;
layout(location = 3) in vec2 aTexCoord2;
out vec2 vTexCoord3;
layout(location = 4) in vec2 aTexCoord3;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

void main()
{
    vec4 worldPoint = _93.uPlacementMat * vec4(aPosition, 1.0);
    vec4 cameraPoint = _111.scene.uLookAtMat * worldPoint;
    mat4 viewModelMat = _111.scene.uLookAtMat * _93.uPlacementMat;
    mat4 param = _111.scene.uLookAtMat;
    mat4 param_1 = _93.uPlacementMat;
    mat3 viewModelMatTransposed = blizzTranspose(param) * blizzTranspose(param_1);
    gl_Position = _111.scene.uPMatrix * cameraPoint;
    vPosition = vec4(cameraPoint.xyz, aColor.w);
    vNormal = normalize(viewModelMatTransposed * aNormal);
    vColor = vec4(0.5, 0.499989986419677734375, 0.5, 1.0);
    vColor2 = vec4(aColor.zyx * 2.0, aColor2.w);
    int uVertexShader = _182.VertexShader_UseLitColor.x;
    #if (VERTEXSHADER == (-1))
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 0)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 1)
    vTexCoord = aTexCoord;
    vTexCoord2 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 2)
    vTexCoord = aTexCoord;
    vec3 param_2 = vPosition.xyz;
    vec3 param_3 = vNormal;
    vTexCoord2 = posToTexCoord(param_2, param_3);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 3)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 4)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 5)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    #endif
    #if (VERTEXSHADER == 6)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 7)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 8)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
}


